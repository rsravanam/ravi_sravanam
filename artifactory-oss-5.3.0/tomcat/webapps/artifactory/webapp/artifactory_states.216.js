webpackJsonp([5,7,8,9],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var AdminState = _interopRequire(__webpack_require__(172));

	var ArtifactState = _interopRequire(__webpack_require__(273));

	var BuildsState = _interopRequire(__webpack_require__(320));

	var HomeModule = _interopRequire(__webpack_require__(335));

	var OAuthErrorModule = _interopRequire(__webpack_require__(346));

	var notFound404 = _interopRequire(__webpack_require__(347));

	var Forbidden403 = _interopRequire(__webpack_require__(348));

	var Login = _interopRequire(__webpack_require__(349));

	var ChangePassword = _interopRequire(__webpack_require__(351));

	var ForgotPassword = _interopRequire(__webpack_require__(353));

	var UserProfile = _interopRequire(__webpack_require__(356));

	var ServerError5XX = _interopRequire(__webpack_require__(358));

	var ServerDown = _interopRequire(__webpack_require__(359));

	var BaseState = _interopRequire(__webpack_require__(360));

	var Search = _interopRequire(__webpack_require__(362));

	angular.module("artifactory.states", [AdminState.name, ArtifactState.name, BuildsState.name, HomeModule.name, OAuthErrorModule.name, notFound404.name, Forbidden403.name, Login.name, ChangePassword.name, ForgotPassword.name, UserProfile.name, ServerDown.name, ServerError5XX.name, BaseState.name, Search.name, "artifactory.services", "artifactory.dao", "cfp.hotkeys", "ui.router"]).run(changeStateHook);

	function changeStateHook(User, $rootScope, $q, JFrogNotifications, $location, $timeout, $state, ArtifactoryFeatures, FooterDao, ArtifactoryState, JFrogEventBus, OnBoardingWizard) {

	    var EVENTS = JFrogEventBus.getEventsDefinition();

	    JFrogEventBus.register(EVENTS.USER_LOGOUT, function (confirmDiscard) {
	        if (confirmDiscard === true) {
	            checkDiscardConfirmation($q).then(function () {
	                JFrogEventBus.dispatch(EVENTS.USER_LOGOUT);
	            });
	        }
	    });

	    $rootScope.$on("$locationChangeStart", function (e, newUrl) {
	        if (ArtifactoryState.getState("confirmDiscardModalOpen")) {
	            e.preventDefault();
	        }
	    });

	    $rootScope.$on("$locationChangeSuccess", function () {
	        if (window.ga) {
	            var gaTrackPage = ArtifactoryState.getState("gaTrackPage");
	            if (gaTrackPage && typeof gaTrackPage === "function") gaTrackPage();
	        }
	    });

	    var pendingOnboarding = false;
	    var firstStateChange = true;
	    $rootScope.$on("$stateChangeStart", function (e, toState, toParams, fromState, fromParams) {
	        if (firstStateChange) {
	            var _ret = (function () {
	                firstStateChange = false;
	                pendingOnboarding = true;
	                var pending = { toState: toState, toParams: toParams, search: $location.search() };
	                OnBoardingWizard.isSystemOnboarding().then(function (onBoarding) {
	                    pendingOnboarding = false;
	                    var redirectFromBintray = !!(pending.search.client_id && pending.search.code && pending.search.scope);
	                    var resetPassword = !!(pending.toState.name === "reset-password" && pending.search.key);
	                    if (onBoarding && !redirectFromBintray && !resetPassword) {
	                        $state.go("home").then(function () {
	                            OnBoardingWizard.show();
	                        });
	                    } else {
	                        $state.go(pending.toState.name, pending.toParams).then(function () {
	                            $location.search(pending.search);
	                        });
	                    }
	                });
	                e.preventDefault();
	                return {
	                    v: undefined
	                };
	            })();

	            if (typeof _ret === "object") return _ret.v;
	        }
	        var onboardingWizardOpen = ArtifactoryState.getState("onboardingWizardOpen");
	        if (toState.name !== "home" && (pendingOnboarding || onboardingWizardOpen === true)) {
	            e.preventDefault();
	            return;
	        }

	        if (fromState.name.startsWith("admin.") || fromState.name === "user_profile") {
	            if (!ArtifactoryState.getState("confirmDiscardModalOpen")) {
	                checkDiscardConfirmation($q, e).then(function () {
	                    $state.go(toState.name, toParams);
	                });
	            } else {
	                e.preventDefault();
	                return;
	            }
	        }
	        var saveAdminState = ArtifactoryState.getState("saveAdminState");

	        if (toState.name.startsWith("admin.") && !toState.name.match(/(?:.new|.edit)\b/) && saveAdminState && !e.defaultPrevented) {
	            ArtifactoryState.setState("lastAdminState", toState);
	            ArtifactoryState.setState("lastAdminStateParams", toParams);
	            ArtifactoryState.removeState("saveAdminState");
	        } else if (saveAdminState && !e.defaultPrevented) {
	            ArtifactoryState.removeState("saveAdminState");
	        }

	        if (fromState.name && toState.name && fromState.name != toState.name) {
	            JFrogEventBus.dispatch(EVENTS.CANCEL_SPINNER);
	        }

	        if (toState.name === "artifacts.browsers.search") {
	            //MOVED FROM artifacts.module.js to prevent error message (ui-router bug workaround)
	            JFrogEventBus.dispatch(EVENTS.SEARCH_URL_CHANGED, toParams);
	        } else if (fromState.name === "artifacts.browsers.search") {
	            JFrogEventBus.dispatch(EVENTS.CLEAR_SEARCH);
	        }

	        if (toState.name === "change-password" && !toParams.username) {
	            e.preventDefault();
	            $state.go("login");
	        }

	        if (toState.name === "oauth_error") {
	            e.preventDefault();

	            var message = $location.search().message;
	            var gotoState = localStorage.stateBeforeOAuth;

	            if (gotoState === "login") {
	                $state.go(gotoState, { oauthError: message, location: "replace" });
	            } else if (gotoState === "user_profile") {
	                JFrogNotifications.create({ error: message });
	                $state.go(gotoState, { location: "replace" });
	            } else {
	                JFrogNotifications.create({ error: message });
	                $state.go("home", { location: "replace" });
	            }
	        }

	        if (toState.name.match(/^builds/) && !User.getCurrent().getCanDeploy()) {
	            toParams.tab = "published";
	        }

	        if (toState.name === "login" && $location.path() !== "/login" && $location.path() !== "/forgot-password" && $location.path() !== "/change-password" && $location.path() !== "/oauth_error" && !$location.path().startsWith("/resetpassword") && !$location.path().startsWith("/404") && !$location.path().startsWith("/403")) {
	            var afterLogin = ArtifactoryState.getState("urlAfterLogin");
	            if (!afterLogin) ArtifactoryState.setState("urlAfterLogin", $location.path());
	        }

	        // Permissions:

	        if (!User.getCurrent().canView(toState.name, toParams)) {
	            if (User.getCurrent().isProWithoutLicense()) {
	                $timeout(function () {
	                    return $location.path("admin/configuration/register_pro");
	                });
	            } else {
	                if ($location.path() !== "/login") ArtifactoryState.setState("urlAfterLogin", $location.path());
	                e.preventDefault();
	                if (User.getCurrent().name === "anonymous") {
	                    JFrogNotifications.create({ error: "You are not authorized to view this page" });
	                    $timeout(function () {
	                        return $location.path("/login");
	                    });
	                } else {
	                    $timeout(function () {
	                        return $location.path("/403");
	                    });
	                }
	            }
	        }
	        // Features per license:
	        else {
	            (function () {
	                var feature = toParams.feature;
	                // Must verify footer data is available before checking (for initial page load)
	                FooterDao.get().then(function () {
	                    if (ArtifactoryFeatures.isDisabled(feature) || ArtifactoryFeatures.isHidden(feature)) {
	                        JFrogNotifications.create({ error: "Page unavailable" });
	                        e.preventDefault();
	                        $timeout(function () {
	                            return $location.path("/home");
	                        });
	                    }
	                });
	            })();
	        }

	        if (!e.defaultPrevented) {
	            JFrogEventBus.dispatch(EVENTS.CLOSE_MODAL);
	            if (ArtifactoryState.getState("clearErrorsOnStateChange")) {
	                ArtifactoryState.removeState("clearErrorsOnStateChange");
	                JFrogEventBus.dispatch(EVENTS.CLOSE_NOTIFICATIONS);
	            }
	        }
	    });
	}

	function checkDiscardConfirmation($q, e) {

	    var defer = $q.defer();
	    var forms = $("form");
	    var changeDiscovered = false;
	    for (var i = 0; i < forms.length; i++) {
	        var _ret = (function (i) {
	            var form = forms[i];
	            var controller = angular.element(form).controller();
	            if (controller && controller._$modelSaver$_ && controller._$modelSaver$_.confirmOnLeave && !controller._$modelSaver$_.isModelSaved()) {
	                changeDiscovered = true;

	                controller._$modelSaver$_.ask().then(function () {
	                    controller._$modelSaver$_.confirmOnLeave = false;
	                    defer.resolve();
	                });

	                return "break";
	            }
	        })(i);

	        if (_ret === "break") break;
	    }

	    if (!changeDiscovered && !e) {
	        defer.resolve();
	    } else if (changeDiscovered && e) {
	        e.preventDefault();
	    }

	    return defer.promise;
	}

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */
/***/ (function(module, exports) {

	"use strict";

	var events = {
	    ACTIVATE_TREE_SEARCH: "tree:search:activate",
	    TREE_SEARCH_CHANGE: "tree:search:change",
	    TREE_NODE_SELECT: "tree:node:select",
	    TREE_NODE_OPEN: "tree:node:open",
	    TREE_SEARCH_KEYDOWN: "tree:search:keydown",
	    TREE_SEARCH_CANCEL: "tree:search:cancel",
	    TREE_SEARCH_RUNNING: "tree:search:running",
	    TREE_COMPACT: "tree:compact",
	    TREE_REFRESH: "tree:refresh",
	    TREE_COLLAPSE_ALL: "tree:collapse:all",
	    TREE_DATA_IS_SET: "tree:hasdata",
	    SEARCH_COLLAPSE: "search:collapse",
	    SEARCH: "search",
	    CLEAR_SEARCH: "search:clear",

	    ACTION_WATCH: "action:watch", // node
	    ACTION_UNWATCH: "action:unwatch", // node
	    ACTION_COPY: "action:copy", // node, target
	    ACTION_MOVE: "action:move", // node, target
	    ACTION_COPY_STASH: "action:copystash", // repoKey
	    ACTION_MOVE_STASH: "action:movestash", // repoKey
	    ACTION_DISCARD_STASH: "action:discardstash", //
	    ACTION_DISCARD_FROM_STASH: "action:discardfromstash", //node
	    ACTION_REFRESH_STASH: "action:refreshstash", //
	    ACTION_EXIT_STASH: "action:exitstash", //
	    ACTION_DELETE: "action:delete", // node
	    ACTION_REFRESH: "action:refresh", // node
	    ACTION_DEPLOY: "action:deploy", // repoKey
	    ACTION_IGNORE_ALERT: "action:ignorealert",
	    ACTION_UNIGNORE_ALERT: "action:unignorealert",

	    BUILDS_BREADCRUMBS: "builds:breadcrumbs",

	    FOOTER_DATA_UPDATED: "footer:data:updated",

	    SHOW_SPINNER: "spinner:show",
	    HIDE_SPINNER: "spinner:hide",
	    CANCEL_SPINNER: "spinner:cancel",

	    USER_CHANGED: "user:changed",
	    USER_LOGOUT: "user:logout", //confirmDiscard (true/false)

	    TAB_NODE_CHANGED: "tabs:node:changed",

	    SEARCH_URL_CHANGED: "search:url:changed",

	    FOOTER_REFRESH: "footer:refresh",

	    REFRESH_SETMEUP_WIZARD: "refresh:setmeup:wizard",

	    REFRESH_PAGE_CONTENT: "refresh:page:content"
	};

	module.exports = events;

/***/ }),
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    API_URL: "../ui",
	    AUTH_LOGIN: "/auth/login?_spring_security_remember_me=",
	    AUTH_CURRENT: "/auth/current",
	    AUTH_LOGOUT: "/auth/logout",
	    AUTH_IS_SAML: "/auth/issaml",
	    AUTH_FORGOT_PASSWORD: "/auth/forgotpassword",
	    AUTH_VALIDATE_KEY: "/auth/validatetoken?key=",
	    AUTH_RESET_PASSWORD: "/auth/resetpassword?key=",
	    AUTH_LOGIN_DATA: "/auth/loginRelatedData",
	    AUTH_CAN_ANNOTATE: "/auth/canAnnotate?repoKey=",
	    CRYPTO: "/crypto",
	    SECURITY_CONFIG: "/securityconfig",
	    USERS: "/users",
	    GROUPS: "/groups",
	    GROUP_PERMISSION: "/groupPermission",
	    MAIL: "/mail",
	    REGISTER_PRO: "/registerlicense",
	    MANAGE_HA_LICENSES: "/manageLicenses",
	    PROXIES: "/proxies",
	    REVERSE_PROXIES: "/reverseProxies",
	    HTTPSSO: "/httpsso",
	    SSHSERVER: "/sshserver",
	    LICENSES: "/licenses",
	    HIGH_AVAILABILITY: "/highAvailability",
	    XRAY: "/xrayRepo",
	    XRAY_CONFIG: "/xrayConfig",
	    SAML_CONFIG: "/saml/config",
	    SAML_LOGOUT: "/saml/logoutRequest",
	    OAUTH_LOGIN: "/oauth2/loginRequest",
	    BINTRAY_SETTING: "/bintraysetting",
	    PROPERTY_SETS: "/propertysets",
	    BROWSE_FILESYSTEM: "/browsefilesystem",
	    BACKUP: "/backup",
	    SYSTEM_INFO: "/systeminfo",
	    CONFIG_DESCRIPTOR: "/configdescriptor",
	    SECURITY_DESCRIPTOR: "/securitydescriptor",
	    INDEXER: "/indexer",
	    STORAGE_SUMMARY: "/storagesummary",
	    TREE_BROWSER: "/treebrowser",
	    REPO_DATA: "/repodata",
	    CRON_TIME: "/crontime",
	    DATE_FORMAT: "/validations/dateformat",
	    NAME_VALIDATOR: "/validations/name",
	    UNIQUE_ID_VALIDATOR: "/validations/uniqueid",
	    XML_NAME_VALIDATOR: "/validations/xmlname",
	    ARTIFACT_PERMISSIONS: "/artifactpermissions",
	    ARTIFACT_GENERAL: "/artifactgeneral",
	    ARTIFACT_GENERAL_BINTRAY: "/artifactgeneral/bintray",
	    ARTIFACT_GENERAL_BINTRAY_DIST: "/artifactgeneral/bintray/dist",
	    ARTIFACT_VIEW_SOURCE: "/archiveViewSource",
	    ARTIFACT_BUILDS: "/artifactbuilds",
	    ARTIFACT_ACTIONS: "/artifactactions",
	    ARTIFACT_PROPERTIES: "/artifactproperties",
	    PREDEFINE_VALUES: "/predefinevalues",
	    REPO_PROPERTY_SET: "/repopropertyset",
	    ARTIFACT_WATCHES: "/artifactwatches",
	    ARTIFACT_SEARCH: "/artifactsearch",
	    DEPENDENCY_DECLARATION: "/dependencydeclaration",
	    ARTIFACT: "/artifact",
	    FOOTER: "/auth/screen/footer",
	    VIEWS: "/views",
	    CROWD: "/crowd",
	    EXPORT: "/artifactexport",
	    IMPORT: "/artifactimport",
	    MAINTENANCE: "/maintenance",
	    LDAP: "/ldap",
	    OAUTH: "/oauth",
	    CHECKSUMS: "/checksums",
	    FILTERED_RESOURCE: "/filteredResource",
	    LDAP_GROUPS: "/ldapgroups",
	    PUSH_TO_BINTRAY: "/pushToBintray",
	    BINTRAY_DISTRIBUTION: "/distribution",
	    GENERAL_CONFIG: "/generalConfig",
	    ONBOARDING: "/onboarding",
	    SIGNINGKEYS: "/signingkeys",
	    ACCESSTOKENS: "/admin/security/accesstokens",
	    KEYSTORE: "/keystore",
	    USER_PROFILE: "/userProfile",
	    SSH_CLIENT: "/sshClient",
	    USER_API_KEY: "/userApiKey",
	    BUILDS: "/builds",
	    BUILDS_INFO: "/buildsinfo", /// JUST FOR MOCK, WILL BE REMOVED
	    TARGET_PERMISSIONS: "/targetPermissions",
	    GENERAL_TAB_LICENSES: "/generalTabLicenses",
	    HOME_PAGE: "/home",
	    SYSTEM_LOGS: "/systemlogs",
	    SET_ME_UP: "/setMeUp",
	    SET_ME_UP_MAVEN: "/setMeUp/mavenSettings",
	    SET_ME_UP_GRADLE: "/setMeUp/gradleSettings",
	    SET_ME_UP_IVY: "/setMeUp/ivySettings",
	    SET_ME_UP_MAVEN_DISTRIBUTION: "/setMeUp/mavenDistributionManagement",
	    SET_ME_UP_MAVEN_SNIPPET: "/setMeUp/mavenSnippet",
	    SET_ME_UP_GRADLE_SNIPPET: "/setMeUp/gradleSnippet",
	    SET_ME_UP_IVY_SNIPPET: "/setMeUp/ivySnippet",
	    SET_ME_UP_REVERSE_PROXY_DATA: "/setMeUp/reverseProxyData",
	    REPOSITORIES: "/admin/repositories",
	    REPOSITORIES_LAYOUTS: "/admin/repolayouts",
	    STASH_RESULTS: "/stashResults",
	    SUPPORT_PAGE: "/userSupport",
	    SERVER_TIME: "/system/serverTime",
	    LICENSE_DETAILS: "/system/license",
	    BINARY_PROVIDERS_INFO: "/binary/providers/info",
	    DOCKER_STATUS: "/admin/repositories/getdockerstatus",
	    GLOBAL_REPLICATIONS_BLOCK: "/global/replications/config",
	    SUMOLOGIC: "/sumologic"
	};

/***/ }),
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	                admin: {
	                                advanced: {
	                                                maintenance: {
	                                                                garbageCronExpression: "The Cron expression that determines the frequency of garbage collection.\nFor detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                cleanupCronExpression: "The Cron expression that determines the frequency of artifacts cleanup.\nFor detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                runNow: "Remove unreferenced binaries from the underlying datastore.\nArtifactory periodically runs garbage collection to remove unused (deleted) binaries from the datastore.\nYou may also run datastore cleanup manually using this button.",
	                                                                enableQuotaControl: "Enable control over the amount of storage space used for binaries to avoid running out of disk space.",
	                                                                storageSpaceLimit: "The maximum percentage of disk capacity that the partition containing the binaries folder is allowed to use.\nOnce this limit has been reached, deployment is rejected with a 413 error (request entity\ntoo large) and an error message is displayed in the UI (visible to admin users only).\nWhen using filesystem storage, the partition checked is the one containing the\n'$ARTIFACTORY_HOME/data/filestore' directory.\nWhen using database BLOB storage, the partition checked is the one containing the\n'$ARTIFACTORY_HOME/data/cache' directory.",
	                                                                storageSpaceWarning: "The percentage of disk space usage, by the partition containing the binaries folder, that will trigger a warning.\nOnce this limit is reached a warning is logged and a warning message is displayed in the UI\n(visible to admin users only).",
	                                                                cronExpressionCleanup: "The Cron expression that determines the frequency at which unused artifacts are cleaned up. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                runUnusedCachedArtifactsCleanup: "Remove unused artifacts from all remote repository caches\naccording to the 'Keep Unused Artifacts(Hours)' setting for each remote repository.\nArtifactory periodically cleans up unused artifacts from all remote repository caches.\nYou can also run the cleanup manually using this button.",
	                                                                cleanVirtualRepositoriesNow: "Clean up internal data used by virtual repositories.\nCached POM files older than the number of hours defined in the 'virtualCacheCleanup.maxAgeHours' system property will be deleted.\nThe default is 168 hours (one week). Artifacts accessed through virtual repositories will not be affected by this.",
	                                                                compressTheInternetDatabase: "When using the internal Derby database, use this to clean up fragmented space that may remain\nafter delete operations.\nNOTE! It is recommended to run this when Artifactory activity is low because compression may not run its full course when\nstorage is busy (although this has no detrimental effect on the storage).",
	                                                                pruneUnreferencedData: "Running Artifactory with the wrong file system permissions on storage folders, or running out of storage space,\ncan result in unreferenced binary files and empty folders present in the filestore or cache folders. This action\nremoves unreferenced files and empty folders."

	                                                },
	                                                storageSummary: {
	                                                                itemsCount: "The total number of items (both files and folders) in your system.",
	                                                                optimization: "The ratio of Binaries Size to Artifacts Size.\nThis reflects how much the usage of storage in your system has been reduced by Artifactory using checksum storage.",
	                                                                artifactsCount: "The total number of artifacts pointing to the physical binaries stored on your system.",
	                                                                storageDirectory: "If Storage Type is \"filesystem\" then this is the path to the physical file store.\nIf Storage Type is \"fullDb\" then this is the path to the directory that caches binaries when they are extracted from the database.\nIf Storage Type is \"S3\" then this is the path to the directory that caches binaries from S3.\n\nIf Storage Type is \"Advanced Configuration\" then these are the paths of the corresponding binary providers, supplied by the advanced configuration.",
	                                                                centralConfigurationDescriptor: "",
	                                                                securityConfigurationDescriptor: ""
	                                                },
	                                                supportPage: {
	                                                                hideUserDetails: "This option will remove passwords and user related information from configuration files before generating the support info package."
	                                                }
	                                },
	                                configuration: {
	                                                general: {
	                                                                serverName: "A name that uniquely identifies this artifactory server instance across the network.",
	                                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs.",
	                                                                fileUploadMaxSize: "The maximum size (in MB) allowed for artifacts uploaded through the web UI.\nSet to '0' for unlimited size.",
	                                                                bintrayMaxFilesUpload: "The maximum number of files that can be uploaded to Bintray in a single operation.",
	                                                                dateFormat: "The format used to display dates.\nFor a detailed explanation see: <a href=\"http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html\" target=\"_blank\">Joda DateTimeFormat</a>",
	                                                                globalOfflineMode: "If set, Artifactory does not try to access remote resources to fetch artifacts.\nOnly cached and local artifacts are served",
	                                                                showAvailableAddonsInfo: "When set, Artifactory displays information about available Add-ons. This overrides any user-specific setting to hide information.",
	                                                                folderDownloadMaxFiles: "The maximum amount of artifacts that can be downloaded under one folder.",
	                                                                folderDownloadMaxSize: "The maximum size (in MB) of a folder that is allowed to be downloaded.",
	                                                                folderDownloadMaxParallel: "The maximum amount of folder download requests Artifactory will allow to run together.",
	                                                                retentionPeriodDays: "The maximum number of days to keep artifacts in the trashcan.",
	                                                                allowPermDeletes: "When deleting, users will be given an option to bypass the trash can and delete artifacts permanently.",
	                                                                blockReplications: "When set, replication will not be triggered regardless of configuration.",
	                                                                blockPushReplications: " When set, push replication will not be triggered regardless of configuration.",
	                                                                blockPullReplications: "When set, pull replication will not be triggered regardless of configuration."
	                                                },
	                                                licenseForm: {
	                                                                licenseKey: "A unique short name identifying the license.",
	                                                                longName: "A descriptive name for the license.",
	                                                                URLs: "A URL (or URLs separated by semicolon) pointing to the license's homepage.",
	                                                                regExp: "A regular expression used to match licenses of this type against license details in artifact module information.\nFor regular expression syntax reference please refer to the Pattern javadoc."

	                                                },
	                                                propertySetsForm: {},
	                                                proxyForm: {
	                                                                systemDefault: "Make this proxy the default for new remote repositories and for internal HTTP requests.",
	                                                                redirectingProxyTargetHosts: "An optional list of host names (separated by newline or comma) to which the proxy may redirect requests.\nThe credentials of the proxy are reused by requests redirected to any of these hosts."

	                                                },
	                                                reverseProxy: {
	                                                                serverName: "The server name that will be used to access Artifactory.\nShould be correlated with the base URL value.",
	                                                                publicAppContext: "The path which will be publicly used to access Artifactory. If Artifactory is accessible on the root of the server leave empty.",
	                                                                artifactoryServerName: "The internal server name for Artifactory which will be used by the web server to access the Artifactory machine.\nIf the web server is installed on the same machine as Artifactory you can use localhost, otherwise use the IP or hostname.",
	                                                                artifactoryAppContext: "The path which will be used to access the Artifactory application. If Artifactory is accessible on the root of the server leave empty.",
	                                                                sslCertificate: "The full path of the certificate file on the web server.",
	                                                                sslKey: "The full path of the key file on the web server."
	                                                },
	                                                mail: {
	                                                                enable: "The activity state of the configuration.",
	                                                                from: "The \"from\" address header to use in all outgoing messages (optional). ",
	                                                                subjectPrefix: "A prefix to use for the subject of all outgoing messages.",
	                                                                artifactoryURL: "The Artifactory URL to to link to in all outgoing messages (optional)."
	                                                },
	                                                bintray: {
	                                                                bintrayUsername: "The default Bintray user name that will be used by Artifactory in cases where an Artifactory\nuser doesn't have Bintray credentials defined.",
	                                                                bintrayAPIKey: "The default Bintray API Key that will be used by Artifactory in cases where an Artifactory\nuser doesn't have Bintray credentials defined."
	                                                },
	                                                registerPro: {
	                                                                licenseKey: "The license key is required for using Artifactory Add-ons."
	                                                }
	                                },
	                                import_export: {
	                                                repositories: {
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page.",
	                                                                targetLocalRepository: "Specifies the repository in which to place imported content.\nWhen importing to a single repository, the file structure within the folder you import from should be similar to:\nSELECTED_DIR\n|\n|--LIB_DIR_1\nBut when importing to all repositories, the file structure within the folder you import from should be similar to:\nSELECTED_DIR\n|\n|--REPOSITORY_NAME_DIR_1\n| |\n| |--LIB_DIR_1\n\nWhen importing to all repositories, make sure the names of the directories representing\nthe repositories in the archive, match the names of the target repositories in Artifactory.",
	                                                                repositoryZipFile: "The archive file from which to import content.\nWhen importing to a single repository, the file structure within the archive should be similar to:\nARCHIVE.ZIP\n|\n|--LIB_DIR_1\nWhen importing to all repositories, the file structure within the archive you import from should be similar to:\nARCHIVE.ZIP\n|\n|--REPOSITORY_NAME_DIR_1\n| |\n| |--LIB_DIR_1\nWhen importing to all repositories, make sure the names of the directories representing\nthe repositories in the archive, match the names of the target repositories in Artifactory.\nNOTE! Uploading the archive, does not import its content.\nTo import, select the Target Local Repository, upload the archive and click Import."
	                                                },
	                                                system: {
	                                                                excludeBuilds: "Exclude all builds from the export.",
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export.",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page."

	                                                },
	                                                stash: {
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export.",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page.",
	                                                                createArchive: "Export the results as a zip archive."
	                                                }
	                                },
	                                repositories: {
	                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs.",
	                                                xrayBlockMinSeverity: "Artifacts identified with an alert of the specified severity or above will be blocked for download.",
	                                                xrayBlockUnscanned: "Block download of artifacts that have not been scanned by Xray.",
	                                                localForm: {
	                                                                publicDescription: "Textual description of the repository. This description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form.",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included (**/*).",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*. By default no artifacts are excluded.",
	                                                                repositoryLayout: "The layout that the repository should use to store and identify modules.",
	                                                                checksumPolicy: "Checksum policy determines how Artifactory behaves when a client checksum for a deployed resource is missing or conflicts with the locally calculated checksum (bad checksum).\nFor more details, please refer to <a href=\"https://www.jfrog.com/confluence/display/RTF/Local+Repositories#LocalRepositories-ChecksumPolicy\">Checksum Policy</a>.",
	                                                                mavenSnapshotVersionBehavior: "Specifies the naming convention for Maven SNAPSHOT versions.\nThe options are -\nUnique: Version number is based on a time-stamp (default)\nNon-unique: Version number uses a self-overriding naming pattern of artifactId-version-SNAPSHOT.type\nDeployer: Respects the settings in the Maven client that is deploying the artifact.",
	                                                                maxUniqueSnapshots: "The maximum number of unique snapshots of a single artifact to store.\nOnce the number of snapshots exceeds this setting, older versions are removed.\nA value of 0 (default) indicates there is no limit, and unique snapshots are not cleaned up.",
	                                                                maxUniqueTags: "The maximum number of unique tags of a single Docker image to store in this repository.\nOnce the number tags for an image exceeds this setting, older tags are removed. A value of 0 (default) indicates there is no limit.",
	                                                                blackedOut: "When set, the repository does not participate in artifact resolution and new artifacts cannot be deployed.",
	                                                                yumMetadataFolderDepth: "The depth, relative to the repository's root folder, where RPM metadata is created.\nThis is useful when your repository contains multiple RPM repositories under parallel hierarchies.\nFor example, if your RPMs are stored under 'fedora/linux/$releasever/$basearch', specify a depth of 4.",
	                                                                yumGroupFileNames: "A comma-separated list of xml file names containing RPM group component definitions.\nArtifactory includes the group definitions as part of the calculated RPM metadata, as well as automatically generating a gzipped version of the group files, if required.",
	                                                                allowContentBrowsing: "When set, you may view content such as HTML or Javadoc files directly from Artifactory.\nThis may not be safe and therefore requires strict content moderation to prevent malicious users from uploading content that may compromise security (e.g., cross-site scripting attacks).",
	                                                                selectPropertySets: "Specifies the Property Sets to be used to construct the list of properties displayed when assigning properties to artifacts in this repository.\nThis is a convenience; not a restrictive measure. You can still assign any property to artifacts from the Properties tab.",
	                                                                cronExpressionReplication: "The Cron expression that determines when the next replication will be triggered. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                nextReplicationTime: "The next replication time based on the Cron expression.",
	                                                                enableEventReplication: "When set, additions and modifications are replicated as they occur.",
	                                                                trivialLayout: "When set, the repository will use the deprecated trivial layout.",
	                                                                forceNugetAuth: "Force basic authentication credentials in order to use this repository.",
	                                                                pathPrefix: "Limit replication to artifacts matching this sub-path under the source repository."
	                                                },
	                                                remoteForm: {
	                                                                publicDescription: "Textual description of the repository.\nThis description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form. ",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served.\nBy default, all artifacts are included (**/*).",
	                                                                nuGetDownloadContextPath: "The context path prefix through which NuGet downloads are served.\nFor example, the NuGet Gallery download URL is 'https://nuget.org/api/v2/package', so the repository\nURL should be configured as 'https://nuget.org' and the download context path should be configured as 'api/v2/package'.",
	                                                                nuGetFeedContextPath: "The context path prefix through which the NuGet feeds are served.\nFor example, the NuGet Gallery feed URL is 'https://nuget.org/api/v2', so the repository URL should be configured as 'https://nuget.org' and the feed context path should be configured as 'api/v2'.",
	                                                                eagerlyFetchJars: "When marked, the repository attempts to eagerly fetch the jar in the background each time a POM is requested.",
	                                                                eagerlyFetchSources: "When marked, the repository attempts to eagerly fetch the source jar in the background each time a jar is requested.",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*.\nBy default no artifacts are excluded.",
	                                                                dockerEnableTokenAuthentication: "Enable token (Bearer) based authentication.",
	                                                                checksumPolicy: "Checksum policy determines how Artifactory behaves when a client checksum for a deployed resource is missing or conflicts with the locally calculated checksum (bad checksum).\nFor more details, please refer to <a href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories#RemoteRepositories-ChecksumPolicy\">Checksum Policy</a>.",
	                                                                maxUniqueSnapshots: "The maximum number of unique snapshots of a single artifact to store.\nOnce the number of snapshots exceeds this setting, older versions are removed.\nA value of 0 (default) indicates there is no limit, and unique snapshots are not cleaned up.",
	                                                                listRemoteFolderItems: "Lists the items of remote folders in simple and list browsing. Required for dynamic resolution that depends on remote folder content information, such as remote Ivy version lookups. The remote content is cached according to the value of the\n'Retrieval Cache Period'.",
	                                                                blackedOut: "When set, the repository or its local cache do not participate in artifact resolution.",
	                                                                globalOfflineMode: "If set, Artifactory does not try to access remote resources to fetch artifacts. Only cached and local artifacts are served.",
	                                                                offline: "If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.",
	                                                                shareConfiguration: "If set, the configuration details of this remote repository can be publicly shared with remote clients such as other Artifactory servers.",
	                                                                repositoryLayout: "The layout that the repository should use to store and identify modules.",
	                                                                remoteLayoutMapping: "The layout that best matches that of the remote repository.\nPath-mapping takes place if the remote layout is different from the local layout.\nIn this case, remote module artifacts and descriptors are stored according to the local repository layout (e.g., Maven 1->Maven 2, or Maven 2->Ivy).",
	                                                                localAddress: "The local address to be used when creating connections.\nUseful for specifying the interface to use on systems with multiple network interfaces.",
	                                                                username: "Username for HTTP authentication.",
	                                                                password: "Password for HTTP authentication.",
	                                                                socketTimeout: "Network timeout (in ms) to use when establishing a connection and for unanswered requests.\nTiming out on a network operation is considered a retrieval failure.",
	                                                                lenientHostAuthentication: "Allow credentials of this repository to be used on requests redirected to any other host.",
	                                                                enableCookieManagement: "Enables cookie management if the remote repository uses cookies to manage client state.",
	                                                                keepUnusedArtifacts: "The number of hours to wait before an artifact is deemed \"unused\" and eligible for cleanup from the repository.\nA value of 0 means automatic cleanup of cached artifacts is disabled.",
	                                                                assumedOfflineLimit: "The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time, an online check is attempted in order to reset the offline status.\nA value of 0 means the repository is never assumed offline.",
	                                                                retrievalCachePeriod: "This value refers to the number of seconds to cache metadata files before checking for newer versions on remote server. A value of 0 indicates no caching.",
	                                                                missedRetrievalCachePeriod: "The number of seconds to cache artifact retrieval misses (artifact not found).     A value of 0 indicates no caching.",
	                                                                queryParams: "Custom HTTP query parameters that will be automatically included in all remote resource requests.\nFor example: param1=val1&ampparam2=val2&ampparam3=val3",
	                                                                allowContentBrowsing: "When set, you may view content such as HTML or Javadoc files directly from Artifactory.\nThis may not be safe and therefore requires strict content moderation to prevent malicious users from uploading content that may compromise security (e.g., cross-site scripting attacks).",
	                                                                storeArtifactsLocally: "When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory servers.",
	                                                                synchronizeArtifactoryProperties: "When set, remote artifacts are fetched along with their properties.",
	                                                                selectPropertySets: "Specifies the Property Sets to be used to construct the list of properties displayed when assigning properties to artifacts in this repository.\nThis is a convenience; not a restrictive measure. You can still assign any property to artifacts from the Properties tab.",
	                                                                cronExpression: "The Cron expression that determines artifact cleanup frequency. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                cronExpressionReplication: "The Cron expression that determines when the next replication will be triggered. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                syncDeletes: "Delete artifacts and folders that no longer exist in the source repository.",
	                                                                syncProperties: "Include metadata properties of files and folders as part of the replication.",
	                                                                pathPrefix: "Limit replication to artifacts matching this sub-path under the source repository.",
	                                                                bowerRegistryURL: "The remote Bower registry URL to communicate with.\nUsually the default value (https://bower.herokuapp.com) will be correct unless the remote resource is an Artifactory instance. In this case the value should match the remote repository URL.",
	                                                                nugetFeedContextPath: "The context path prefix through which the NuGet feeds are served.\nFor example, the NuGet Gallery feed URL is 'https://nuget.org/api/v2', so the repository URL should be configured as 'https://nuget.org' and the feed context path should be configured as 'api/v2'.",
	                                                                nugetDownloadContextPath: "The context path prefix through which NuGet downloads are served.\nFor example, the NuGet Gallery download URL is 'https://nuget.org/api/v2/package', so the repository\nURL should be configured as 'https://nuget.org' and the download context path should be configured as 'api/v2/package'.",
	                                                                smartSyncStatistics: "If set, download statistics for the artifact at the remote Artifactory instance will be updated each time a cached item is downloaded from your repository.",
	                                                                smartSyncProperties: "If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance.",
	                                                                smartListRemoteFolderItems: "If set, Artifactory lets you navigate the contents of the repository at the remote Artifactory instance, for all package types, even if the artifacts have not been cached in this repository.",
	                                                                originAbsenceDetection: "If set, Artifactory will check that cached artifacts' sources are available in the origin repository.",
	                                                                propagateQueryParams: "If set, the query params passed with the request to Artifactory, will be passed on to the remote repo.",
	                                                                rejectInvalidJars: "Reject the caching of jar files that are found to be invalid.\nFor example, pseudo jars retrieved behind a \"captive portal\".",
	                                                                blockMismatchingMimeTypes: "If set, artifacts will fail to download if a mismatch is detected between requested and received mimetype, according to the list specified in the system properties file under blockedMismatchingMimeTypes. You can override by adding mimetypes to the override list below."
	                                                },
	                                                virtualForm: {
	                                                                publicDescription: "Textual description of the repository.\nThis description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form. ",
	                                                                cleanupRepositoryReferencesinPOM: "(1) Discard Active References - Removes repository elements that are declared directly under project or under a profile in the same POM that is activeByDefault.\n(2) Discard Any References - Removes all repository elements regardless of whether they are included in an active profile or not.\n(3) Nothing - Does not remove any repository elements declared in the POM.",
	                                                                pathSuffix: "An optional sub-path inside the local repository where P2 metadata files reside.\nWhen left empty, P2 metadata files (content, artifacts, compositeContent, etc.) are assumed to reside directly under the repository's root.\nIf you have a Tycho repository deployed as a single archive, specify the archive's root path. For example: 'eclipse-repository.zip!'. ",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served.\nBy default, all artifacts are included (**/*).",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*.\nBy default no artifacts are excluded.",
	                                                                resolvedRepositories: "The resolved list of repositories.\nRepositories starting with an exclamation mark ('!') indicate that not all tokens can be mapped between the layout of this virtual repository and the marked repository.\nPath translations may not work as expected.",
	                                                                artifactoryRequestCanRetrieveRemoteArtifacts: "Determines whether artifact requests coming from other instance of Artifactory can be fulfilled by accessing this virtual repository's remote repositories, or by only accessing its caches (default).",
	                                                                externalDependenciesPatterns: "Optional include patterns to match external dependencies. Ant-style path expressions are supported (*, **, ?).\nFor example, specifying **/github.com/** will only allow external dependencies from github.com host.",
	                                                                cleanupRepositoryReferencesInPOMs: "(1) Discard Active References - Removes repository elements that are declared directly under a project or a profile in the same POM that is activeByDefault.\n(2) Discard Any References - Removes all repository elements regardless of whether they are included in an active profile or not.\n(3) Nothing - Does not remove any repository elements declared in the POM.",
	                                                                virtualRetrievalCachePeriod: "This value refers to the number of seconds to cache metadata files before checking for newer versions on aggregated repositories. A value of 0 indicates no caching.",
	                                                                keyPair: "A named key-pair that is used to sign artifacts automatically."

	                                                },
	                                                distributionForm: {
	                                                                includesPattern: "Properties on distributed artifacts with key that matches the list below will be added as a version attributes in Bintray.",
	                                                                repositoryVisibility: "Creating private Bintray repositories is available for <a href=\"https://www.jfrog.com/bintray/bintray-private-repo/\" target=\"_blank\">premium Bintray</a> accounts.",
	                                                                distributeProduct: "When set, the ${productName} token will be replaced in the distribution rules with the product name configured below. Also, Artifactory will create a <a href=\"https://bintray.com/docs/usermanual/uploads/uploads_products.html\" target=\"_blank\">Bintray product</a> and link the deployed packages to the product."
	                                                },
	                                                layoutsForm: {
	                                                                artifactPathPattern: "Please refer to: <a href=\"http://www.jfrog.com/confluence/display/RTF/Repository+Layouts#RepositoryLayouts-ModulesandPathPatternsusedbyRepositoryLayouts\" target=\"_blank\">Path Patterns</a> in the Artifactory Wiki documentation.",
	                                                                distinctiveDescriptorPathPattern: "Please refer to: <a href=\"http://www.jfrog.com/confluence/display/RTF/Repository+Layouts#RepositoryLayouts-DescriptorPathPatterns\" target=\"_blank\">Descriptor Path Patterns</a> in the Artifactory Wiki documentation.",
	                                                                folderIntegrationRevisionRegExp: "A regular expression matching the integration revision string appearing in a folder name\nas part of the artifact's path. For example, 'SNAPSHOT', in Maven.\nNote! Take care not to introduce any regexp capturing groups within this expression.\nIf not applicable use '.*'.",
	                                                                fileIntegrationRevisionRegExp: "A regular expression matching the integration revision string appearing in a file name\nas part of the artifact's path. For example, 'SNAPSHOT|(?:(?:[0-9]{8}.[0-9]{6})-(?:[0-9]+))',\nin Maven.\nNote! Take care not to introduce any regexp capturing groups within this expression.\nIf not applicable use '.*'."

	                                                },
	                                                reverseProxy: {
	                                                                registryPort: "This port will be binded to the Docker registry."
	                                                },
	                                                rulesPopup: {
	                                                                repositoryFilterTooltip: "<b>Repository Filter</b> -(Optional) Rule will only apply to repositories matching the regular expression.\n                                          You can reuse the capture values in anyone of the Bintray output fields. <a href='https://www.jfrog.com/confluence/display/RTF/Distribution+Repository#DistributionRepository-RepositoryandPathFilterParameters' target='_blank'> Click here </a> to read more about this field.",
	                                                                pathFilterToolip: "<b>Path Filter</b> - (Optional) Rule will only apply to artifacts with path matching the regular expression\n                                          You can reuse the capture values in anyone of the Bintray output fields. <a href='https://www.jfrog.com/confluence/display/RTF/Distribution+Repository#DistributionRepository-RepositoryandPathFilterParameters' target='_blank'> Click here </a> to read more about this field." }
	                                },
	                                security: {
	                                                general: {
	                                                                hideExistenceOfUnauthorizedResources: "When set, Artifactory hides the existence of unauthorized resources by sending a 404\nresponse (not found) to requests for resources that are not accessible by the user. Otherwise,\nthe response implies that the resource exists, but is protected,  by requesting authentication\nfor anonymous requests (401), or by denying an authenticated request for unauthorized users.",
	                                                                passwordEncryptionPolicy: "Determines the password requirements from users identified to Artifactory from a remote client such as Maven.\nThe options are:\n(1) Supported (default): Users can authenticate using secure encrypted passwords or clear-text passwords.\n(2) Required: Users must authenticate using secure encrypted passwords. Clear-text authentication fails.\n(3) Unsupported: Only clear-text passwords can be used for authentication.",
	                                                                encrypt: "Artifactory will generate a Master Encryption Key and encrypt all passwords in your configuration.",
	                                                                decrypt: "Artifactory will decrypt all passwords in your configuration.",
	                                                                passwordMaxAge: "The time interval in which users will be obligated to change their password",
	                                                                notifyByMail: "Users will receive an email notification X days before password will expire.\nMail server must be enabled and configured correctly."
	                                                },
	                                                usersForm: {
	                                                                disableInternalPassword: "When set, user's password is cleared which means that only external authentication is allowed (for example via an LDAP server)."
	                                                },
	                                                permissionsForm: {
	                                                                includePatterns: "Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\nAnt-style path expressions are supported (*, **, ?).\nFor example: \"org/apache/**\"",
	                                                                excludePatterns: "Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\nAnt-style path expressions are supported (*, **, ?).\nFor example: \"org/apache/**\""
	                                                },
	                                                LDAPSettingsForm: {
	                                                                LDAPURL: "Location of the LDAP server in the following format:\nldap://myserver:myport/dc=sampledomain,dc=com",
	                                                                userDNPattern: "A DN pattern that can be used to log users directly in to LDAP.\nThis pattern is used to create a DN string for 'direct' user authentication where the pattern is relative to the base DN in the LDAP URL.\nThe pattern argument {0} is replaced with the username. This only works if anonymous binding is allowed and a direct user DN can\nbe used, which is not the default case for Active Directory (use User DN search filter instead).\nExample: uid={0},ou=People",
	                                                                autoCreateArtifactoryUsers: "When set, users are automatically created when using LDAP. Otherwise, users are transient\nand associated with auto-join groups defined in Artifactory.",
	                                                                emailAttribute: "An attribute that can be used to map a user's email address to a user created\nautomatically in Artifactory.",
	                                                                searchFilter: "A filter expression used to search for the user DN used in LDAP authentication.\nThis is an LDAP search filter (as defined in 'RFC 2254') with optional arguments.\nIn this case, the username is the only argument, and is denoted by '{0}'.\nPossible examples are:\n(uid={0}) - This searches for a username match on the attribute.\nAuthentication to LDAP is performed from the DN found if successful.",
	                                                                searchBase: "(Optional) A context name to search in relative to the base DN of the LDAP URL. For example, 'ou=users'\nWith the LDAP Group Add-on enabled, it is possible to enter multiple search base entries\nseparated by a pipe ('|') character.",
	                                                                manageDN: "The full DN of the user that binds to the LDAP server to perform user searches.\nOnly used with \"search\" authentication.\n",
	                                                                managerPassword: "The password of the user that binds to the LDAP server to perform the search.\nOnly used with \"search\" authentication.",
	                                                                subTreeSearch: "When set, enables deep search through the sub tree of the LDAP URL + search base."
	                                                },
	                                                LDAPGroupsForm: {
	                                                                settingsName: "LDAP group key.",
	                                                                LDAPSetting: "Select the LDAP setting you want to use for group retrieval",
	                                                                "static": "Groups have a multi-value member attribute containing user DNs or User IDs.",
	                                                                dynamic: "Users have a mutli-value member attribute containing DNs or names of imported groups.\nDefault group association strategy for Active Directory.",
	                                                                hierarchy: "User DN contains one or more hierarchical name attributes of imported groups.\nFor example: cn=joe,ou=sales,ou=europe,dc=acme,dc=com implies Joe's membership in the 'sales' and 'europe' groups.",
	                                                                groupMemberAttribute: "A multi-value attribute on the group entry containing user DNs or IDs of the group members (e.g., uniqueMember,member).",
	                                                                groupNameAttribute: "Attribute on the group entry denoting the group name. Used when importing groups.",
	                                                                descriptionAttribute: "An attribute on the group entry which denoting the group description. Used when importing groups.",
	                                                                filter: "The LDAP filter used to search for group entries. Used when importing groups.",
	                                                                searchBase: "A search base for group entry DNs, relative to the DN on the LDAP server's URL (and not relative to the LDAP Setting's \"Search Base\"). Used when importing groups."
	                                                },
	                                                crowd_integration: {
	                                                                sessionValidationInterval: "The time window (min) during which the session does not need to be validated.",
	                                                                useJIRAUserServer: "Authenticate using credentials instead of the default session, token-based authentication.\nThis is required when using the JIRA User Server.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from a Crowd user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user in Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                useDefaultProxyConfiguration: "If a default proxy definition exists, it is used to pass through to the Crowd Server."

	                                                },
	                                                SAMLSSOSettings: {
	                                                                SAMLLoginURL: "The identity provider login URL (when you try to login, the service provider redirects to this URL).",
	                                                                SAMLLogoutURL: "The identity provider logout URL (when you try to logout, the service provider redirects to this URL).",
	                                                                SAMLServiceProviderName: "The Artifactory name in the SAML federation.",
	                                                                SAMLCertificate: "The certificate for SAML Authentication.\nNOTE! The certificate must contain the public key to allow Artifactory to verify sign-in requests.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from a SAML user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user inside Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generate API key.",
	                                                                autoRedirect: "When set, clicking on the login link will direct users to the configured SAML login URL.",
	                                                                syncGroups: "When set, in addition to the groups the user is already associated with, he will also be associated with the groups returned in the SAML login " + "response. Note that the user's association with the returned groups is not persistent. It is only valid for the current login session.",
	                                                                groupAttribute: "The group attribute in the SAML login XML response.",
	                                                                emailAttribute: "If Auto Create Artifactory Users is enabled or an internal user exists, Artifactory will set the user's email to the value in this attribute that is returned by the SAML login XML response."
	                                                },
	                                                OAuthSSO: {
	                                                                id: "Your OAuth2 id, given by the provider.",
	                                                                secret: "Your OAuth2 shared secret, given by the provider.",
	                                                                domain: "Google App domain accepted for authentication.",
	                                                                basicUrl: "The url used to acquire a token via basic auth.",
	                                                                authUrl: "The url used for the initial authentication step.",
	                                                                apiUrl: "The url used for api access, if needed to get user data.",
	                                                                tokenUrl: "The url used to acquire a token from the provider.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generate API key."
	                                                },
	                                                HTTPSSO: {
	                                                                artifactoryIsProxiedByASecureHTTPServer: "When set, Artifactory trusts incoming requests and reuses the remote user originally set on the request by the SSO of the HTTP server.\nThis is useful if you want to use existing enterprise SSO integrations, such as the powerful authentication schemes provided by Apache (mod_auth_ldap, mod_auth_ntlm, mod_auth_kerb, etc.).\nWhen Artifactory is deployed as a webapp on Tomcat behind Apache:\nIf using mod_proxy_ajp, be sure to set tomcatAuthentication=\"false\" on the AJP connector.\nIf using mod_jk, be sure to use the \"JkEnvVar REMOTE_USER\" directive in Apache's configuration.",
	                                                                remoteUserRequestVariable: "The name of the HTTP request variable to use for extracting the user identity.\nDefault is: REMOTE_USER.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from an SSO user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user inside Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generate API key."
	                                                },
	                                                SSHSERVER: {
	                                                                enableSshServer: "Enable SSH authentication.",
	                                                                serverPublicKey: "SSH Public Key to identify your server.",
	                                                                serverPrivateKey: "SSH Private Key to identify your server.",
	                                                                sshServerPort: "The port to use for SSH authentication. Default: 1337",
	                                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs."
	                                                },
	                                                signingKeys: {
	                                                                passPhrase: "Pass phrase required to use the installed keys. It can be saved or supplied with the REST API calls.\nThe \"Verify\" button checks that the keys and pass phrase match, and can be used to verify the pass phrase without saving it.\nIf keys are saved, we highly recommend using the Master Encryption Key feature."
	                                                }

	                                },
	                                services: {
	                                                backupsForm: {
	                                                                cronExpression: "The Cron expression that determines backup frequency. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>",
	                                                                serverPathForBackup: "The directory to which local repository data is backed up as files.\nThe default is $ARTIFACTORY_HOME/backup/[backup_key]",
	                                                                sendMailToAdminsIfThereAreBackupErrors: "Requires properly configured email settings and valid email addresses for admin users.",
	                                                                precalculateSpaceBeforeBackup: "Artifactory will estimate disk space needed for backup and verify it is available.",
	                                                                excludeBuilds: "Exclude all builds from the backup.",
	                                                                excludeNewRepositories: "Automatically exclude new repositories from the backup.",
	                                                                retentionPeriod: "The maximum number of hours to keep old backups in the destination directory.\nSetting the \"Incremental\" checkbox, indicates that backups are incrementally written\n(delta only) to the same directory: ${backupDir}/current. This \"in place\" backup is suitable\nfor file-system based backup support. In this mode, cleanup of old backups is inactive.\nThe default is 168 hours (7 days).",
	                                                                backUpToAZipArchive: "When set, the backup output should be a zip archive.\nOtherwise the output is to a directory (default)."

	                                                },
	                                                mavenIndexer: {
	                                                                cronExpression: "The Cron expression that determines indexer frequency. For detailed information, see <a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger\" target=\"_blank\">The CronTrigger Tutorial</a>"
	                                                }
	                                },
	                                logAnalytics: {
	                                                newConnection: "Use this option if you don't have a Client ID and Secret for Artifactory."
	                                }
	                },
	                artifacts: {
	                                deploy: {
	                                                targetRepo: "The target repository to which the artifact should be deployed.",
	                                                targetPath: "The relative path in the target repository. You can add key-value matrix parameters to deploy the artifacts with properties.\nFor more details, please refer to <a href=\"http://www.jfrog.com/confluence/display/RTF/Using+Properties+in+Deployment+and+Resolution#UsingPropertiesinDeploymentandResolution-IntroducingMatrixParameters\" target=\"_blank\"> Introducing Matrix Parameters</a>.",
	                                                deployAsMaven: "Deploy a Maven artifact where the target deployment path is based on Maven attributes.\nIf you want to specify the target deployment path manually, unset this option.",
	                                                deployAsDebian: "Deploying a Debian file to a Debian repository requires coordinates. Setting this flag lets you configure the Debian file coordinates",
	                                                noDeployPermission: "You do not have deploy permission" },
	                                pushToBintray: {
	                                                bintrayPackageName: "A target package name under the repository. You must create the package in Bintray first if it does not exist.",
	                                                bintrayPackageVersion: "A target version under the package.If the version does not yet exist in Bintray, it is automatically created."
	                                },
	                                browse: {
	                                                created: "The time this artifact was deployed to or cached in Artifactory.",
	                                                lastModified: "The time this artifact was modified. If this value is not available, the artifact's 'Created' value is used.\nThis can occur if the artifact is deployed without the 'X-Artifactory-Last-Modified' request header.",
	                                                licenses: "Scans the archive for a textual license file. The following file names are searched for:\nlicense,LICENSE,license.txt,LICENSE.txt,LICENSE.TXT\n(You can override this list by using the 'artifactory.archive.licenseFile.names' property).",
	                                                filtered: "Set this to have Artifactory serve the file as a filtered resource.\nA filtered textual resource is processed by the <a href=\"http://freemarker.org/\" target=\"_blank\">FreeMarker</a> engine before being returned to clients.\nThe context accessible to the template includes:\nProperties ,Security and Request. Javadocs can be found in the <a href=\"http://repo.jfrog.org/artifactory/libs-releases-local/org/artifactory/artifactory-papi/%5BRELEASE%5D/artifactory-papi-%5BRELEASE%5D-javadoc.jar!/index.html\" target=\"_blank\">Artifactory Public API</a>.",
	                                                lastReplicationStatus: "Displays the result of the latest run of this repository's scheduled replication.\nCan be one of the following:\nNever ran: Replication has not yet run.\nIncomplete: Replication has not yet completed or was interrupted.\nCompleted with errors: Replication errors were logged.\nCompleted with warnings: Replication warnings were logged.\nCompleted successfully: No errors or warnings logged.\nInconsistent: Replication status cannot be interpreted.",
	                                                recursive: "Add the property to all children of the current node."
	                                },
	                                search: {
	                                                stash: "The Stash lets you store search results for later use.\nOnce it is populated, you can add, subtract or intersect new search results to assemble just the right set of artifacts you need.\nThe Stash Browser displays all the artifacts in your stash and provides a convenient way to perform bulk operations.\nYou can copy or move the entire Stash to a repository, or perform actions on individual items."
	                                },

	                                general: {
	                                                /*name: 'Copy this link to navigate directly to this item in the tree browser.',*/
	                                                created: "The time this artifact was deployed to or cached in Artifactory",
	                                                filtered: "Set this to have Artifactory serve the file as a filtered resource.\nA filtered textual resource is processed by the <a href=\"http://freemarker.org/\" target=\"_blank\">FreeMarker</a> engine before being returned to clients.\nThe context accessible to the template includes:\nProperties ,Security and Request. Javadocs can be found in the <a href=\"http://repo.jfrog.org/artifactory/libs-releases-local/org/artifactory/artifactory-papi/%5BRELEASE%5D/artifactory-papi-%5BRELEASE%5D-javadoc.jar!/index.html\" target=\"_blank\">Artifactory Public API</a>."
	                                },
	                                selectTargetPathModal: {
	                                                targetRepoInput: ["Selects the target repository for the transferred items.", "Repositories starting with an exclamation mark ('!') indicate that not all tokens", "can be mapped between the layouts of the source repository and the marked repository.", "Path translations may not work as expected."].join(" "),
	                                                copyToCustomCheckbox: {
	                                                                copy: ["Enable copying and renaming to a custom target path. WARNING: This will cause", "the operation to suppress cross-layout translation when copying to different layouts.", "This means that your client may not be able to resolve the artifacts even in cases of a same-layout move."].join(" "),
	                                                                move: ["Enable moving and renaming to a custom target path. WARNING: This will cause", "the operation to suppress cross-layout translation when moving to different layouts.", "This means that your client may not be able to resolve the artifacts even in cases of a same-layout move."].join(" ")
	                                                },
	                                                customPathInput: {
	                                                                copy: ["Type the path in the target repository where the selected source should be copied to.", "NOTE: Copy operations are executed using Unix conventions (e.g.copying org/jfrog/example from", "a source repository to org/jfrog/example in a target repository will result in the contents of the source", "being copied to org/jfrog/example/example). To achieve the same path in the target repository, copy", "the source into one folder up in the hierarchy (i.e. copy source org/jfrog/example into target org/jfrog).", "If you leave the Target Path empty, the source will be moved into the target repository's root folder."].join(" "),
	                                                                move: ["Type the path in the target repository where the selected source should be moved to.", "NOTE: Move operations are executed using Unix conventions (e.g. moving org/jfrog/example from", "a source repository to org/jfrog/example in a target repository will result in the contents of the source", "being moved to org/jfrog/example/example). To achieve the same path in the target repository, move", "the source into one folder up in the hierarchy (i.e. move source org/jfrog/example into target org/jfrog).", "If you leave the Target Path empty, the source will be moved into the target repository's root folder."].join(" ")
	                                                }

	                                }
	                },
	                builds: {
	                                summary: "An artifact license can have one of the following statuses:\nUnapproved: The license found is not approved.\nUnknown: License information was found but cannot be related to any license managed in Artifactory.\nNot Found: No license information could be found for the artifact.\nNeutral: The license found is not approved, however another approved license was found for the artifact.\nApproved: The license found is approved.",
	                                includePublishedArtifacts: "Include the build's published module artifacts in the license report if they are also used as dependencies for other modules in this build.",
	                                IncludeDependenciesOfTheFollowingScopes: "Include the build's published module dependencies in the license report.\nYou can optionally select the dependency scopes to include.",
	                                autoFindLicenses: "Automatically extract license data from artifacts' module information.\nWhen an artifact has conflicting licenses already attached, you can select whether\nto override these licenses with the ones found.",
	                                name: "The Code Center application name. Click on the link to navigate to this application in Code Center."
	                },
	                userProfile: {
	                                apiKey: "Your API key can be used to authenticate you when using the REST API.\nTo use the API key, add the following header to all REST API calls: 'X-JFrog-Art-Api: &ltYOUR_API_KEY&gt'"
	                }

	};

/***/ }),
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    Watch: { title: "Watch", icon: "icon-watch" },
	    Unwatch: { title: "Unwatch", icon: "icon-unwatch" },
	    Download: { title: "Download", icon: "icon-download" },
	    DownloadFolder: { title: "Download", icon: "icon-download" },
	    View: { title: "View", icon: "icon-view" },
	    Delete: { title: "Delete", icon: "icon-clear" },
	    DeletePermanently: { title: "Delete Permanently", icon: "icon-clear" },
	    Copy: { title: "Copy", icon: "icon-copy" },
	    Move: { title: "Move", icon: "icon-move" },
	    CopyStash: { title: "Copy Stash to Repository", icon: "icon-copy" },
	    MoveStash: { title: "Move Stash to Repository", icon: "icon-move" },
	    ShowInTree: { title: "Show In Tree", icon: "icon-show-in-tree" },
	    DiscardFromStash: { title: "Discard from Stash", icon: "icon-delete-content" },
	    DiscardStash: { title: "Discard Search Results", icon: "icon-delete-content" },
	    DeleteContent: { title: "Delete Content", icon: "icon-clear" },
	    CopyContent: { title: "Copy Content", icon: "icon-copy" },
	    MoveContent: { title: "Move Content", icon: "icon-move" },
	    DeleteVersions: { title: "Delete Versions", icon: "icon-delete-versions" },
	    Refresh: { title: "Refresh", icon: "icon-refresh" },
	    UploadToBintray: { title: "Push to Bintray", icon: "icon-bintray" },
	    Distribute: { title: "Distribute", icon: "icon-distribution-repo" },
	    Redistribute: { title: "Redistribute", icon: "icon-distribution-repo" },
	    Zap: { title: "Zap Cache", icon: "icon-zap" },
	    ZapCaches: { title: "Zap Caches", icon: "icon-zap" },
	    RecalculateIndex: { title: "Recalculate Index", icon: "icon-re-index" },
	    NativeBrowser: { title: "Native Browser", icon: "icon-simple-browser" },
	    EmptyTrash: { title: "Empty Trash Can", icon: "icon-trash" },
	    SearchTrash: { title: "Search Trash Can", icon: "icon-search" },
	    Restore: { title: "Restore", icon: "icon-trashcan-restore" },
	    IgnoreAlert: { title: "Ignore Alert", icon: "icon-xray-ignore-alert" },
	    UnignoreAlert: { title: "Un-Ignore Alert", icon: "icon-xray-alert" }
	};

/***/ }),
/* 160 */
/***/ (function(module, exports) {

	/**
	 * Created by tomere on 2/22/2017.
	 */
	"use strict";

	module.exports = {
	    actions: {
	        distribute: {
	            noRepos: {
	                admin: {
	                    message: "No distribution repositories are configured. To distribute artifacts and builds, <a href=\"#/admin/repositories/distribution\">create a Distribution repository</a>.\n                              To learn about distribution repositories, refer to the Artifactory <a href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository\">User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                    messageType: "alert-info"
	                },
	                nonAdmin: {
	                    message: "No distribution repositories are configured.\n                              To learn about distribution repositories, refer to the Artifactory <a href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository\">User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                    messageType: "alert-info"
	                }
	            },
	            inOfflineMode: {
	                message: "Global offline mode is enabled. To allow distribution, disable the global offline mode through the General Configuration page.",
	                messageType: "alert-danger"
	            },
	            noPermissions: {
	                message: "You do not have distribute and deploy permissions.",
	                messageType: "alert-danger"
	            }
	        },
	        deploy: {
	            deployToDistRepoErrorMessage: {
	                message: "File(s) cannot be directly deployed to a distribution repository. Instead, use the \"Distribute\" action on the relevant repository or select an alternative target repository.",
	                messageType: "alert-danger"
	            },
	            deployPermissionsErrorMessage: {
	                message: "You do not have deploy permission",
	                messageType: "alert-danger"
	            },
	            hasNoDefaultDeployRepo: {
	                message: "This virtual repository is not configured with a default deployment repository. To learn about configuring virtual repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Deploying+Artifacts#DeployingArtifacts-DeployingtoaVirtualRepository\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-warning"
	            },
	            cannotDeployToRemote: {
	                message: "Cannot deploy to a remote repository. To learn about remote repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-danger"
	            },
	            cannotDeployToTrashCan: {
	                message: "Cannot deploy to Trash Can. To learn about the Trash Can, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Browsing+Artifactory#BrowsingArtifactory-TrashCan\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-danger"
	            } }
	    },
	    jf_general: {
	        xray: {
	            xrayDetectedIssuesOnDownloadableArtifact: "Xray has detected issues on this artifact",
	            xrayDidntScanFileYet: "This artifact is currently blocked for download until it has been indexed and scanned by Xray. Please try again once processing is completed.",
	            xrayDetectedIssuesOnNonDownloadableArtifact: "Xray has detected issues on this artifact, and it has been blocked for download and distribution" }
	    }
	};

/***/ }),
/* 161 */,
/* 162 */,
/* 163 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    localChecksumPolicy: {
	        CLIENT: "Verify against client checksums",
	        SERVER: "Trust server generated checksums"
	    },
	    remoteChecksumPolicy: {
	        GEN_IF_ABSENT: "Generate if absent",
	        FAIL: "Fail",
	        IGNORE_AND_GEN: "Ignore and generate",
	        PASS_THRU: "Ignore and pass-through"
	    },
	    snapshotRepositoryBehavior: {
	        UNIQUE: "Unique",
	        NONUNIQUE: "Non-unique",
	        DEPLOYER: "Deployer"
	    },
	    pomCleanupPolicy: {
	        discard_active_reference: "Discard active references",
	        discard_any_reference: "Discard any reference",
	        nothing: "Nothing"
	    },
	    dockerApiVersion: {
	        V1: "V1",
	        V2: "V2"
	    },
	    vcsGitProvider: {
	        GITHUB: "GitHub",
	        BITBUCKET: "BitBucket",
	        STASH: "Stash / Private BitBucket",
	        ARTIFACTORY: "Artifactory",
	        CUSTOM: "Custom"
	    },
	    defaultLayouts: {
	        maven: "maven-2-default",
	        ivy: "ivy-default",
	        gradle: "gradle-default",
	        nuget: "nuget-default",
	        npm: "npm-default",
	        bower: "bower-default",
	        composer: "composer-default",
	        conan: "conan-default",
	        puppet: "puppet-default",
	        vcs: "vcs-default",
	        sbt: "sbt-default"
	    },
	    REPO_TYPE: {
	        LOCAL: "local",
	        REMOTE: "remote",
	        VIRTUAL: "virtual",
	        DISTRIBUTION: "distribution"
	    },
	    repoPackageTypes: [{
	        serverEnumName: "Bower",
	        value: "bower",
	        text: "Bower",
	        icon: "bower",
	        repoType: ["local", "remote", "virtual"],
	        description: "Bower package manager is optimized for front-end development. A Bower repository will allow you to easily manage your Bower packages and proxy remote Bower repositories."
	    }, {
	        serverEnumName: "Chef",
	        value: "chef",
	        text: "Chef",
	        icon: "chef",
	        repoType: ["local", "remote", "virtual"],
	        description: "Chef Description" // TODO
	    }, {
	        serverEnumName: "CocoaPods",
	        value: "cocoapods",
	        text: "CocoaPods",
	        icon: "cocoapods",
	        repoType: ["local", "remote"],
	        description: "CocoaPods is an application level dependency manager for the Objective-C programming language and any other languages that run on the Objective-C runtime, that provides a standard format for managing external libraries."
	    }, {
	        serverEnumName: "Conan",
	        value: "conan",
	        text: "Conan",
	        icon: "conan",
	        repoType: ["local"],
	        description: "Conan is a portable package manager, intended for C and C++ developers, but it is able to manage builds from source, dependencies, and precompiled binaries for any language."
	    }, {
	        serverEnumName: "Debian",
	        value: "debian",
	        text: "Debian",
	        icon: "debian",
	        repoType: ["local", "remote"],
	        description: "A Debian repository will allow you to host, cache and distribute your packages for Debian based operating systems such as Ubuntu."
	    }, {
	        serverEnumName: "Docker",
	        value: "docker",
	        text: "Docker",
	        icon: "docker",
	        repoType: ["local", "remote", "virtual"],
	        description: "Docker allows you to package an application with all of its dependencies into a standardized unit for software development. A Docker repository will allow you to easily and securely manage your Docker images."
	    }, {
	        serverEnumName: "Gems",
	        value: "gems",
	        text: "Gems",
	        icon: "gems",
	        repoType: ["local", "remote", "virtual"],
	        description: "A RubyGems repository allows you to easily download, install, and use ruby software packages in your system. Gems can be used to extend or modify functionality in Ruby applications."
	    }, {
	        serverEnumName: "GitLfs",
	        value: "gitlfs",
	        text: "Git LFS",
	        icon: "git-lfs",
	        repoType: ["local", "remote", "virtual"],
	        description: "Git LFS replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents in an Artifactory repository. This allows you to work with the same Git workflow, but with better access control, faster download and more repository space."
	    }, {
	        serverEnumName: "Gradle",
	        value: "gradle",
	        text: "Gradle",
	        icon: "gradle",
	        repoType: ["local", "remote", "virtual"],
	        description: "Gradle is a build automation tool which lets model your problem domain declaratively using a powerful and expressive domain-specific language (DSL) implemented in Groovy."
	    }, {
	        serverEnumName: "Ivy",
	        value: "ivy",
	        text: "Ivy",
	        icon: "ivy",
	        repoType: ["local", "remote", "virtual"],
	        description: "Apache Ivy is a popular dependency manager focusing on flexibility and simplicity. Ivy offers full integration with ant, and a strong transitive dependency management engine."
	    }, {
	        serverEnumName: "Maven",
	        value: "maven",
	        text: "Maven",
	        icon: "maven",
	        repoType: ["local", "remote", "virtual"],
	        description: "Apache Maven is a build automation tool which provides useful project information from your projects sources."
	    }, {
	        serverEnumName: "Npm",
	        value: "npm",
	        text: "npm",
	        icon: "npm",
	        repoType: ["local", "remote", "virtual"],
	        description: "npm package manager makes it easy for JavaScript developers to share, reuse code, and update code. Host your own node.js packages in Artifactory and proxy remote npm repositories. Use npm against a single in-house repository under your control for your all npm needs."
	    }, {
	        serverEnumName: "NuGet",
	        value: "nuget",
	        text: "NuGet",
	        icon: "nuget",
	        repoType: ["local", "remote", "virtual"],
	        description: "NuGet is the package manager for Microsoft development platforms including .NET. Host and proxy NuGet packages in Artifactory, and pull libraries from Artifactory into your various Visual Studio .NET applications."
	    }, {
	        serverEnumName: "Opkg",
	        value: "opkg",
	        text: "Opkg",
	        icon: "opkg",
	        repoType: ["local", "remote"],
	        description: "Opkg is a lightweight package management system based upon ipkg. It is intended for use on embedded Linux devices, and is commonly used for IoT."
	    }, {
	        serverEnumName: "Composer",
	        value: "composer",
	        text: "PHP Composer",
	        icon: "composer",
	        repoType: ["local", "remote"],
	        description: "Composer is a dependency manager for PHP."
	    }, {
	        serverEnumName: "P2",
	        value: "p2",
	        text: "P2",
	        icon: "p2",
	        repoType: ["remote", "virtual"],
	        description: "P2 provides a provisioning platform for Eclipse and Equinox-based applications."
	    }, {
	        serverEnumName: "Pypi",
	        value: "pypi",
	        text: "PyPI",
	        icon: "pypi",
	        repoType: ["local", "remote", "virtual"],
	        description: "The Python Package Index for the Python programming language. Transparently resolve PyPI distribution locations, whether local or remote. Exercise fine-grained access control to all PyPI resources with comprehensive security measures and full support for pip."
	    }, {
	        serverEnumName: "Puppet",
	        value: "puppet",
	        text: "Puppet",
	        icon: "puppet",
	        repoType: ["local", "remote", "virtual"],
	        description: "A repository of puppet modules."
	    }, {
	        serverEnumName: "SBT",
	        value: "sbt",
	        text: "SBT",
	        icon: "sbt",
	        repoType: ["local", "remote", "virtual"],
	        description: "Sbt is a build tool for the Scala community and Java projects. Sbt uses advanced concepts to provide flexible and powerful build definitions."
	    }, {
	        serverEnumName: "Vagrant",
	        value: "vagrant",
	        text: "Vagrant",
	        icon: "vagrant",
	        repoType: ["local"],
	        description: "Vagrant provides easy-to-configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow."
	    }, {
	        serverEnumName: "VCS",
	        value: "vcs",
	        text: "VCS",
	        icon: "vcs",
	        repoType: ["remote"],
	        description: "A VCS remote repository gives you stable and reliable access to your source code with security and access control, along with smart search capabilities for any of the supported version control systems."
	    }, {
	        serverEnumName: "YUM",
	        value: "yum",
	        text: "RPM",
	        icon: "rpm",
	        repoType: ["local", "remote", "virtual"],
	        description: "An RPM repository will allow you to host, cache and distribute your RPM packages."
	    }, {
	        serverEnumName: "Generic",
	        value: "generic",
	        text: "Generic",
	        icon: "generic",
	        repoType: ["local", "remote", "virtual"],
	        description: "A generic repository can be used to host and proxy any type of file."
	    }]
	};

/***/ }),
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var Configuration = _interopRequire(__webpack_require__(173));

	var Repositories = _interopRequire(__webpack_require__(201));

	var Advanced = _interopRequire(__webpack_require__(207));

	var Dashboard = _interopRequire(__webpack_require__(225));

	var ImportExport = _interopRequire(__webpack_require__(226));

	var Security = _interopRequire(__webpack_require__(232));

	var Services = _interopRequire(__webpack_require__(265));

	var AdminController = __webpack_require__(272).AdminController;

	function adminConfig($stateProvider) {
	    $stateProvider.state("admin", {
	        url: "/admin",
	        parent: "app-layout",
	        templateUrl: "states/admin/admin.html",
	        controller: "AdminController as Admin"
	    });
	}

	module.exports = angular.module("admin.module", [Configuration.name, Repositories.name, Advanced.name, Dashboard.name, ImportExport.name, Security.name, Services.name]).config(adminConfig).controller("AdminController", AdminController);

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var Licenses = _interopRequire(__webpack_require__(174));

	var Mail = _interopRequire(__webpack_require__(177));

	var Xray = _interopRequire(__webpack_require__(179));

	var Proxies = _interopRequire(__webpack_require__(182));

	var ReverseProxies = _interopRequire(__webpack_require__(185));

	var RegisterPro = _interopRequire(__webpack_require__(188));

	var Bintray = _interopRequire(__webpack_require__(190));

	var General = _interopRequire(__webpack_require__(192));

	var PropertySets = _interopRequire(__webpack_require__(194));

	var HighAvailability = _interopRequire(__webpack_require__(198));

	var AdminConfigurationController = __webpack_require__(200).AdminConfigurationController;

	/**
	 * configuration and state definition
	 * @param $stateProvider
	 */
	function configurationConfig($stateProvider) {

	    $stateProvider.state("admin.configuration", {
	        url: "/configuration",
	        template: "<ui-view></ui-view>",
	        controller: "AdminConfigurationController as AdminConfiguration"
	    });
	}

	/**
	 * Module definition
	 */
	module.exports = angular.module("admin.configuration", [Licenses.name, Mail.name, Xray.name, Proxies.name, ReverseProxies.name, RegisterPro.name, Bintray.name, General.name, PropertySets.name, HighAvailability.name]).config(configurationConfig).controller("AdminConfigurationController", AdminConfigurationController);

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationLicensesController = __webpack_require__(175).AdminConfigurationLicensesController;

	var AdminConfigurationLicenseFormController = __webpack_require__(176).AdminConfigurationLicenseFormController;

	function licensesConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.licenses", {
	        url: "/licenses",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/licenses.html",
	        controller: "AdminConfigurationLicensesController as AdminConfigurationLicenses"
	    }).state("admin.configuration.licenses.edit", {
	        parent: "admin.configuration",
	        url: "/licenses/{licenseName}/edit",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/license_form.html",
	        controller: "AdminConfigurationLicenseFormController as AdminLicenseForm"
	    }).state("admin.configuration.licenses.new", {
	        parent: "admin.configuration",
	        url: "/licenses/new",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/license_form.html",
	        controller: "AdminConfigurationLicenseFormController as AdminLicenseForm"
	    });
	}

	module.exports = angular.module("configuration.licenses", ["ui.router"]).config(licensesConfig).controller("AdminConfigurationLicensesController", AdminConfigurationLicensesController).controller("AdminConfigurationLicenseFormController", AdminConfigurationLicenseFormController);

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var API = _interopRequire(__webpack_require__(88));

	var AdminConfigurationLicensesController = exports.AdminConfigurationLicensesController = (function () {
	    function AdminConfigurationLicensesController($scope, $window, JFrogModal, LicensesDao, JFrogGridFactory, ArtifactoryState, uiGridConstants) {
	        _classCallCheck(this, AdminConfigurationLicensesController);

	        this.$window = $window;
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.licensesDao = LicensesDao;
	        this.$scope = $scope;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;

	        this._createGrid();
	        this._initLicenses();

	        //clear 'prevState' in ArtifactoryState, used to return from license form to another state (Builds->Licenses)
	        ArtifactoryState.setState("prevState", undefined);
	    }

	    _createClass(AdminConfigurationLicensesController, {
	        _initLicenses: {
	            value: function _initLicenses() {
	                var _this = this;

	                this.licensesDao.getLicense().$promise.then(function (licenses) {
	                    _this.licenses = licenses;
	                    _this.gridOption.setGridData(_this.licenses.data);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getCloumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        deleteLicense: {
	            value: function deleteLicense(license) {
	                var _this = this;

	                var json = { licenseskeys: [license.name] };
	                this.modal.confirm("Are you sure you want to delete " + license.name + "?").then(function () {
	                    _this.licensesDao["delete"](json).$promise.then(function () {
	                        return _this.updateListTable();
	                    });
	                });
	            }
	        },
	        deleteSelectedLicenses: {
	            value: function deleteSelectedLicenses() {
	                var _this = this;

	                //Get All selected licenses
	                var selectedRows = this.gridOption.api.selection.getSelectedGridRows();
	                //Create an array of the selected licenses keys
	                var names = _.map(selectedRows, function (row) {
	                    return row.entity.name;
	                });
	                //Create Json for the bulk request
	                var json = { licenseskeys: names };
	                //console.log('Bulk delete....');
	                //Ask for confirmation before delete and if confirmed then delete bulk of licenses
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " licenses?").then(function () {
	                    _this.licensesDao["delete"](json).$promise.then(function () {
	                        return _this.updateListTable();
	                    });
	                });
	            }
	        },
	        updateListTable: {
	            value: function updateListTable() {
	                var _this = this;

	                this.licensesDao.getLicense().$promise.then(function (licenses) {
	                    _this.licenses = licenses;
	                    _this.gridOption.setGridData(_this.licenses.data);
	                    if (_this.modalInstance) {
	                        _this.closeModal();
	                    }
	                });
	            }
	        },
	        setStatus: {
	            value: function setStatus(row) {
	                var _this = this;

	                if (row.approved) {
	                    row.approved = false;
	                    row.status = "Unapproved";
	                } else {
	                    row.approved = true;
	                    row.status = "Approved";
	                }
	                this.licensesDao.update(row).$promise.then(function () {
	                    return _this.updateListTable();
	                });
	            }
	        },
	        exportLicenses: {
	            value: function exportLicenses() {
	                this.$window.open("" + API.API_URL + "/licenseexport", "_self", "");
	            }
	        },
	        getCloumns: {
	            value: function getCloumns() {
	                return [{
	                    name: "License Key",
	                    displayName: "License Key",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.licenses.edit({licenseName: row.entity.name})\" id=\"license-key\" class=\"text-center ui-grid-cell-contents\">{{row.entity.name}}</a></div>",
	                    width: "15%"
	                }, {
	                    name: "Name",
	                    displayName: "Name",
	                    field: "longName",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"license-name\"><span>{{row.entity.longName}}</span></div>",
	                    width: "40%"

	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "url",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ><a href=\"{{row.entity.url}}\" target=\"_blank\" id=\"license-url\">{{row.entity.url}}</a></div>",
	                    width: "30%"
	                }, {
	                    name: "Status",
	                    displayName: "Status",
	                    field: "status",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><jf-switch-toggle texton=\"Approved\" id=\"license-status\" textoff=\"Unapproved\" ng-click=\"grid.appScope.AdminConfigurationLicenses.setStatus(row.entity)\" ng-class=\"{'on': row.entity.approved, 'off': !row.entity.approved}\"></jf-switch-toggle></div>",
	                    width: "15%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (license) {
	                        return _this.deleteLicense(license);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedLicenses();
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationLicensesController;
	})();

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminConfigurationLicenseFormController = exports.AdminConfigurationLicenseFormController = (function () {
	    function AdminConfigurationLicenseFormController($stateParams, LicensesDao, $state, ArtifactoryState, ArtifactoryModelSaver) {
	        var _this = this;

	        _classCallCheck(this, AdminConfigurationLicenseFormController);

	        this.state = $state;
	        this.isNew = !$stateParams.licenseName;
	        this.licensesDao = LicensesDao;
	        this.artifactoryState = ArtifactoryState;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["license"]);

	        this.TOOLTIP = TOOLTIP.admin.configuration.licenseForm;

	        if (this.isNew) {
	            this.license = new LicensesDao();
	        } else {
	            this.license = LicensesDao.getSingleLicense({ name: $stateParams.licenseName });
	            this.license.$promise.then(function (data) {
	                _this.ArtifactoryModelSaver.save();
	            });
	        }
	    }

	    _createClass(AdminConfigurationLicenseFormController, {
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                var whenSaved = this.isNew ? this.license.$create() : this.license.$update();
	                whenSaved.then(function () {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this._end();
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                var prevState = this.artifactoryState.getState("prevState");
	                if (prevState) {
	                    this.state.go(prevState.state, prevState.params);
	                } else {
	                    this.state.go("^.licenses");
	                }
	            }
	        },
	        testRegex: {
	            value: function testRegex(value) {

	                var regex = new RegExp("^[A-Za-z0-9._-]*$");
	                return regex.test(value);
	            }
	        }
	    });

	    return AdminConfigurationLicenseFormController;
	})();

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationMailController = __webpack_require__(178).AdminConfigurationMailController;

	function mailConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.mail", {
	        params: { feature: "mail" },
	        url: "/mail",
	        templateUrl: "states/admin/configuration/mail/mail.html",
	        controller: "AdminConfigurationMailController as AdminConfigurationMail"
	    });
	}

	module.exports = angular.module("configuration.mail", []).config(mailConfig).controller("AdminConfigurationMailController", AdminConfigurationMailController);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminConfigurationMailController = exports.AdminConfigurationMailController = (function () {
	    function AdminConfigurationMailController(MailDao, JFrogEventBus, $timeout, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminConfigurationMailController);

	        this.mailDao = MailDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.getMailData();
	        this.mailSettingsForm = null;
	        this.testReceiptForm = null;
	        this.TOOLTIP = TOOLTIP.admin.configuration.mail;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["mail"]);
	        this.$timeout = $timeout;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }

	    _createClass(AdminConfigurationMailController, {
	        getMailData: {
	            value: function getMailData() {
	                var _this = this;

	                this.mailDao.get().$promise.then(function (mail) {
	                    _this.mail = mail;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        save: {
	            value: function save(form) {
	                var _this = this;

	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, form.$name);
	                if (this.mailSettingsForm.$valid) {
	                    this.mailDao.update(this.mail).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getMailData();
	                });
	            }
	        },
	        testReceipt: {
	            value: function testReceipt(form) {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, form.$name);
	                if (this.testReceiptForm.$valid) {
	                    this.mailDao.save(this.mail);
	                }
	            }
	        }
	    });

	    return AdminConfigurationMailController;
	})();

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationXrayController = __webpack_require__(180).AdminConfigurationXrayController;

	function xrayConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.xray", {
	        params: { feature: "xray" },
	        url: "/xray",
	        templateUrl: "states/admin/configuration/xray/xray.html",
	        controller: "AdminConfigurationXrayController as AdminConfigurationXray"
	    });
	}

	module.exports = angular.module("configuration.xray", []).config(xrayConfig).controller("AdminConfigurationXrayController", AdminConfigurationXrayController);

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var FIELD_OPTIONS = _interopRequire(__webpack_require__(163));

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminConfigurationXrayController = exports.AdminConfigurationXrayController = (function () {
	    function AdminConfigurationXrayController($scope, XrayDao, FooterDao, JFrogModal, JFrogGridFactory, JFrogEventBus, commonGridColumns) {
	        var _this = this;

	        _classCallCheck(this, AdminConfigurationXrayController);

	        this.$scope = $scope;
	        this.commonGridColumns = commonGridColumns;
	        this.xrayDao = XrayDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.footerDao = FooterDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.notConnnectedToXrayMessage = CONFIG_MESSAGES.admin.configuration.xray.notConnnectedToXrayMessage;
	        this.createGrid();
	        this.getData();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getData();
	        });
	        //        XrayDao.getConf().$promise.then((data)=>console.log(data))
	    }

	    _createClass(AdminConfigurationXrayController, {
	        getData: {
	            value: function getData() {
	                var _this = this;

	                this.xrayDao.getIndex().$promise.then(function (data) {
	                    _.forEach(data, function (row) {

	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.pkgType.toLowerCase();
	                        });

	                        row.packageIcon = rowPackageType.icon;
	                        row.repoType = row.type.charAt(0).toUpperCase() + row.type.slice(1);
	                    });
	                    _this.indexedRepos = data;
	                    _this.gridOptions.setGridData(data);
	                });
	                this.xrayDao.getNoneIndex().$promise.then(function (data) {

	                    _.forEach(data, function (row) {

	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.pkgType.toLowerCase();
	                        });

	                        row.packageIcon = rowPackageType.icon;
	                        row.repoType = row.type.charAt(0).toUpperCase() + row.type.slice(1);
	                    });

	                    _this.unindexedRepos = data;
	                });
	                this.xrayDao.isXrayEnabled().$promise.then(function (data) {
	                    _this.xrayEnabled = data.xrayEnabled;
	                });
	            }
	        },
	        createGrid: {
	            value: function createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setMultiSelect().setButtons(this.getActions()).setRowTemplate("default").setBatchActions(this.getBatchActions());
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    width: "40%"
	                }, {
	                    name: "Repository Type",
	                    displayName: "Repository Type",
	                    field: "type",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.repoType}}</div>",
	                    width: "30%"
	                }, {
	                    name: "Package Type",
	                    displayName: "Package Type",
	                    field: "pkgType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.pkgType", "row.entity.packageIcon", "repo-type-icon"),
	                    width: "30%"
	                }];
	            }
	        },
	        getActions: {
	            value: function getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Remove",
	                    callback: function (row) {
	                        return _this.removeIndexes(row);
	                    },
	                    visibleWhen: function () {
	                        return _this.xrayEnabled;
	                    }
	                }];
	            }
	        },
	        getBatchActions: {
	            value: function getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Remove",
	                    callback: function () {
	                        return _this.bulkRemove();
	                    },
	                    visibleWhen: function () {
	                        return _this.xrayEnabled;
	                    }
	                }];
	            }
	        },
	        add: {
	            value: function add() {
	                var _this = this;

	                if (this.xrayEnabled === true) {
	                    (function () {
	                        var modalScope = _this.$scope.$new();
	                        var modalInstance = undefined;

	                        modalScope.availableRepos = _.cloneDeep(_this.unindexedRepos);
	                        modalScope.indexedRepos = _.cloneDeep(_this.indexedRepos) || [];

	                        modalScope.save = function (indexed) {
	                            _this.xrayDao.updateRepositories({}, indexed).$promise.then(function () {
	                                _this.getData();
	                                modalInstance.close();
	                            });
	                        };

	                        modalInstance = _this.modal.launchModal("add_xray_index_modal", modalScope);
	                    })();
	                }
	            }
	        },
	        removeIndexes: {
	            value: function removeIndexes(repos) {
	                var _this = this;

	                if (_.isArray(repos)) {
	                    this.xrayDao.removeIndex({}, repos).$promise.then(function () {
	                        _this.getData();
	                    });
	                } else {
	                    this.xrayDao.removeIndex({}, [{ name: repos.name, type: repos.type }]).$promise.then(function () {
	                        _this.getData();
	                    });
	                }
	            }
	        },
	        bulkRemove: {
	            value: function bulkRemove() {
	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                var removeList = _.map(selectedRows, function (obj) {
	                    return _.pick(obj, ["name", "type"]);
	                });
	                this.removeIndexes(removeList);
	            }
	        },
	        _updateFooter: {
	            value: function _updateFooter() {
	                this.JFrogEventBus.dispatch(EVENTS.FOOTER_REFRESH);
	            }
	        },
	        xrayEnabledChange: {
	            value: function xrayEnabledChange() {
	                var _this = this;

	                if (this.xrayEnabled === false) {
	                    this.modal.confirm("If disabled, Artifactory will not generate events for Xray and your artifacts will not be indexed or scanned.<br /><br />Are you sure you want to disable Xray integration?", "Disable Xray Integration", { confirm: "Disable" }).then(function () {
	                        _this.enableDisableXrayIntegration(false);
	                    })["catch"](function () {
	                        _this.xrayEnabled = true;
	                    });
	                } else {
	                    this.enableDisableXrayIntegration(true);
	                }
	            }
	        },
	        enableDisableXrayIntegration: {
	            value: function enableDisableXrayIntegration(action) {
	                this.xrayEnabled = action;
	                this.xrayDao.setXrayEnabled({}, { xrayEnabled: this.xrayEnabled }).$promise.then(function () {});
	            }
	        }
	    });

	    return AdminConfigurationXrayController;
	})();

/***/ }),
/* 181 */
/***/ (function(module, exports) {

	/**
	 * Created by tomere on 2/22/2017.
	 */
	"use strict";

	module.exports = {
	    admin: {
	        repositories: {
	            local: {
	                noReplicationsMessage: "This repository has not been configured for replication. To learn about replicating repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Repository+Replication\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noReposMessage: "Artifactory has not been configured with local repositories. To learn about local repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Local+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            remote: {
	                noReposMessage: "Artifactory has not been configured with remote repositories. To learn about remote repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noXrayIntegrationMessage: "This Artifactory instance is not connected to <a href=\"https://www.jfrog.com/confluence/display/XRAY/Welcome+to+JFrog+Xray\" target=\"_blank\">Xray <i class=\"icon icon-external-link\"></i></a>."
	            },
	            virtual: {
	                noReposMessage: "Artifactory has not been configured with virtual repositories. To learn about virtual repositories, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Virtual+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            distribution: {
	                noReposMessage: "Distribution repositories can be used to distribute your products or packages with <a href=\"https://bintray.com\" target=\"_blank\">JFrog Bintray <i class=\"icon icon-external-link\"></i></a> - the universal distribution platform."
	            }
	        },
	        configuration: {
	            propertySets: {
	                noSetsMessage: "Artifactory has not been configured with property sets. To learn about configuring Artifactory to work with property sets <a href=\"https://www.jfrog.com/confluence/display/RTF/Properties#Properties-PropertySets\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            proxies: {
	                noSetsMessage: "Artifactory has not been configured with proxy servers. To learn about configuring Artifactory to work with proxy servers, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Proxies\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            xray: {
	                notConnnectedToXrayMessage: "This Artifactory instance is not connected to Xray. To connect this instance to Xray and index artifacts for analysis, refer to the <a href=\"https://www.jfrog.com/confluence/display/XRAY/Welcome+to+JFrog+Xray\" target=\"_blank\">Xray User Guide <i class=\"icon icon-external-link\"></i></a>"
	            },
	            ha: {
	                haNotConfiguredMessage: "High Availability license is installed but HA feature is not configured.<br>\n                                      Visit <a target=\"_blank\" href=\"https://www.jfrog.com/confluence/display/RTF/Installation+and+Setup#InstallationandSetup-ConfiguringArtifactoryHA\">Artifactory High Availability Installation and Setup <i class=\"icon icon-external-link\"></i></a> page in <a target=\"_blank\" href=\"https://www.jfrog.com/confluence/display/RTF/Welcome+to+Artifactory\">JFrog's wiki <i class=\"icon icon-external-link\"></i></a> for detailed instructions."
	            }
	        },
	        security: {
	            users: {
	                userForm: {
	                    userIsAdmin: "This user has Admin privileges and is, therefore, not restricted by any of the permission targets specified in the table below." } },
	            groups: {
	                noGroupsMessage: "No groups found. To learn about managing groups in Artifactory, refer to the Artifactory User Guide.  <a href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Users#ManagingUsers-CreatingandEditingGroups\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                groupForm: {
	                    groupIsAdmin: "This group has Admin privileges and is, therefore, not restricted by any of the permission targets specified in the table below." } },
	            accessTokens: {
	                noTokensMessage: "Artifactory has no access tokens to display. To learn how to generate access tokens, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Access+Tokens\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            ldap: {
	                noLdapConfigurationMessage: "Artifactory has not been configured with an LDAP server. To learn about configuring Artifactory to work with LDAP, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Security+with+LDAP\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	            }
	        },
	        services: {
	            backups: {
	                noBackupsMessage: "Artifactory has not been configured with backups jobs. To learn about backing up Artifactory, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Backups\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	            }
	        },
	        advanced: {
	            logAnalytics: {
	                sumoLogicIntegrationMessage: "The JFrog Artifactory / Sumo Logic integration gives you a centralized overview of your artifact repositories with the ability to drill down and quickly identify recent changes, check application dependencies and identify potential issues. Through dashboards, queries and searches that are pre-enabled out-of-the-box, Sumo Logic allows you to analyze all data that Artifactory generates. For a complete overview, <a href=\"https://www.jfrog.com/confluence/display/RTF/Log+Analytics\" target=\"_blank\">click here <i class=\"icon icon-external-link\"></i></a>." },
	            supportZone: {
	                openSupportTicketMessage: "The support info bundle is not sent to JFrog support directly. Once you completed the download log in to JFrog <a href=\"https://support.jfrog.com/\" target=\"_blank\">Support Portal <i class=\"icon icon-external-link\"></i></a> and open a relevant ticket."
	            }
	        }
	    },
	    builds: {
	        noBuildsDataMessage: "No builds have been published to Artifactory. To learn about build integration, refer to the <a href=\"https://www.jfrog.com/confluence/display/RTF/Build+Integration\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." }
	};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationProxiesController = __webpack_require__(183).AdminConfigurationProxiesController;

	var AdminConfigurationProxyFormController = __webpack_require__(184).AdminConfigurationProxyFormController;

	function proxiesConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.proxies", {
	        params: { feature: "Proxies" },
	        url: "/proxies",
	        templateUrl: "states/admin/configuration/proxies/proxies.html",
	        controller: "AdminConfigurationProxiesController as AdminConfigurationProxies"
	    }).state("admin.configuration.proxies.new", {
	        params: { feature: "Proxies" },
	        parent: "admin.configuration",
	        url: "/proxies/new",
	        templateUrl: "states/admin/configuration/proxies/proxy_form.html",
	        controller: "AdminConfigurationProxyFormController as ProxyForm"
	    }).state("admin.configuration.proxies.edit", {
	        params: { feature: "Proxies" },
	        parent: "admin.configuration",
	        url: "/proxies/:proxyKey/edit",
	        templateUrl: "states/admin/configuration/proxies/proxy_form.html",
	        controller: "AdminConfigurationProxyFormController as ProxyForm"
	    });
	}

	module.exports = angular.module("configuration.proxies", []).config(proxiesConfig).controller("AdminConfigurationProxiesController", AdminConfigurationProxiesController).controller("AdminConfigurationProxyFormController", AdminConfigurationProxyFormController);

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminConfigurationProxiesController = exports.AdminConfigurationProxiesController = (function () {
	    function AdminConfigurationProxiesController($scope, ProxiesDao, JFrogGridFactory, JFrogModal, $q, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminConfigurationProxiesController);

	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.proxiesDao = ProxiesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.proxies = {};
	        this.noSetsMessage = CONFIG_MESSAGES.admin.configuration.proxies.noSetsMessage;
	        this._createGrid();
	        this._initProxies();
	    }

	    _createClass(AdminConfigurationProxiesController, {
	        _initProxies: {
	            value: function _initProxies() {
	                var _this = this;

	                this.proxiesDao.get().$promise.then(function (proxies) {
	                    _this.proxies = proxies;
	                    _this.gridOptions.setGridData(proxies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setMultiSelect().setButtons(this._getButtons()).setBatchActions(this._getBatchActions()).setRowTemplate("default");
	            }
	        },
	        deleteSelectedProxies: {
	            value: function deleteSelectedProxies() {
	                var _this = this;

	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " proxies?").then(function () {
	                    //Create an array of the selected propertySet names
	                    var keys = _.map(selectedRows, function (row) {
	                        return row.key;
	                    });
	                    //Create Json for the bulk request
	                    var json = { proxyKeys: keys };
	                    //console.log('Bulk delete....');
	                    //Delete bulk of property set
	                    _this.proxiesDao["delete"](json).$promise.then(function () {
	                        return _this._initProxies();
	                    });
	                }).then(function () {
	                    return _this._initProxies();
	                });
	            }
	        },
	        deleteProxy: {
	            value: function deleteProxy(key) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete the proxy '" + key + "'?").then(function () {
	                    return _this._doDeleteProxy(key);
	                }).then(function () {
	                    return _this._initProxies();
	                });
	            }
	        },
	        _doDeleteProxy: {
	            value: function _doDeleteProxy(key) {

	                var json = { proxyKeys: [key] };
	                //console.log(json);
	                return this.proxiesDao["delete"](json).$promise;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    name: "Key",
	                    displayName: "Key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.proxies.edit({proxyKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    width: "30%"
	                }, {
	                    field: "host",
	                    name: "Host",
	                    displayName: "Host",
	                    width: "45%"
	                }, {
	                    field: "port",
	                    name: "Port",
	                    displayName: "Port",
	                    width: "10%"
	                }, {
	                    field: "defaultProxy",
	                    name: "Default Proxy",
	                    displayName: "Default Proxy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.defaultProxy"),
	                    width: "15%"
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProxies();
	                    }
	                }];
	            }
	        },
	        _getButtons: {
	            value: function _getButtons() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteProxy(row.key);
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationProxiesController;
	})();

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var $state = undefined,
	    $stateParams = undefined,
	    ProxiesDao = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined;

	var AdminConfigurationProxyFormController = exports.AdminConfigurationProxyFormController = (function () {
	    function AdminConfigurationProxyFormController(_$state_, _$stateParams_, _ProxiesDao_, _JFrogModal_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, AdminConfigurationProxyFormController);

	        ProxiesDao = _ProxiesDao_;
	        $stateParams = _$stateParams_;
	        $state = _$state_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["proxy"]);;

	        this.isNew = !$stateParams.proxyKey;
	        this.formTitle = "" + (this.isNew && "New" || "Edit " + $stateParams.proxyKey) + " Proxy";
	        this.TOOLTIP = TOOLTIP.admin.configuration.proxyForm;
	        this._initProxy();
	    }

	    _createClass(AdminConfigurationProxyFormController, {
	        _initProxy: {
	            value: function _initProxy() {
	                var _this = this;

	                if (this.isNew) {
	                    this.proxy = {};
	                } else {
	                    ProxiesDao.getSingleProxy({ key: $stateParams.proxyKey }).$promise.then(function (proxy) {
	                        _this.proxy = proxy;
	                        ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        onChangeDefault: {
	            value: function onChangeDefault() {
	                var _this = this;

	                if (!this.proxy.defaultProxy) {
	                    return;
	                }JFrogModal.confirm("Do you wish to use this proxy with existing remote repositories (and override any assigned proxies)?", "", { confirm: "OK" })["catch"](function () {
	                    return _this.proxy.defaultProxy = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                var whenSaved = this.isNew ? ProxiesDao.save(this.proxy) : ProxiesDao.update(this.proxy);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                    _this.savePending = false;
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.proxies");
	            }
	        }
	    });

	    return AdminConfigurationProxyFormController;
	})();

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationReverseProxiesController = __webpack_require__(186).AdminConfigurationReverseProxiesController;

	var AdminConfigurationReverseProxyFormController = __webpack_require__(187).AdminConfigurationReverseProxyFormController;

	function reverseProxiesConfig($stateProvider) {
	    $stateProvider
	    /*
	                .state('admin.configuration.reverse_proxies', {
	                    params: {feature: 'ReverseProxies'},
	                    url: '/reverse_proxies',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxies.html',
	                    controller: 'AdminConfigurationReverseProxiesController as AdminConfigurationReverseProxies'
	                })
	                .state('admin.configuration.reverse_proxies.new', {
	                    params: {feature: 'ReverseProxies'},
	                    parent: 'admin.configuration',
	                    url: '/reverse_proxies/new',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxy_form.html',
	                    controller: 'AdminConfigurationReverseProxyFormController as ReverseProxyForm'
	                })
	                .state('admin.configuration.reverse_proxies.edit', {
	                    params: {feature: 'ReverseProxies'},
	                    parent: 'admin.configuration',
	                    url: '/reverse_proxies/:reverseProxyKey/edit',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxy_form.html',
	                    controller: 'AdminConfigurationReverseProxyFormController as ReverseProxyForm'
	                })
	    */
	    .state("admin.configuration.reverse_proxy", {
	        params: { feature: "ReverseProxies", reverseProxyKey: "nginx" },
	        parent: "admin.configuration",
	        url: "/reverse_proxy",
	        templateUrl: "states/admin/configuration/reverse_proxies/reverse_proxy_form.html",
	        controller: "AdminConfigurationReverseProxyFormController as ReverseProxyForm"
	    });
	}

	module.exports = angular.module("configuration.reverse_proxies", []).config(reverseProxiesConfig).controller("AdminConfigurationReverseProxiesController", AdminConfigurationReverseProxiesController).controller("AdminConfigurationReverseProxyFormController", AdminConfigurationReverseProxyFormController);

/***/ }),
/* 186 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminConfigurationReverseProxiesController = exports.AdminConfigurationReverseProxiesController = (function () {
	    function AdminConfigurationReverseProxiesController($scope, ReverseProxiesDao, JFrogGridFactory, JFrogModal, $q, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminConfigurationReverseProxiesController);

	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.reverseProxiesDao = ReverseProxiesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$q = $q;

	        this._createGrid();
	        this._initReverseProxies();
	    }

	    _createClass(AdminConfigurationReverseProxiesController, {
	        _initReverseProxies: {
	            value: function _initReverseProxies() {
	                var _this = this;

	                this.reverseProxiesDao.get().$promise.then(function (reverseProxies) {
	                    _this.gridOptions.setGridData(reverseProxies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setMultiSelect().setButtons(this._getButtons()).setBatchActions(this._getBatchActions()).setRowTemplate("default");
	            }
	        },
	        deleteSelectedReverseProxies: {
	            value: function deleteSelectedReverseProxies() {
	                var _this = this;

	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " reverse proxies?").then(function () {
	                    var keys = _.map(selectedRows, function (row) {
	                        return row.key;
	                    });
	                    _this.reverseProxiesDao["delete"]({ proxyKeys: keys }).$promise.then(function () {
	                        return _this._initReverseProxies();
	                    });
	                }).then(function () {
	                    return _this._initReverseProxies();
	                });
	            }
	        },
	        deleteReverseProxy: {
	            value: function deleteReverseProxy(key) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete the reverse proxy '" + key + "'?").then(function () {
	                    return _this._doDeleteReverseProxy(key);
	                }).then(function () {
	                    return _this._initReverseProxies();
	                });
	            }
	        },
	        _doDeleteReverseProxy: {
	            value: function _doDeleteReverseProxy(key) {
	                return this.reverseProxiesDao["delete"]({ proxyKeys: [key] }).$promise;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    name: "Key",
	                    displayName: "Key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.reverse_proxies.edit({reverseProxyKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    width: "30%"
	                }, {
	                    field: "webServerType",
	                    name: "Web Server Type",
	                    displayName: "Web Server Type",
	                    width: "20%"
	                }, {
	                    field: "serverName",
	                    name: "Server Name",
	                    displayName: "Server Name",
	                    width: "50%"
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedReverseProxies();
	                    }
	                }];
	            }
	        },
	        _getButtons: {
	            value: function _getButtons() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteReverseProxy(row.key);
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationReverseProxiesController;
	})();

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var API = _interopRequire(__webpack_require__(88));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var $state = undefined,
	    $stateParams = undefined,
	    $timeout = undefined,
	    ReverseProxiesDao = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined,
	    ArtifactViewsDao = undefined,
	    HaDao = undefined,
	    JFrogIFrameDownload = undefined;

	var AdminConfigurationReverseProxyFormController = exports.AdminConfigurationReverseProxyFormController = (function () {
	    function AdminConfigurationReverseProxyFormController(_$state_, _$stateParams_, _$timeout_, _ReverseProxiesDao_, _JFrogModal_, _ArtifactoryModelSaver_, _ArtifactViewsDao_, _HaDao_, _JFrogIFrameDownload_) {
	        _classCallCheck(this, AdminConfigurationReverseProxyFormController);

	        ReverseProxiesDao = _ReverseProxiesDao_;
	        $stateParams = _$stateParams_;
	        $state = _$state_;
	        $timeout = _$timeout_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["reverseProxy"]);
	        ArtifactViewsDao = _ArtifactViewsDao_;
	        HaDao = _HaDao_;
	        JFrogIFrameDownload = _JFrogIFrameDownload_;

	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };

	        this.webServerTypeOptions = [{ text: "nginx", value: "NGINX", icon: "nginx" }, { text: "apache", value: "APACHE", icon: "apache" }];
	        this.dockerReverseProxyMethodSelectizeOptions = [{ text: "", value: "NOVALUE" }, { text: "Port", value: "PORTPERREPO" }, { text: "Sub Domain", value: "SUBDOMAIN" }];

	        this.formTitle = "Reverse Proxy Configuration Generator";
	        this.TOOLTIP = TOOLTIP.admin.configuration.reverseProxy;

	        this._checkHaConfiguration();

	        this._initReverseProxy();
	    }

	    _createClass(AdminConfigurationReverseProxyFormController, {
	        _checkHaConfiguration: {
	            value: function _checkHaConfiguration() {
	                var _this = this;

	                HaDao.query().$promise.then(function (ha) {
	                    _this.haConfigured = ha.length > 0;
	                });
	            }
	        },
	        _initReverseProxy: {
	            value: function _initReverseProxy() {
	                var _this = this;

	                ReverseProxiesDao.get({ key: "dummy" }).$promise.then(function (reverseProxy) {
	                    _this.reverseProxy = reverseProxy;
	                    _this.reverseProxy.key = "nginx";
	                    _this.reverseProxy.serverNameExpression = "*." + (_this.reverseProxy.serverName ? _this.reverseProxy.serverName : "<SERVER_NAME>");

	                    _this.reverseProxy.httpPort = _this.reverseProxy.httpPort || 80;
	                    if (_this.reverseProxy.publicAppContext === undefined) _this.reverseProxy.publicAppContext = "artifactory";
	                    //                    this.reverseProxy.artifactoryServerName = this.reverseProxy.artifactoryServerName || 'localhost';
	                    _this.reverseProxy.artifactoryPort = _this.reverseProxy.artifactoryPort || 8081;
	                    if (_this.reverseProxy.artifactoryAppContext === undefined) _this.reverseProxy.artifactoryAppContext = "artifactory";
	                    if (!_this.reverseProxy.useHttp && !_this.reverseProxy.useHttps) _this.reverseProxy.useHttp = true;
	                    _this.reverseProxy.httpsPort = _this.reverseProxy.httpsPort || 443;
	                    _this.reverseProxy.upStreamName = _this.reverseProxy.upStreamName || "artifactory";

	                    _this.reverseProxy.dockerReverseProxyMethod = _this.reverseProxy.dockerReverseProxyMethod || "NOVALUE";

	                    _this.reverseProxy.webServerType = _.findWhere(_this.webServerTypeOptions, { value: _this.reverseProxy.webServerType });
	                    //this.reverseProxy.webServerType = this.webServerTypeOptions[0];

	                    ArtifactoryModelSaver.save();

	                    $timeout(function () {
	                        _this.gotData = true;
	                    });
	                });
	            }
	        },
	        onChangeServerName: {
	            value: function onChangeServerName() {
	                this.reverseProxy.serverNameExpression = "*." + (this.reverseProxy.serverName ? this.reverseProxy.serverName : "<SERVER_NAME>");
	            }
	        },
	        save: {
	            value: function save() {
	                var publicAppContext = this.reverseProxy.publicAppContext;
	                var artifactoryAppContext = this.reverseProxy.artifactoryAppContext;
	                this.reverseProxy.publicAppContext = publicAppContext.endsWith("/") ? publicAppContext.substr(0, publicAppContext.length - 1) : publicAppContext;
	                this.reverseProxy.artifactoryAppContext = artifactoryAppContext.endsWith("/") ? artifactoryAppContext.substr(0, artifactoryAppContext.length - 1) : artifactoryAppContext;

	                this.reverseProxy.publicAppContext = this.reverseProxy.publicAppContext.startsWith("/") ? this.reverseProxy.publicAppContext.substr(1) : this.reverseProxy.publicAppContext;
	                this.reverseProxy.artifactoryAppContext = this.reverseProxy.artifactoryAppContext.startsWith("/") ? this.reverseProxy.artifactoryAppContext.substr(1) : this.reverseProxy.artifactoryAppContext;

	                var payload = _.cloneDeep(this.reverseProxy);

	                payload.webServerType = payload.webServerType.value;
	                payload.key = payload.webServerType.toLowerCase();

	                if (payload.dockerReverseProxyMethod !== "SUBDOMAIN") delete payload.serverNameExpression;

	                if (!payload.useHttps) {
	                    delete payload.httpsPort;
	                    delete payload.sslKey;
	                    delete payload.sslCertificate;
	                }
	                if (!payload.useHttp) {
	                    delete payload.httpPort;
	                }

	                var whenSaved = ReverseProxiesDao.save(payload);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        viewSnippet: {
	            value: function viewSnippet() {
	                if (!this.canViewSnippet()) {
	                    return;
	                }ArtifactViewsDao.getDockerProxySnippet({}, { repoKey: "dummy" }).$promise.then(function (data) {
	                    var message = "To use your reverse proxy configuration, copy the snippet below and place it in the sites-enabled folder and reload your reverse proxy server. This will affect Artifactory's reverse proxy configuration, and Docker repositories if you have any configured.";
	                    JFrogModal.launchCodeModal("Reverse Proxy Configuration Snippet", data.template, { name: "text" }, message, "Snippet");
	                });
	            }
	        },
	        downloadSnippet: {
	            value: function downloadSnippet() {
	                if (!this.canViewSnippet()) {
	                    return;
	                }JFrogIFrameDownload("" + API.API_URL + "/views/dockerproxy/dummy?download=true");
	            }
	        },
	        canViewSnippet: {
	            value: function canViewSnippet() {
	                return ArtifactoryModelSaver.isModelSaved() && this.reverseProxyEditForm.$valid;
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;

	                ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._initReverseProxy();
	                });

	                //        this._end();
	            }

	            /*
	                _end() {
	                    $state.go('^.reverse_proxies');
	                }
	            */

	        }
	    });

	    return AdminConfigurationReverseProxyFormController;
	})();

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationRegisterController = __webpack_require__(189).AdminConfigurationRegisterController;

	function registerProConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.register_pro", {
	        params: { feature: "register_pro" },
	        url: "/artifactory_licenses",
	        templateUrl: "states/admin/configuration/register_pro/register_pro.html",
	        controller: "AdminConfigurationRegisterController as AdminConfigurationRegister"
	    });
	}

	module.exports = angular.module("configuration.register_pro", []).config(registerProConfig).controller("AdminConfigurationRegisterController", AdminConfigurationRegisterController);

/***/ }),
/* 189 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminConfigurationRegisterController = exports.AdminConfigurationRegisterController = (function () {
	    function AdminConfigurationRegisterController(User, $state, FooterDao) {
	        _classCallCheck(this, AdminConfigurationRegisterController);

	        this.$state = $state;
	        this.User = User;
	        this.footerDao = FooterDao;
	        this.initHa();
	    }

	    _createClass(AdminConfigurationRegisterController, {
	        initHa: {
	            value: function initHa() {
	                var _this = this;

	                this.footerDao.get().then(function (footerData) {
	                    _this.isHaConfigured = footerData.haConfigured;
	                });
	            }
	        }
	    });

	    return AdminConfigurationRegisterController;
	})();

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationBintrayController = __webpack_require__(191).AdminConfigurationBintrayController;

	function bintrayConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.bintray", {
	        url: "/bintray",
	        templateUrl: "states/admin/configuration/bintray/bintray.html",
	        controller: "AdminConfigurationBintrayController as AdminConfigurationBintray"
	    });
	}

	module.exports = angular.module("configuration.bintray", []).config(bintrayConfig).controller("AdminConfigurationBintrayController", AdminConfigurationBintrayController);

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminConfigurationBintrayController = exports.AdminConfigurationBintrayController = (function () {
	    function AdminConfigurationBintrayController(BintrayDao) {
	        _classCallCheck(this, AdminConfigurationBintrayController);

	        this.bintrayDao = BintrayDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.configuration.bintray;
	        this._init();
	    }

	    _createClass(AdminConfigurationBintrayController, {
	        _init: {
	            value: function _init() {
	                var _this = this;

	                this.bintrayDao.get().$promise.then(function (data) {
	                    _this.bintray = data;
	                    _this.bintray.fileUploadLimit = data.fileUploadLimit || 0;
	                });
	            }
	        },
	        save: {
	            value: function save(bintray) {
	                this.bintrayDao.update(bintray);
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._init();
	            }
	        },
	        fullCredentials: {
	            value: function fullCredentials() {
	                return this.bintray && this.bintray.userName && this.bintray.apiKey;
	            }
	        },
	        testBintray: {
	            value: function testBintray() {
	                this.bintrayDao.save(this.bintray).$promise.then(function (data) {});
	            }
	        }
	    });

	    return AdminConfigurationBintrayController;
	})();

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationGeneralController = __webpack_require__(193).AdminConfigurationGeneralController;

	function generalConfig($stateProvider) {

	    $stateProvider.state("admin.configuration.general", {
	        url: "/general",
	        params: { focusOnBaseUrl: false },
	        templateUrl: "states/admin/configuration/general/general.html",
	        controller: "AdminConfigurationGeneralController as AdminConfiguration"
	    });
	}

	module.exports = angular.module("configuration.general", []).config(generalConfig).controller("AdminConfigurationGeneralController", AdminConfigurationGeneralController);

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var API = _interopRequire(__webpack_require__(88));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminConfigurationGeneralController = exports.AdminConfigurationGeneralController = (function () {
	    function AdminConfigurationGeneralController($scope, $q, $timeout, $stateParams, FileUploader, JFrogNotifications, GeneralConfigDao, FooterDao, JFrogEventBus, ArtifactoryModelSaver, ArtifactActionsDao, JFrogModal, ArtifactoryFeatures) {
	        _classCallCheck(this, AdminConfigurationGeneralController);

	        this.$scope = $scope;
	        this.$q = $q;
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.generalConfigDao = GeneralConfigDao;
	        this.footerDao = FooterDao;
	        this.FileUploader = FileUploader;
	        this.modal = JFrogModal;
	        this.logoType = "File";
	        this.defaultLogoUrl = "images/artifactory_logo.216.svg";
	        this.logoEndPoint = "" + API.API_URL + "/generalConfig/logo";
	        this.TOOLTIP = TOOLTIP.admin.configuration.general;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["generalConfigData"]);
	        this.features = ArtifactoryFeatures;

	        this.deleteUserLogo = false;

	        this._initUploader();

	        this._getGeneralConfigData();
	    }

	    _createClass(AdminConfigurationGeneralController, {
	        customMessageToggle: {
	            value: function customMessageToggle() {
	                this.toggleColorPicker();
	            }
	        },
	        toggleColorPicker: {
	            value: function toggleColorPicker() {
	                $(".color-picker-input").prop("disabled", !this.generalConfigData.systemMessageEnabled);
	            }
	        },
	        _getGeneralConfigData: {
	            value: function _getGeneralConfigData() {
	                var _this = this;

	                this.generalConfigDao.get().$promise.then(function (data) {
	                    _this.generalConfigData = data;
	                    _this.blockReplications = data.blockPushReplications || data.blockPullReplications;
	                    _this.generalConfigData.systemMessageTitleColor = _this.generalConfigData.systemMessageTitleColor.toUpperCase();
	                    _this.ArtifactoryModelSaver.save();
	                    _this._getCurrentImage();
	                    if (_this.generalConfigData.systemMessageEnabled == false) {
	                        _this.toggleColorPicker();
	                    }
	                });
	            }
	        },
	        _getCurrentImage: {
	            value: function _getCurrentImage() {
	                var _this = this;

	                this._userLogoExists().then(function () {
	                    $(".artifactory-logo img")[0].src = _this.logoEndPoint;
	                })["catch"](function () {
	                    if (_this.generalConfigData.logoUrl) {
	                        _this.logoUrlInput = _this.generalConfigData.logoUrl;
	                        $(".artifactory-logo img")[0].src = _this.generalConfigData.logoUrl;
	                    } else {
	                        $(".artifactory-logo img")[0].src = _this.defaultLogoUrl;
	                    }
	                });
	            }
	        },
	        _updateGeneralConfigData: {
	            value: function _updateGeneralConfigData() {
	                var _this = this;

	                this.generalConfigDao.update(this.generalConfigData).$promise.then(function (data) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(EVENTS.FOOTER_DATA_UPDATED);
	                });
	            }
	        },
	        _deleteUploadedPicture: {
	            value: function _deleteUploadedPicture() {
	                this.generalConfigDao.deleteLogo().$promise.then(function (data) {});
	            }
	        },
	        _initUploader: {
	            value: function _initUploader() {
	                this.uploader = new this.FileUploader();

	                this.uploader.url = this.logoEndPoint;
	                this.uploader.onSuccessItem = this.onUploadSuccess.bind(this);
	            }
	        },
	        isSelectedLogoType: {
	            value: function isSelectedLogoType(type) {
	                return this.logoType === type;
	            }
	        },
	        onUploadSuccess: {
	            value: function onUploadSuccess() {
	                //        console.log('onUploadSuccess');
	                //        this.generalConfigData.logoUrl = this.logoEndPoint;
	                this.logoUrlInput = undefined;
	                this._updateGeneralConfigData();
	                this.uploader.clearQueue();
	            }
	        },
	        onAfterAddingFile: {
	            value: function onAfterAddingFile(fileItem) {
	                var _this = this;

	                this.assertImage(fileItem._file).then(function () {
	                    _this.logoFile = fileItem.file.name;
	                    _this.showPreview(fileItem._file);
	                })["catch"](function (err) {
	                    _this.artifactoryNotifications.create({ error: err });
	                    _this.uploader.clearQueue();
	                });
	            }
	        },
	        assertImage: {
	            value: function assertImage(file) {

	                var deferred = this.$q.defer();

	                var reader = new FileReader();
	                reader.onload = function (e) {
	                    var buffer = reader.result;
	                    var uInt8View = new Uint8Array(buffer);
	                    var int32Sample = uInt8View[3] + uInt8View[2] * 256 + uInt8View[1] * (256 * 256) + uInt8View[0] * (256 * 256 * 256);

	                    switch (int32Sample) {
	                        case 2303741511: //png
	                        case 1195984440: //gif
	                        case 1112360694: //bmp
	                        case 4292411360:case 4292411361:
	                            //jpg
	                            //case 1010792557: case 1014199911: //svg
	                            deferred.resolve();
	                            break;
	                        default:
	                            deferred.reject("Not an image file!");
	                            break;
	                    }
	                };
	                reader.readAsArrayBuffer(file);

	                return deferred.promise;
	            }
	        },
	        showPreview: {
	            value: function showPreview(file) {
	                if (typeof FileReader !== "undefined" && /image/i.test(file.type)) {
	                    var img = $(".artifactory-logo img")[0];
	                    var reader = new FileReader();
	                    reader.onload = (function (theImg) {
	                        return function (evt) {
	                            theImg.src = evt.target.result;
	                        };
	                    })(img);
	                    reader.readAsDataURL(file);
	                }
	            }
	        },
	        clearLookAndFeel: {
	            value: function clearLookAndFeel() {
	                var _this = this;

	                this.generalConfigData.logoUrl = ""; //this.defaultLogoUrl;
	                this.logoUrlInput = undefined;
	                this.uploader.clearQueue();
	                this.logoFile = undefined;

	                this.deleteUserLogo = true;

	                this.$timeout(function () {
	                    $(".artifactory-logo img")[0].src = _this.defaultLogoUrl;
	                });
	            }
	        },
	        clear: {
	            value: function clear() {
	                this.generalConfigData.customUrlBase = "";
	                this.clearLookAndFeel();
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.isSelectedLogoType("File") && this.uploader.queue.length) {
	                    this.uploader.uploadAll();
	                } else {
	                    if (this.deleteUserLogo) this._deleteUploadedPicture();
	                    this._updateGeneralConfigData();
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.clear();
	                    _this._getGeneralConfigData();
	                });
	            }
	        },
	        onChangeLogoUrl: {
	            value: function onChangeLogoUrl() {
	                var _this = this;

	                var form = this.$scope.formGeneral;
	                if (this.logoUrlInput && !form.logoUrlInput.$invalid) {
	                    this._imageExists(this.logoUrlInput).then(function () {
	                        _this.generalConfigData.logoUrl = _this.logoUrlInput;
	                        _this.deleteUserLogo = true;
	                    })["catch"](function (err) {
	                        return console.log(err);
	                    });
	                }
	            }
	        },
	        _userLogoExists: {
	            value: function _userLogoExists() {
	                var deferred = this.$q.defer();
	                this.footerDao.get(true).then(function (footerData) {
	                    if (footerData.userLogo) {
	                        deferred.resolve();
	                    } else {
	                        deferred.reject();
	                    }
	                });
	                return deferred.promise;
	            }
	        },
	        _imageExists: {
	            value: function _imageExists(url) {
	                var deferred = this.$q.defer();
	                var img = new Image();
	                img.onload = function () {
	                    deferred.resolve();
	                };
	                img.onerror = function () {
	                    deferred.reject("no image found");
	                };
	                img.src = url;
	                return deferred.promise;
	            }
	        },
	        emptyTrashcan: {
	            value: function emptyTrashcan() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to empty the trash can?", "Empty Trash", { confirm: "Empty Trash" }).then(function () {
	                    return _this.artifactActionsDao.perform({ action: "emptytrash" }, {});
	                });
	            }
	        },
	        onChangeBlockReplications: {
	            value: function onChangeBlockReplications() {
	                this.generalConfigData.blockPushReplications = this.blockReplications;
	                this.generalConfigData.blockPullReplications = this.blockReplications;
	            }
	        },
	        onChangePushPullReplications: {
	            value: function onChangePushPullReplications() {
	                this.blockReplications = this.generalConfigData.blockPushReplications || this.generalConfigData.blockPullReplications;
	            }
	        }
	    });

	    return AdminConfigurationGeneralController;
	})();

	//            console.log(data);

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationPropertySetsController = __webpack_require__(195).AdminConfigurationPropertySetsController;

	var AdminConfigurationPropertySetFormController = __webpack_require__(196).AdminConfigurationPropertySetFormController;

	var PropertyFormModalFactory = __webpack_require__(197).PropertyFormModalFactory;

	function propertySetsConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.property_sets", {
	        params: { feature: "properties" },
	        url: "/property_sets",
	        controller: "AdminConfigurationPropertySetsController as PropertySets",
	        templateUrl: "states/admin/configuration/property_sets/property_sets.html"
	    }).state("admin.configuration.property_sets.edit", {
	        params: { feature: "properties" },
	        parent: "admin.configuration",
	        url: "/property_sets/{propertySetName}/edit",
	        templateUrl: "states/admin/configuration/property_sets/property_set_form.html",
	        controller: "AdminConfigurationPropertySetFormController as PropertySetForm"
	    }).state("admin.configuration.property_sets.new", {
	        params: { feature: "properties" },
	        parent: "admin.configuration",
	        url: "/property_sets/new",
	        templateUrl: "states/admin/configuration/property_sets/property_set_form.html",
	        controller: "AdminConfigurationPropertySetFormController as PropertySetForm"
	    });
	}

	module.exports = angular.module("configuration.property_sets", []).config(propertySetsConfig).controller("AdminConfigurationPropertySetsController", AdminConfigurationPropertySetsController).controller("AdminConfigurationPropertySetFormController", AdminConfigurationPropertySetFormController).factory("PropertyFormModal", PropertyFormModalFactory);

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var $timeout = undefined,
	    Property = undefined,
	    PropertySet = undefined,
	    uiGridConstants = undefined;

	var AdminConfigurationPropertySetsController = exports.AdminConfigurationPropertySetsController = (function () {
	    function AdminConfigurationPropertySetsController($scope, PropertySetsDao, JFrogGridFactory, _$timeout_, _Property_, _PropertySet_, JFrogModal, _uiGridConstants_) {
	        _classCallCheck(this, AdminConfigurationPropertySetsController);

	        $timeout = _$timeout_;
	        this.propertySetsDao = PropertySetsDao;
	        this.$scope = $scope;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        Property = _Property_;
	        PropertySet = _PropertySet_;
	        uiGridConstants = _uiGridConstants_;
	        this.propertySets = {};
	        this.noSetsMessage = CONFIG_MESSAGES.admin.configuration.propertySets.noSetsMessage;
	        this._createGrid();
	        this._initPropertySets();
	    }

	    _createClass(AdminConfigurationPropertySetsController, {
	        _initPropertySets: {
	            value: function _initPropertySets() {
	                var _this = this;

	                this.propertySetsDao.query().$promise.then(function (propertySets) {
	                    _this.propertySets = propertySets.map(function (propertySet) {
	                        return new PropertySet(propertySet);
	                    });
	                    _this.gridOptions.setGridData(_this.propertySets);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        deletePropertySet: {
	            value: function deletePropertySet(propertySet) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete the property set '" + propertySet.name + "?'").then(function () {
	                    var json = { propertySetNames: [propertySet.name] };
	                    _this.propertySetsDao["delete"](json).$promise.then(function () {
	                        return _this._initPropertySets();
	                    });
	                });
	            }
	        },
	        deleteSelectedPropertySets: {
	            value: function deleteSelectedPropertySets() {
	                var _this = this;

	                //Get All selected users
	                var selectedRows = this.gridOptions.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " property sets?").then(function () {
	                    //Create an array of the selected propertySet names
	                    var names = selectedRows.map(function (row) {
	                        return row.entity.name;
	                    });
	                    //Delete bulk of property sets
	                    _this.propertySetsDao["delete"]({ propertySetNames: names }).$promise.then(function () {
	                        return _this._initPropertySets();
	                    });
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    name: "Property Set Name",
	                    displayName: "Property Set Name",
	                    sort: {
	                        direction: uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.property_sets.edit({propertySetName: row.entity.name})\" class=\"text-center ui-grid-cell-contents\">{{row.entity.name}}</a></div>"
	                }, {
	                    field: "propertiesCount",
	                    name: "Properties Count",
	                    displayName: "Properties Count"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (propertySet) {
	                        return _this.deletePropertySet(propertySet);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedPropertySets();
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationPropertySetsController;
	})();

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	// Injectables:
	var $q = undefined,
	    $scope = undefined,
	    $state = undefined,
	    $stateParams = undefined,
	    JFrogGridFactory = undefined,
	    PropertySetsDao = undefined,
	    PropertyFormModal = undefined,
	    Property = undefined,
	    PropertySet = undefined,
	    uiGridConstants = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined;

	var AdminConfigurationPropertySetFormController = exports.AdminConfigurationPropertySetFormController = (function () {
	    function AdminConfigurationPropertySetFormController(_$stateParams_, _$scope_, _PropertySetsDao_, _$state_, _JFrogGridFactory_, _PropertyFormModal_, ArtifactoryState, _$q_, _Property_, _PropertySet_, _uiGridConstants_, _JFrogModal_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, AdminConfigurationPropertySetFormController);

	        $scope = _$scope_;
	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        Property = _Property_;
	        PropertySet = _PropertySet_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["propertySet"]);;

	        this.isNew = !$stateParams.propertySetName;
	        PropertySetsDao = _PropertySetsDao_;
	        PropertyFormModal = _PropertyFormModal_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        $q = _$q_;
	        uiGridConstants = _uiGridConstants_;

	        this.TOOLTIP = TOOLTIP.admin.configuration.propertySetsForm;
	        this._createGrid();
	        this._initPropertySet();
	        ArtifactoryState.setState("prevState", $state.current);
	    }

	    _createClass(AdminConfigurationPropertySetFormController, {
	        _initPropertySet: {
	            value: function _initPropertySet() {
	                var _this = this;

	                var promise = undefined;
	                if (this.isNew) {
	                    promise = $q.when();
	                } else {
	                    promise = PropertySetsDao.get({ name: $stateParams.propertySetName }).$promise;
	                }
	                promise.then(function (propertySet) {
	                    _this.propertySet = new PropertySet(propertySet);
	                    ArtifactoryModelSaver.save();
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = JFrogGridFactory.getGridInstance($scope).setColumns(this.getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                var whenSaved = this.isNew ? PropertySetsDao.save(this.propertySet) : PropertySetsDao.update(this.propertySet);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                    _this.savePending = false;
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.property_sets");
	            }
	        },
	        editProperty: {
	            value: function editProperty(property) {
	                // (Adam) Don't take the actual property object because it's different after filtering the GRID
	                // Instead, we find the property in the original propertySet
	                property = this.propertySet.getPropertyByName(property.name);
	                this._launchPropertyEditor(property, false);
	            }
	        },
	        newProperty: {
	            value: function newProperty(e) {
	                e.preventDefault();
	                var property = new Property();
	                this._launchPropertyEditor(property, true);
	            }
	        },
	        _launchPropertyEditor: {
	            value: function _launchPropertyEditor(property, isNew) {
	                var _this = this;

	                new PropertyFormModal(this.propertySet, property, isNew).launch().then(function () {
	                    if (isNew) {
	                        _this.propertySet.addProperty(property);
	                    }
	                    // (Adam) Must reset the data, because of the filter
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        _doDeleteProperty: {
	            value: function _doDeleteProperty(property) {
	                this.propertySet.removeProperty(property.name);
	            }
	        },
	        deleteProperty: {
	            value: function deleteProperty(property) {
	                var _this = this;

	                JFrogModal.confirm("Are you sure you want to delete the property '" + property.name + "?'").then(function () {
	                    _this._doDeleteProperty(property);
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        deleteSelectedProperties: {
	            value: function deleteSelectedProperties() {
	                var _this = this;

	                var selectedRows = this.gridOptions.api.selection.getSelectedGridRows();
	                JFrogModal.confirm("Are you sure you want to delete " + selectedRows.length + " properties?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteProperty(row.entity);
	                    });
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    name: "Property Name",
	                    displayName: "Property Name",
	                    sort: {
	                        direction: uiGridConstants.ASC
	                    },
	                    cellTemplate: "\n                    <div class=\"ui-grid-cell-contents\">\n                        <a  href=\"\"\n                            ng-click=\"grid.appScope.PropertySetForm.editProperty(row.entity)\"\n                            class=\"text-center ui-grid-cell-contents\">{{row.entity.name}}</a>\n                    </div>"
	                }, {
	                    name: "Value Type",
	                    displayName: "Value Type",
	                    field: "propertyType",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.getDisplayType() }}</div>"
	                }, {
	                    field: "predefinedValues",
	                    name: "Predefined Values",
	                    displayName: "Predefined Values",
	                    cellTemplate: "\n                    <div style=\"padding-left: 10px;  white-space: nowrap; overflow-x: auto;\">\n                        <div class=\"item\" ng-repeat=\"value in row.entity.predefinedValues\">\n                            {{value.value}}<span ng-if=\"value.defaultValue\"> (default)</span>\n                        </div>\n                    </div>\n                "
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (propertySet) {
	                        return _this.deleteProperty(propertySet);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProperties();
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationPropertySetFormController;
	})();

/***/ }),
/* 197 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.PropertyFormModalFactory = PropertyFormModalFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// modal
	var $rootScope = undefined;
	var JFrogModal = undefined;
	var Property = undefined,
	    PropertySet = undefined;

	var PropertyFormModal = (function () {
	    function PropertyFormModal(propertySet, property, isNew) {
	        _classCallCheck(this, PropertyFormModal);

	        this.scope = $rootScope.$new();
	        this.scope.PropertyForm = this;
	        this.isNew = isNew;
	        this.originalProperty = property;
	        this.property = angular.copy(this.originalProperty);
	        this.propertySet = propertySet;
	        this.propertyTypes = Property.propertyTypes;
	    }

	    _createClass(PropertyFormModal, {
	        launch: {
	            value: function launch() {
	                this.modalInstance = JFrogModal.launchModal("property_form_modal", this.scope);
	                return this.modalInstance.result;
	            }
	        },
	        save: {
	            value: function save() {
	                angular.copy(this.property, this.originalProperty);
	                this.modalInstance.close();
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.modalInstance.dismiss();
	            }
	        },
	        isPropertyUnique: {
	            value: function isPropertyUnique(propertyName) {
	                return propertyName === this.originalProperty.name || !this.propertySet.getPropertyByName(propertyName);
	            }
	        },
	        isPredefinedValuesValid: {
	            value: function isPredefinedValuesValid() {
	                if (this.property.propertyType === "ANY_VALUE") {
	                    return true; // Any Value allows no predefined values
	                } else {
	                    return this.property.predefinedValues.length; // Other types must have predefined values
	                }
	            }
	        },
	        isDefaultValuesValid: {
	            value: function isDefaultValuesValid(propertyType) {
	                if (propertyType === "MULTI_SELECT") {
	                    return true;
	                }return this.property.getDefaultValues().length < 2;
	            }
	        },
	        invalidateType: {
	            value: function invalidateType() {
	                // By changing the property we use in ui-validate-watch, we force the validation on propertyType to run again
	                this.propertyTypeWatch = this.propertyTypeWatch || 0;
	                this.propertyTypeWatch++;
	            }
	        },
	        getPredefinedValuesStr: {
	            value: function getPredefinedValuesStr() {
	                // This is for watching the propertyType value
	                return JSON.stringify(this.property.predefinedValues);
	            }
	        },
	        removeValue: {
	            value: function removeValue(value) {
	                _.remove(this.property.predefinedValues, value);
	                this.invalidateType();
	            }
	        },
	        addValue: {
	            value: function addValue() {
	                this.newValue = $("#newPredefinedValueName").val();
	                this.errorMessage = null;

	                if (this._isValueEmpty(this.newValue)) {
	                    this.errorMessage = "Must input value";
	                } else if (!this._isValueUnique(this.newValue)) {
	                    this.errorMessage = "Value already exists";
	                } else {
	                    this.property.addPredefinedValue(this.newValue);
	                    this.newValue = null;
	                    $("#newPredefinedValueName").val("");
	                    this.invalidateType();
	                }
	            }
	        },
	        _isValueEmpty: {
	            value: function _isValueEmpty(text) {
	                return _.isEmpty(text);
	            }
	        },
	        _isValueUnique: {
	            value: function _isValueUnique(text) {
	                return !this.property.getPredefinedValue(text);
	            }
	        }
	    });

	    return PropertyFormModal;
	})();

	function PropertyFormModalFactory(_$rootScope_, _JFrogModal_, _Property_, _PropertySet_) {
	    Property = _Property_;
	    PropertySet = _PropertySet_;
	    $rootScope = _$rootScope_;
	    JFrogModal = _JFrogModal_;
	    return PropertyFormModal;
	}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminConfigurationHAController = __webpack_require__(199).AdminConfigurationHAController;

	function haConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.ha", {
	        params: { feature: "highavailability" },
	        url: "/ha",
	        templateUrl: "states/admin/configuration/ha/ha.html",
	        controller: "AdminConfigurationHAController as AdminConfigurationHA"
	    });
	}

	module.exports = angular.module("configuration.ha", []).config(haConfig).controller("AdminConfigurationHAController", AdminConfigurationHAController);

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var HaDao = undefined,
	    $scope = undefined,
	    artifactoryGridFactory = undefined,
	    modal = undefined;

	var AdminConfigurationHAController = exports.AdminConfigurationHAController = (function () {
	    function AdminConfigurationHAController(_$scope_, _JFrogModal_, _HaDao_, _JFrogGridFactory_, _ArtifactoryState_) {
	        _classCallCheck(this, AdminConfigurationHAController);

	        HaDao = _HaDao_;
	        $scope = _$scope_;
	        artifactoryGridFactory = _JFrogGridFactory_;
	        modal = _JFrogModal_;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.configuration.ha;

	        this.gridOptions = {};
	        this._createGrid();
	        this._initHa();
	    }

	    _createClass(AdminConfigurationHAController, {
	        _initHa: {
	            value: function _initHa() {
	                var _this = this;

	                HaDao.query().$promise.then(function (ha) {
	                    _this.ha = ha;
	                    _this.gridOptions.setGridData(_this.ha);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = artifactoryGridFactory.getGridInstance($scope).setColumns(this._getColumns()).setButtons(this._getActions()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "id",
	                    name: "Node ID",
	                    displayName: "Node ID",
	                    width: "7%" }, {
	                    field: "startTime",
	                    name: "Start Time",
	                    displayName: "Start Time",
	                    width: "9%"
	                }, {
	                    field: "url",
	                    name: "URL",
	                    displayName: "URL",
	                    width: "18%",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a target=\"_blank\" href=\"{{ COL_FIELD }}\">{{ COL_FIELD }}</a></div>"
	                }, {
	                    field: "memberShipPort",
	                    name: "Membership Port",
	                    displayName: "Membership Port",
	                    width: "11%"
	                }, {
	                    field: "state",
	                    name: "State",
	                    displayName: "State",
	                    width: "11%",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ COL_FIELD }}" + "<span class=\"ha-node-has-no-license\"\n                                      ng-if=\"!row.entity.hasLicense\"\n                                      jf-tooltip=\"No license installed.\">&nbsp;(Inactive)</span>\n                               </div>"
	                }, {
	                    field: "role",
	                    name: "Role",
	                    displayName: "Role",
	                    width: "8%"
	                }, {
	                    field: "lastHeartbeat",
	                    name: "Last Heartbeat",
	                    displayName: "Last Heartbeat",
	                    width: "11%",
	                    cellTemplate: "\n                    <div ng-if=\"row.entity.heartbeatStale\"\n                         class=\"ui-grid-cell-contents ha-heartbeat-stale\"\n                         jf-tooltip=\"Heartbeat is stale. Check if your server is down.\"><i class=\"icon icon-notif-warning\"></i>{{ COL_FIELD }}</div>\n                    <div ng-if=\"!row.entity.heartbeatStale\"\n                         class=\"ui-grid-cell-contents\">{{ COL_FIELD }}</div>\n                         "
	                }, {
	                    field: "version",
	                    name: "Version",
	                    displayName: "Version",
	                    width: "9%"
	                }, {
	                    field: "revision",
	                    name: "Revision",
	                    displayName: "Revision",
	                    width: "6%"
	                }, {
	                    field: "releaseDate",
	                    name: "Release Date",
	                    displayName: "Release Date",
	                    width: "10%"
	                }];
	            }
	        },
	        _deleteNode: {
	            value: function _deleteNode(node) {
	                var _this = this;

	                modal.confirm("Are you sure you wish to remove " + node.id + " from the nodes list?").then(function () {
	                    return HaDao["delete"]({ id: node.id });
	                }).then(function () {
	                    return _this._initHa();
	                });
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    visibleWhen: function (node) {
	                        return node.heartbeatStale;
	                    },
	                    callback: function (node) {
	                        return _this._deleteNode(node);
	                    }
	                }];
	            }
	        }
	    });

	    return AdminConfigurationHAController;
	})();

/***/ }),
/* 200 */
/***/ (function(module, exports) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminConfigurationController = exports.AdminConfigurationController = function AdminConfigurationController() {
	    _classCallCheck(this, AdminConfigurationController);

	    var AdminConfiguration = this;
	    AdminConfiguration.stateUrl = "/configuration";
	    AdminConfiguration.controllerName = "idan";
	};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminRepositoriesController = __webpack_require__(202).AdminRepositoriesController;

	var AdminRepositoryFormController = __webpack_require__(203).AdminRepositoryFormController;

	var VirtualRepositoryFormController = __webpack_require__(204).VirtualRepositoryFormController;

	var AdminRepositoriesLayoutController = __webpack_require__(205).AdminRepositoriesLayoutController;

	var AdminRepositoryLayoutFormController = __webpack_require__(206).AdminRepositoryLayoutFormController;

	function repositoriesConfig($stateProvider) {
	    $stateProvider
	    // base state
	    .state("admin.repositories", {
	        url: "",
	        abstract: true,
	        template: "<ui-view></ui-view>"
	    })

	    // repository list and forms
	    .state("admin.repositories.list", {
	        url: "/repositories/{repoType}",
	        templateUrl: "states/admin/repositories/repositories.html",
	        controller: "AdminRepositoriesController as Repositories"
	    }).state("admin.repositories.list.edit", {
	        parent: "admin.repositories",
	        url: "/repository/{repoType}/{repoKey}/edit",
	        templateUrl: "states/admin/repositories/repository_form.html",
	        controller: "AdminRepositoryFormController as RepositoryForm"
	    }).state("admin.repositories.list.new", {
	        parent: "admin.repositories",
	        url: "/repository/{repoType}/new",
	        templateUrl: "states/admin/repositories/repository_form.html",
	        controller: "AdminRepositoryFormController as RepositoryForm"
	    })

	    // repository layout list and forms
	    .state("admin.repositories.repo_layouts", {
	        url: "/repo_layouts",
	        templateUrl: "states/admin/repositories/repositories_layouts.html",
	        controller: "AdminRepositoriesLayoutController as RepositoriesLayoutController"
	    }).state("admin.repositories.repo_layouts.edit", {
	        parent: "admin.repositories",
	        url: "/repo_layouts/{layoutname}/edit",
	        templateUrl: "states/admin/repositories/repository_layout_form.html",
	        controller: "AdminRepositoryLayoutFormController as RepositoryLayoutForm",
	        params: { viewOnly: true }
	    }).state("admin.repositories.repo_layouts.new", {
	        parent: "admin.repositories",
	        url: "/repo_layouts/new?copyFrom",
	        templateUrl: "states/admin/repositories/repository_layout_form.html",
	        controller: "AdminRepositoryLayoutFormController as RepositoryLayoutForm"
	    });
	}

	module.exports = angular.module("admin.repositories", []).config(repositoriesConfig).controller("AdminRepositoriesController", AdminRepositoriesController).controller("AdminRepositoryFormController", AdminRepositoryFormController).controller("VirtualRepositoryFormController", VirtualRepositoryFormController).controller("AdminRepositoriesLayoutController", AdminRepositoriesLayoutController).controller("AdminRepositoryLayoutFormController", AdminRepositoryLayoutFormController);

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var FIELD_OPTIONS = _interopRequire(__webpack_require__(163));

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AdminRepositoriesController = exports.AdminRepositoriesController = (function () {
	    function AdminRepositoriesController($scope, $state, JFrogGridFactory, RepositoriesDao, JFrogModal, uiGridConstants, ArtifactActionsDao, ArtifactoryFeatures, commonGridColumns, GlobalReplicationsConfigDao, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminRepositoriesController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$state = $state;
	        this.commonGridColumns = commonGridColumns;
	        this.repositoriesDao = RepositoriesDao;
	        this.globalReplicationsConfigDao = GlobalReplicationsConfigDao;
	        this.$scope = $scope;
	        this.modal = JFrogModal;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.repositories;
	        this.features = ArtifactoryFeatures;
	        this.currentRepoType = $state.params.repoType;
	        this.gridData = {};
	        this.JFrogEventBus = JFrogEventBus;
	        if (!_.contains(["local", "remote", "virtual", "distribution"], this.currentRepoType)) {
	            this.$state.go("not_found_404");
	            return;
	        }

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this._initRepos();
	        });

	        this._createGrid();
	        this._initRepos();
	        this._getGlobalReplicationsStatus();
	    }

	    _createClass(AdminRepositoriesController, {
	        isCurrentRepoType: {
	            value: function isCurrentRepoType(type) {
	                return this.currentRepoType == type;
	            }
	        },
	        _createGrid: {

	            /**
	             * Creates the grid according to current repo type, sets draggable according to the global repo status
	             * NOTE: Multi select and batch actions are commented until batch delete repos is approved for prod.
	             */

	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect();
	                //.setBatchActions(this._getBatchActions())
	                this.gridOption.setRowTemplate("default");
	            }
	        },
	        _initRepos: {
	            value: function _initRepos() {
	                var _this = this;

	                this.repositoriesDao.getRepositories({ type: this.currentRepoType }).$promise.then(function (data) {
	                    _this.noReposMessage = _this.CONFIG_MESSAGES[_this.currentRepoType].noReposMessage;
	                    _.forEach(data, function (row) {
	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.repoType.toLowerCase();
	                        });
	                        if (rowPackageType) {
	                            row.displayType = rowPackageType.text;
	                            row.typeIcon = rowPackageType.icon;
	                        } else if (row.repoType.toLowerCase() === FIELD_OPTIONS.REPO_TYPE.DISTRIBUTION) {} else row.ignore = true;
	                    });
	                    data = _.filter(data, function (row) {
	                        return !row.ignore;
	                    });
	                    _this.gridData = data;
	                    _this.gridOption.setGridData(data);
	                });
	            }
	        },
	        reorderRepositories: {
	            value: function reorderRepositories() {
	                return this.repositoriesDao.reorderRepositories({ repoType: this.currentRepoType }, this.getRepoOrder()).$promise;
	            }
	        },
	        getRepoOrder: {
	            value: function getRepoOrder() {
	                var repoOrderList = [];
	                this.gridData.forEach(function (data) {
	                    repoOrderList.push(data.repoKey);
	                });
	                return repoOrderList;
	            }
	        },
	        _deleteSelected: {
	            value: function _deleteSelected(row) {
	                var _this = this;

	                this.modal.confirm("Are you sure you wish to delete this repository? All artifacts will be permanently deleted.", "Delete " + row.repoKey + " Repository", { confirm: "Delete" }).then(function () {
	                    _this.repositoriesDao.deleteRepository({
	                        type: _this.currentRepoType,
	                        repoKey: row.repoKey
	                    }).$promise.then(function (result) {
	                        _this._initRepos();
	                    });
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this._deleteSelectedRepos();
	                    }
	                }];
	            }
	        },
	        _deleteSelectedRepos: {
	            value: function _deleteSelectedRepos() {
	                var selectedRows = this.gridOption.api.selection.getSelectedGridRows();
	            }
	        },
	        _editSelected: {
	            value: function _editSelected(row) {
	                this.$state.go("^.list.edit", { repoType: this.currentRepoType, repoKey: row.repoKey });
	            }
	        },
	        createNewRepo: {
	            value: function createNewRepo() {
	                this.$state.go("^.list.new", { repoType: this.currentRepoType });
	            }
	        },
	        _calculateIndex: {
	            value: function _calculateIndex(row) {
	                this.artifactActionsDao.perform({
	                    action: "calculateIndex",
	                    type: row.repoType,
	                    repoKey: row.repoKey
	                });
	            }
	        },
	        localReplicationsRunNow: {
	            value: function localReplicationsRunNow(repoKey) {
	                this.repositoriesDao.runNowReplications({ repoKey: repoKey }).$promise.then(function () {});
	            }
	        },
	        remoteExecuteReplicationNow: {
	            value: function remoteExecuteReplicationNow(repoKey) {
	                this.repositoriesDao.executeRemoteReplicationNow({ repoKey: repoKey }, this.repoInfo).$promise.then(function (result) {});
	            }
	        },
	        _getGlobalReplicationsStatus: {
	            value: function _getGlobalReplicationsStatus() {
	                var _this = this;

	                this.globalReplicationsConfigDao.status().$promise.then(function (status) {
	                    _this.globalReplicationsStatus = {
	                        blockPullReplications: status.blockPullReplications,
	                        blockPushReplications: status.blockPushReplications
	                    };
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                switch (this.currentRepoType) {
	                    case "local":
	                        return this._getLocalColumns();
	                    case "remote":
	                        return this._getRemoteColumns();
	                    case "virtual":
	                        return this._getVirtualColumns();
	                    case "distribution":
	                        return this._getDistColumns();
	                }
	            }
	        },
	        _getLocalColumns: {
	            value: function _getLocalColumns() {
	                var _this = this;

	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.list.edit({repoType:'local',repoKey: row.entity.repoKey})\" id=\"repositories-local-key\">{{COL_FIELD}}</a></div>",
	                    width: "55%",
	                    enableSorting: true
	                    //sort: {
	                    //    direction: this.uiGridConstants.ASC
	                    //}
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "15%",
	                    enableSorting: true
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-local-reindex\"></a></div>",
	                    width: "15%",
	                    enableSorting: true
	                }, {
	                    name: "Replications",
	                    displayName: "Replications",
	                    field: "replications",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" ng-class=\"{'replication-disabled': grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications}\"><a class=\"grid-column-button icon icon-run\" ng-click=\"(!row.entity.replications || grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications) || grid.appScope.Repositories.localReplicationsRunNow(row.entity.repoKey)\" ng-disabled=\"!row.entity.replications\" jf-tooltip=\"{{grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications ? 'Push Replication Is Blocked' : (row.entity.replications ? 'Run Replication' : 'No Replication Configured')}}\" id=\"repositories-local-replicate\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getRemoteColumns: {
	            value: function _getRemoteColumns() {
	                var _this = this;

	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.list.edit({repoType:'remote',repoKey: row.entity.repoKey})\" id=\"repositories-remote-key\">{{COL_FIELD}}</a></div>",
	                    width: "20%",
	                    enableSorting: true
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "10%",
	                    enableSorting: true
	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "url",
	                    width: "40%",
	                    enableSorting: true
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-local-reindex\"></a></div>",
	                    width: "15%",
	                    enableSorting: false
	                }, {
	                    name: "Replications",
	                    displayName: "Replications",
	                    field: "hasEnabledReplication",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" ng-class=\"{'replication-disabled': grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications}\"><a class=\"grid-column-button icon icon-run\" ng-click=\"(!row.entity.hasEnabledReplication || grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications) || grid.appScope.Repositories.remoteExecuteReplicationNow(row.entity.repoKey)\" ng-disabled=\"!row.entity.hasEnabledReplication\" jf-tooltip=\"{{grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications ? 'Pull Replication Is Blocked' : (row.entity.hasEnabledReplication ? 'Run Replication' : 'No Replication Configured')}}\" id=\"repositories-local-replicate\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getVirtualColumns: {
	            value: function _getVirtualColumns() {
	                var _this = this;

	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.list.edit({repoType:'virtual',repoKey: row.entity.repoKey})\" id=\"repositories-virtual-key\">{{COL_FIELD}}</a></div>",
	                    width: "20%",
	                    enableSorting: true
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "10%",
	                    enableSorting: true
	                }, {
	                    name: "Included Repositories",
	                    displayName: "Included Repositories",
	                    field: "numberOfIncludesRepositories",
	                    width: "15%",
	                    enableSorting: false
	                }, {
	                    name: "Selected Repositories",
	                    displayName: "Selected Repositories",
	                    field: "selectedRepos",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.selectedRepos", "row.entity.repoKey", null, null, "repositories-virtual-selected"),
	                    width: "40%",
	                    enableSorting: false
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-virtual-reindex\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getDistColumns: {
	            value: function _getDistColumns() {
	                var _this = this;

	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.list.edit({repoType:'distribution',repoKey: row.entity.repoKey})\" id=\"repositories-distribution-key\">{{COL_FIELD}}</a></div>",
	                    width: "85%",
	                    enableSorting: true
	                }, {
	                    name: "Repository Visibility",
	                    displayName: "Repository Visibility",
	                    field: "visibility",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repository-visibility\">{{row.entity.visibility}}</div>",
	                    width: "15%",
	                    enableSorting: true,
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    }
	                } /*,
	                  {
	                     name: 'Status',
	                     displayName: 'Status',
	                     field: 'status',
	                     cellTemplate: this.commonGridColumns.ajaxColumn(),
	                     width: '15%',
	                     actions: {
	                         delete: row => this._deleteSelected(row);
	                     }
	                  }*/
	                ];
	            }
	        }
	    });

	    return AdminRepositoriesController;
	})();

	/*this.repositoriesDao.checkBintrayAuthentication({repoKey: row.repoKey}).$promise.then((result,row) => {
	    //row.status = result;
	    console.log('Check validation for: ' + row.repoKey);
	}).catch(() => {
	    row.status = "Error";
	    console.log('Error checking ' + row.repoKey);
	});*/

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var fieldsValuesDictionary = _interopRequire(__webpack_require__(163));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminRepositoryFormController = exports.AdminRepositoryFormController = (function () {
	    function AdminRepositoryFormController($q, $scope, $stateParams, $state, $timeout, $location, RepositoriesDao, PropertySetsDao, JFrogGridFactory, ReverseProxiesDao, JFrogModal, FooterDao, ArtifactoryFeatures, JFrogNotifications, commonGridColumns, ArtifactoryModelSaver, GeneralConfigDao, DockerStatusDao, GlobalReplicationsConfigDao, XrayDao, GoogleAnalytics) {
	        _classCallCheck(this, AdminRepositoryFormController);

	        this.$scope = $scope;
	        this.$q = $q;
	        this.currentTab = "basic";
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.$location = $location;
	        this.propertySetsDao = PropertySetsDao;
	        this.globalReplicationsConfigDao = GlobalReplicationsConfigDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.notifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.generalConfigDao = GeneralConfigDao;
	        this.NO_VALUE_STRING = "** NO VALUE **";
	        this.$state = $state;
	        this.footerDao = FooterDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.repositoriesDao = RepositoriesDao;
	        this.reverseProxiesDao = ReverseProxiesDao;
	        this.xrayDao = XrayDao;
	        this.newRepository = false;
	        this.features = ArtifactoryFeatures;
	        this.replicationsGridOption = {};
	        this.replicationScope = $scope.$new();
	        this.TOOLTIP = TOOLTIP.admin.repositories;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.repositories;
	        this.DockerStatusDao = DockerStatusDao.getInstance();
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["repoInfo"], ["replications.*.proxies"]);
	        this.bintrayAuthentication = true;

	        this.reverseProxies = ["**"];

	        this.reverseProxiesSelectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	        this._setupDistribution();
	        this.licensesListConfig = {
	            sortField: "text",
	            maxItems: null,
	            plugins: ["remove_button"]
	        };

	        this._createGrid();
	        this.initRepoForm();
	        this.repoType = this.$stateParams.repoType;
	        if (this.$stateParams.repoKey) {
	            this.title = "Edit " + this.$stateParams.repoKey + " Repository";
	            this.newRepository = false;
	            this.editRepository(this.$stateParams.repoKey);
	        } else {
	            this.newRepository = true;
	            this.repoInfo = new RepositoriesDao();
	            this.title = "New " + _.capitalize(this.repoType) + " Repository";
	            this._initNewRepositoryTypeConfig();

	            if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                if (!this.repoInfo.basic) {
	                    this.repoInfo.basic = {};
	                    this.repoInfo.basic.contentSynchronisation = {};
	                    this.repoInfo.basic.contentSynchronisation.statistics = {};
	                    this.repoInfo.basic.contentSynchronisation.properties = {};
	                }

	                this.repoInfo.basic.contentSynchronisation.enabled = false;
	                this.repoInfo.basic.contentSynchronisation.statistics.enabled = false;
	                this.repoInfo.basic.contentSynchronisation.properties.enabled = false;
	            }
	        }
	        this.packageType = fieldsValuesDictionary.repoPackageTypes;

	        this._getBaseUrl();
	        this._getGlobalReplicationsStatus();
	        this.originalValueFlag = true;
	        this.footerDao.get(true);

	        this.repositoryFilterTooltip = this.TOOLTIP.rulesPopup.repositoryFilterTooltip;
	        this.pathFilterToolip = this.TOOLTIP.rulesPopup.pathFilterToolip;
	        this.noReplicationsMessage = this.CONFIG_MESSAGES.local.noReplicationsMessage;
	    }

	    _createClass(AdminRepositoryFormController, {
	        isCurrentRepoType: {
	            value: function isCurrentRepoType(type) {
	                return this.repoType == type;
	            }
	        },
	        initRepoForm: {

	            /**
	             * init propertiesSets  and replication scope functions for modal and fields options
	             */

	            value: function initRepoForm() {
	                var _this = this;

	                this.replicationScope.replication = {}; //to create a single replication
	                this.replicationScope.testLocalReplicationUrl = function (url) {
	                    return _this.testLocalReplicationUrl(url);
	                };

	                this.replicationScope.addReplication = function (replication) {
	                    return _this.addReplication(replication);
	                };
	                this.replicationScope.closeModal = function () {
	                    return _this.closeModal();
	                };
	                this.replicationScope.RepositoryForm = this;
	            }
	        },
	        editRepository: {

	            /**
	             * run only if edit repository and get repository data
	             */

	            value: function editRepository(repoKey) {
	                var _this = this;

	                this.repositoriesDao.getRepository({ type: this.repoType, repoKey: repoKey }).$promise.then(function (info) {
	                    _this.repoInfo = info;

	                    _this.repoInfo.basic.includesPatternArray = _this.repoInfo.basic.includesPattern ? _this.repoInfo.basic.includesPattern.split(",") : [];
	                    _this.repoInfo.basic.excludesPatternArray = _this.repoInfo.basic.excludesPattern ? _this.repoInfo.basic.excludesPattern.split(",") : [];

	                    var repoPackageType = _.where(fieldsValuesDictionary.repoPackageTypes, { serverEnumName: _this.repoInfo.typeSpecific.repoType });

	                    if (repoPackageType.length) {
	                        _this.repoInfo.typeSpecific.text = repoPackageType[0].text;
	                        _this.repoInfo.typeSpecific.icon = repoPackageType[0].icon;
	                    }

	                    if (_this.repoInfo.typeSpecific.repoType === "Docker" && !_this.features.isAol() && !_this.features.isOss()) {
	                        _this._getReveresProxyConfigurations();
	                    }

	                    if (_this.repoInfo.replications && _this.repoInfo.replications.length) {
	                        _this.repoInfo.cronExp = _this.repoInfo.replications[0].cronExp;
	                        _this.repoInfo.enableEventReplication = _this.repoInfo.replications[0].enableEventReplication;
	                    }
	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this._getRepositoriesByType();
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE && _this.repoInfo.replications) {
	                        _this.repoInfo.replication = _this.repoInfo.replications[0];
	                    } else {
	                        _this.replicationsGridOption.setGridData(_this.repoInfo.replications);
	                    }
	                    _this._getFieldsOptions();

	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        _this._detectSmartRepository(false).then(function () {
	                            _this.lastSmartRemoteURL = _this.repoInfo.basic.url;
	                        });
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE || _this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                        if (_this.repoInfo.typeSpecific.maxUniqueSnapshots === 0) {
	                            _this.repoInfo.typeSpecific.maxUniqueSnapshots = "";
	                        }
	                        if (_this.repoInfo.typeSpecific.maxUniqueTags === 0) {
	                            _this.repoInfo.typeSpecific.maxUniqueTags = "";
	                        }
	                        if (_this.repoInfo.advanced.cache && _this.repoInfo.advanced.cache.keepUnusedArtifactsHours === 0) {
	                            _this.repoInfo.advanced.cache.keepUnusedArtifactsHours = "";
	                        }
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        if (!_this.repoInfo.typeSpecific.authenticated && _this.$location.search().code) {
	                            _this.openBintrayOAuthModal();
	                        }

	                        _this.bintrayAuthentication = _this.repoInfo.typeSpecific.premium ? true : false;
	                        _this.defaultNewRepoPrivateSwitch = _this.repoInfo.basic.defaultNewRepoPrivate == true ? "Private" : "Public";
	                        _this.distributionType = _this.repoInfo.basic.productName != null;
	                        _this.distributionRules = _this.repoInfo.advanced.distributionRules;
	                        if (_this.features.isOss()) {
	                            _this.distributionRules = _.filter(_this.distributionRules, function (rule) {
	                                return _.contains(["Maven", "Gradle", "Ivy", "SBT"], rule.type);
	                            });
	                        }
	                        _this._createDistributionRulesGrid(); // Edit
	                        _this._setupLicenses();
	                        _this._setRulesPackages();
	                    }
	                    _this.repoInfo.basic.selectedLocalRepositories = _.pluck(_.filter(_this.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "local";
	                    }), "repoName");
	                    _this.repoInfo.basic.selectedRemoteRepositories = _.pluck(_.filter(_this.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "remote";
	                    }), "repoName");
	                    _this.repoInfo.basic.selectedLocalRepositories.unshift("");

	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _setDefaultProxy: {
	            value: function _setDefaultProxy() {
	                if (this.newRepository && this.fields.defaultProxy && _.has(this.repoInfo, "advanced.network")) {
	                    !this.repoInfo.advanced.network.proxy ? this.repoInfo.advanced.network.proxy = this.fields.defaultProxy : "";
	                }
	            }
	        },
	        testLocalReplicationUrl: {

	            /**
	             *test button  when adding new replication in local repository
	             */

	            value: function testLocalReplicationUrl(url) {
	                // Create a copy of the repo
	                var testRepo = angular.copy(this.repoInfo);

	                // Make sure replications is not null
	                testRepo.replications = testRepo.replications || [];

	                var testReplication = undefined;
	                if (this.replicationScope.sourceReplication) {
	                    testReplication = _.findWhere(testRepo.replications, { url: this.replicationScope.sourceReplication.url });
	                    angular.copy(this.replicationScope.replication, testReplication);
	                } else {
	                    testReplication = angular.copy(this.replicationScope.replication);
	                    testRepo.replications.push(testReplication);
	                }

	                testReplication.cronExp = this.repoInfo.cronExp;
	                testReplication.nextTime = this.repoInfo.nextTime;
	                testReplication.type = this.repoType;
	                testReplication.enableEventReplication = this.repoInfo.enableEventReplication;

	                this.repositoriesDao.testLocalReplication({ replicationUrl: url }, testRepo);
	            }
	        },
	        testRemoteUrl: {
	            value: function testRemoteUrl() {
	                this.repositoriesDao.testRemoteUrl(this.repoInfo).$promise.then(function (result) {});

	                this._detectSmartRepository();
	            }
	        },
	        _detectSmartRepository: {
	            value: function _detectSmartRepository() {
	                var _this = this;

	                var showModal = arguments[0] === undefined ? true : arguments[0];

	                if (this.features.isOss()) {
	                    return this.$q.when();
	                }

	                var defer = this.$q.defer();
	                this.smartRepoUnknownCapabilities = false;

	                var repoInfoCopy = angular.copy(this.repoInfo);
	                if (!repoInfoCopy.typeSpecific.repoType) {
	                    repoInfoCopy.typeSpecific.repoType = "Generic";
	                }

	                this.repositoriesDao.detectSmartRepository(repoInfoCopy).$promise.then(function (result) {
	                    if (result.artifactory && result.version && result.features.length) {
	                        if (!_this.repoInfo.basic.contentSynchronisation.enabled || _this.repoInfo.basic.url != _this.lastSmartRemoteURL) {
	                            _this.repoInfo.basic.contentSynchronisation.enabled = true;
	                            _this.lastSmartRemoteURL = _this.repoInfo.basic.url;
	                            _this.smartRepoFeatures = result.features;

	                            if (localStorage.disableSmartRepoPopup !== "true" && showModal) {
	                                (function () {
	                                    var modalInstance = undefined;
	                                    var modalScope = _this.$scope.$new();
	                                    modalScope.smartRepo = _this.repoInfo.basic.contentSynchronisation;
	                                    modalScope.smartRepo.typeSpecific = _this.repoInfo.typeSpecific;
	                                    modalScope.closeModal = function () {
	                                        return modalInstance.close();
	                                    };
	                                    modalScope.options = { dontShowAgain: false };
	                                    modalScope.isSmartRepoSupportFeature = function (featureName) {
	                                        return _this.isSmartRepoSupportFeature(featureName);
	                                    };
	                                    modalScope.onDontShowAgain = function () {
	                                        localStorage.disableSmartRepoPopup = modalScope.options.dontShowAgain;
	                                    };
	                                    modalInstance = _this.modal.launchModal("smart_remote_repository", modalScope);
	                                })();
	                            }

	                            defer.resolve(true);
	                        } else defer.resolve(false);
	                    } else {
	                        if (result.artifactory && result.version === null) {
	                            _this.smartRepoUnknownCapabilities = true;
	                        }
	                        _this.repoInfo.basic.contentSynchronisation.enabled = false;
	                        defer.resolve(false);
	                    }
	                });

	                return defer.promise;
	            }
	        },
	        isSmartRepoSupportFeature: {
	            value: function isSmartRepoSupportFeature(featureName) {
	                return _.findWhere(this.smartRepoFeatures, { name: featureName }) !== undefined;
	            }
	        },
	        onBlurCredentials: {
	            value: function onBlurCredentials() {
	                if (this.smartRepoUnknownCapabilities && this.repoInfo.advanced.network.username && this.repoInfo.advanced.network.password) {
	                    this._detectSmartRepository();
	                }
	            }
	        },
	        testRemoteReplication: {
	            value: function testRemoteReplication() {
	                this.addReplication(this.repoInfo.replication);
	                this.repositoriesDao.testRemoteReplication(this.repoInfo).$promise.then(function (result) {});
	            }
	        },
	        setSnapshotVersionBehavior: {
	            value: function setSnapshotVersionBehavior() {
	                if (this.repoInfo && this.repoInfo.typeSpecific && this.repoInfo.typeSpecific.snapshotVersionBehavior) {
	                    if (this.repoInfo.typeSpecific.snapshotVersionBehavior == "NONUNIQUE") {
	                        //this.repoInfo.typeSpecific.maxUniqueSnapshots = 0;
	                        this.disableMaxUniqueSnapshots = true;
	                    } else {
	                        this.disableMaxUniqueSnapshots = false;
	                    }
	                }
	            }
	        },
	        _initNewRepositoryTypeConfig: {
	            value: function _initNewRepositoryTypeConfig() {
	                var _this = this;

	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    this.repoInfo.type = "localRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.type = "remoteRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    this.repoInfo.type = "virtualRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.repoInfo.type = "distributionRepoConfig";
	                }

	                this._getDefaultModels().then(function () {
	                    _this._getFieldsOptions().then(function () {
	                        _this._setDefaultFields();
	                        if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                            _this.openBintrayOAuthModal();
	                        } else {
	                            _this.openRepoTypeModal();
	                        }
	                        _this.ArtifactoryModelSaver.save();
	                    });

	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                        _this.repoInfo.type = "localRepoConfig";
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        _this.repoInfo.type = "remoteRepoConfig";
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this.repoInfo.type = "virtualRepoConfig";
	                    }
	                });
	            }
	        },
	        _populateProperties: {

	            /**
	             * get all properties
	             */

	            value: function _populateProperties() {
	                var _this = this;

	                return this.propertySetsDao.query({ isRepoForm: true }).$promise.then(function (properites) {
	                    _this.propertiesList = properites;
	                });
	            }
	        },
	        _getFieldsOptions: {

	            /**
	             * set dropdown options and default fields
	             */

	            value: function _getFieldsOptions() {
	                var _this = this;

	                return this.repositoriesDao.getAvailableChoicesOptions().$promise.then(function (fields) {
	                    _this.fields = fields;
	                    _this.localChecksumPolicies = fieldsValuesDictionary.localChecksumPolicy;
	                    _this.localChecksumPoliciesKeys = Object.keys(_this.localChecksumPolicies);
	                    _this.remoteChecksumPolicies = fieldsValuesDictionary.remoteChecksumPolicy;
	                    _this.remoteChecksumPoliciesKeys = Object.keys(fieldsValuesDictionary.remoteChecksumPolicy);
	                    fields.proxies = fields.proxies || [];
	                    fields.proxies.unshift("");
	                    fields.webStartKeyPairs = fields.webStartKeyPairs || [];
	                    fields.webStartKeyPairs.unshift("");
	                    _this.repositoryLayouts = _.sortBy(fields.repositoryLayouts, function (layout) {
	                        return layout;
	                    });
	                    _this.xraySeverities = fields.xraySeverities;
	                    _this.xraySeverities.unshift("");

	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this.repositoryLayouts.unshift("");
	                    }
	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        _this.ruleTokensByType = fields.distributionTokensByType;
	                        _this.ruleTokensByLayout = fields.distributionTokensByLayout;
	                        _this.ruleTokensByLayoutKeys = Object.keys(_this.ruleTokensByLayout);

	                        _this.distributionDefaultRules = fields.distributionDefaultRules;
	                        if (_this.features.isOss()) {
	                            _this.distributionDefaultRules = _.filter(_this.distributionDefaultRules, function (rule) {
	                                return _.contains(["Maven", "Gradle", "Ivy", "SBT"], rule.type);
	                            });
	                        }

	                        _this.distributionDefaultProductRules = fields.distributionDefaultProductRules;

	                        if (_this.newRepository) {
	                            _this.repoInfo.type = "distributionRepoConfig";
	                            _this.distributionRules = _this.distributionDefaultRules;
	                            _this._createDistributionRulesGrid(); // NEW
	                        }
	                    }

	                    _this.remoteLayoutMapping = angular.copy(fields.repositoryLayouts);
	                    _this.remoteLayoutMapping.unshift("");
	                    _this.mavenSnapshotRepositoryBehaviors = fieldsValuesDictionary.snapshotRepositoryBehavior;
	                    _this.mavenSnapshotRepositoryBehaviorsKeys = Object.keys(fieldsValuesDictionary.snapshotRepositoryBehavior);
	                    _this.pomCleanupPolicies = fieldsValuesDictionary.pomCleanupPolicy;
	                    _this.pomCleanupPoliciesKeys = Object.keys(fieldsValuesDictionary.pomCleanupPolicy);
	                    _this.vcsGitProviderOptions = fieldsValuesDictionary.vcsGitProvider;
	                    _this.vcsGitProviderOptionsKeys = Object.keys(fieldsValuesDictionary.vcsGitProvider);
	                    _this.setSnapshotVersionBehavior();
	                    return _this._populateProperties();
	                });
	            }
	        },
	        _getDefaultModels: {

	            /**
	             * fetching from server the default data
	             */

	            value: function _getDefaultModels() {
	                var _this = this;

	                return this.repositoriesDao.getDefaultValues().$promise.then(function (models) {
	                    _this.defaultModels = models.defaultModels;
	                });
	            }
	        },
	        setCurrentTab: {

	            /**
	             * check and set current tab
	             */

	            value: function setCurrentTab(tab) {
	                if (this.features.isDisabled(tab)) {
	                    return;
	                }
	                this.currentTab = tab;
	            }
	        },
	        isCurrentTab: {
	            value: function isCurrentTab(tab) {
	                return this.currentTab === tab;
	            }
	        },
	        save: {

	            /**
	             * handle save or update click
	             */

	            value: function save() {
	                var _this = this;

	                var pending = this.repositoriesForm.repoKey.$pending;
	                if (pending && pending.repoKeyValidator) {
	                    this.$timeout(function () {
	                        _this.save();
	                    }, 100);
	                    return;
	                }

	                if (this.savePending) {
	                    return;
	                }if (!this.repositoriesForm.$valid) {
	                    return;
	                }this.savePending = true;

	                this.repoInfo.basic.includesPattern = this.repoInfo.basic.includesPatternArray.join(",") || undefined;
	                this.repoInfo.basic.excludesPattern = this.repoInfo.basic.excludesPatternArray.join(",") || undefined;

	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    if (this.repoInfo.replications && this.repoInfo.replications.length) {
	                        this.saveCronAndEventFlagToAllReplicationsAndValidateHa();
	                    }
	                    //Warn user if saving cron expression without any replication config
	                    if (this.repoInfo.cronExp && (!this.repoInfo.replications || !this.repoInfo.replications.length)) {
	                        this.notifications.create({ warn: "A cron expression was entered without any replication configuration." + "\nThe expression will not be saved."
	                        });
	                    }
	                }

	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this._detectSmartRepository().then(function (result) {
	                        if (!result) {}
	                    });

	                    //Add replication if exists:
	                    if (this.repoInfo.replication) {
	                        if (this.repoInfo.cronExp && this.repoInfo.replication.enabled && (!this.repoInfo.advanced.network.username || !this.repoInfo.advanced.network.password)) {
	                            this.notifications.create({
	                                error: "Pull replication requires non-anonymous authentication to the " + "remote repository.\nPlease make sure to fill the 'Username' and 'Password' fields in the " + "Advanced settings tab or remove the fields you filled in the replication tab."
	                            });
	                            return false;
	                        }
	                        this.addReplication(this.repoInfo.replication);
	                    }

	                    if (this.repoInfo.advanced.network.proxy === "") {
	                        delete this.repoInfo.advanced.network.proxy;
	                    }
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.repoInfo.advanced.distributionRules = this.distributionRules;
	                }
	                this.$timeout(function () {
	                    _this.save_update();
	                }, 500);
	            }
	        },
	        save_update: {

	            /**
	             * save or update wizard form
	             */

	            value: function save_update() {
	                var _this = this;

	                var recursed = arguments[0] === undefined ? false : arguments[0];
	                var changeState = arguments[1] === undefined ? true : arguments[1];

	                var defer = this.$q.defer();

	                if (!recursed && this.repoInfo.isType("cocoapods") && this.baseUrl === this.NO_VALUE_STRING) {
	                    this._showUrlBaseAlert().then(function (gotoGenConf) {
	                        if (gotoGenConf) {
	                            _this.save_update(true).then(function () {
	                                _this.$state.go("admin.configuration.general", { focusOnBaseUrl: true });
	                            });
	                        } else {
	                            _this.save_update(true);
	                        }
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else {
	                    if (this.repoInfo && this.repoInfo.typeSpecific && this.repoInfo.typeSpecific.keyPair === "") {
	                        delete this.repoInfo.typeSpecific.keyPair;
	                    }
	                    if (this.newRepository) {
	                        this.repositoriesDao.save(this.repoInfo).$promise.then(function (result) {
	                            _this.ArtifactoryModelSaver.save();
	                            _this.savePending = false;

	                            // Track new repository creation to Google Analytics
	                            if (_this.repoInfo && _this.repoInfo.typeSpecific) {
	                                if (_.contains(["local", "remote", "distribution"], _this.repoType)) {
	                                    _this.GoogleAnalytics.trackEvent("Admin", "Create Repo", _this.repoInfo.typeSpecific.repoType, null, _this.repoType);
	                                } else if (_this.repoType === "virtual") {
	                                    var virtualData = [];

	                                    // Enable Dependency Rewrite (bower/npm)
	                                    var repoType = _this.repoInfo.typeSpecific.repoType;
	                                    if (repoType === "Bower" || repoType === "Npm") {
	                                        virtualData.push("enableDependencyRewrite:" + _this.repoInfo.typeSpecific.enableExternalDependencies);
	                                    }

	                                    // Default Deployment Repository
	                                    var defaultDeploymentRepo = _this.repoInfo.basic.defaultDeploymentRepo ? true : false;
	                                    virtualData.unshift("defaultDeploymentRepo:" + defaultDeploymentRepo);

	                                    _this.GoogleAnalytics.trackEvent("Admin", "Create Repo", _this.repoInfo.typeSpecific.repoType, _this.repoInfo.basic.selectedRepositories.length, _this.repoType, virtualData[0] || "", virtualData[1] || "");
	                                }
	                            }

	                            if (_this.repoInfo.typeSpecific.repoType === "Docker" && _this.features.isAol()) {
	                                (function () {
	                                    var modalScope = _this.$scope.$new();

	                                    var dockerData = {
	                                        repoKey: _this.repoInfo.general.repoKey,
	                                        packageType: _this.repoType
	                                    };

	                                    _this.DockerStatusDao.get({ repoKey: dockerData.repoKey }).$promise.then(function (data) {
	                                        dockerData.hostname = data.hostname;
	                                        dockerData.dockerPath = data.hostname + "-" + dockerData.repoKey + ".jfrog.io";
	                                        dockerData.noDeployToLocal = !_this.repoInfo.basic.defaultDeploymentRepo;

	                                        switch (dockerData.packageType) {
	                                            case "local":
	                                                dockerData.snippets = [{ message: "According to the repository permission, you will need to login to your repository with docker login command", snippet: "docker login " + dockerData.dockerPath }, { message: "Pull an image.", snippet: "docker pull hello-world" }, { message: "Tag an image.", snippet: "docker tag hello-world " + dockerData.dockerPath + "/hello-world" }, { message: "Then push it to your repository.", snippet: "docker push " + dockerData.dockerPath + "/hello-world" }];
	                                                break;
	                                            case "remote":
	                                                dockerData.snippets = [{ message: "According to the repository permission, you will need to login to your repository with docker login command", snippet: "docker login " + dockerData.dockerPath }, { message: "Pull an image from your repository.", snippet: "docker pull " + dockerData.dockerPath + "/hello-world" }];
	                                                break;
	                                            case "virtual":
	                                                if (!dockerData.noDeployToLocal) {
	                                                    dockerData.snippets = [{ message: "According to the repository permission, you will need to login to your repository with docker login command", snippet: "docker login " + dockerData.dockerPath }, { message: "Pull an image.", snippet: "docker pull hello-world" }, { message: "And to test deploy to virtual, tag an image.", snippet: "docker tag hello-world " + dockerData.dockerPath + "/hello-world" }, { message: "Then push it.", snippet: "docker push " + dockerData.dockerPath + "/hello-world" }, { message: "To pull an image from your repository.", snippet: "docker pull " + dockerData.dockerPath + "/hello-world" }];
	                                                } else {
	                                                    dockerData.snippets = [{ message: "According to the repository permission, you will need to login to your repository with docker login command", snippet: "docker login " + dockerData.dockerPath }, { message: "Pull an image from your repository.", snippet: "docker pull " + dockerData.dockerPath + "/hello-world" }];
	                                                }
	                                                break;
	                                        }

	                                        modalScope.dockerData = dockerData;

	                                        _this.dockerPopup = _this.modal.launchModal("new_docker_modal", modalScope).result;
	                                        _this.dockerPopup["finally"](function () {
	                                            if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                                        });
	                                    });
	                                })();
	                            } else if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                            defer.resolve();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    } else {
	                        this.repositoriesDao.update(this.repoInfo).$promise.then(function (result) {
	                            _this.ArtifactoryModelSaver.save();
	                            _this.savePending = false;

	                            if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                            defer.resolve();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    }
	                }

	                return defer.promise;
	            }
	        },
	        _showUrlBaseAlert: {
	            value: function _showUrlBaseAlert() {
	                var modalScope = this.$scope.$new();
	                modalScope.context = "cocoapods";
	                return this.modal.launchModal("base_url_alert_modal", modalScope, "md").result;
	            }
	        },
	        prevStep: {

	            /**
	             * button pre and  forward at the bottom page
	             */

	            value: function prevStep() {
	                if (this.currentTab == "advanced") {
	                    this.setCurrentTab("basic");
	                } else if (this.currentTab == "replications") {
	                    this.setCurrentTab("advanced");
	                } else if (this.currentTab == "rules") {
	                    this.setCurrentTab("advanced");
	                }
	            }
	        },
	        fwdStep: {
	            value: function fwdStep() {
	                if (this.currentTab == "basic") {
	                    this.setCurrentTab("advanced");
	                    return;
	                }
	                if (this.currentTab == "advanced" && this.repoType != fieldsValuesDictionary.REPO_TYPE.VIRTUAL && this.repoType != fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.setCurrentTab("replications");
	                }
	                if (this.currentTab == "advanced" && this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.setCurrentTab("rules");
	                }
	            }
	        },
	        openRepoTypeModal: {

	            /**
	             * function for select package type
	             */

	            value: function openRepoTypeModal() {
	                var _this = this;

	                var addTextBelowIcon = ["Bower", "Chef", "CocoaPods", "Conan", "Pypi", "Puppet", "Opkg", "Composer", "SBT", "Gradle", "Gems", "NuGet", "GitLfs", "Generic", "P2", "VCS"];
	                this.$repoTypeScope = this.$scope.$new();
	                this.$repoTypeScope.packageTypes = this.getPackageType();
	                this.$repoTypeScope.highlightCheck = function (typeFilter, type) {
	                    if (typeFilter) {
	                        var string = type.text.toLowerCase(),
	                            searchstring = typeFilter.toLowerCase().replace(/ /g, "");

	                        if (string.substr(0, searchstring.length) == searchstring) {
	                            type.highlighted = true;
	                            return true;
	                        } else {
	                            type.highlighted = false;
	                            return false;
	                        };
	                    }
	                };
	                this.$repoTypeScope.checkNoResults = function (typeFilter) {
	                    if (typeFilter && typeFilter.length > 0 && _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    }).length == 0) {
	                        return true;
	                    }
	                };
	                this.$repoTypeScope.isSelected = function () {
	                    var HighlightedListItems = _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    });
	                    if (HighlightedListItems.length == 1) {
	                        return true;
	                    }
	                };
	                this.$repoTypeScope.selectPackage = function () {
	                    var selectedItem = _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    });
	                    if (selectedItem.length == 1) {
	                        _this.selectRepoType(selectedItem[0]);
	                    }
	                };

	                _.map(this.$repoTypeScope.packageTypes, function (type) {
	                    // console.log(type)
	                    if (_.includes(addTextBelowIcon, type.serverEnumName)) type.helpText = true;
	                });

	                this.$repoTypeScope.closeModal = function () {
	                    return _this.closeModalPackageType();
	                };
	                this.$repoTypeScope.modalClose = function () {
	                    return _this.modalClose();
	                };
	                this.$repoTypeScope.selectRepoType = function (type) {
	                    return _this.selectRepoType(type);
	                };
	                this.isTypeModalOpen = true;

	                this.repoTypeModal = this.modal.launchModal("repository_type_modal", this.$repoTypeScope, 930);
	                this.repoTypeModal.result["finally"](function () {
	                    _this.repositoriesForm.repoKey.$validate();
	                    _this.isTypeModalOpen = false;
	                });
	            }
	        },
	        openBintrayOAuthModal: {
	            value: function openBintrayOAuthModal() {
	                var _this = this;

	                this.$bintrayAuthScope = this.$scope.$new();
	                //Stuff for outgoing request
	                this.$bintrayAuthScope.isBackFromBintray = this.$location.search().code;
	                this.$bintrayAuthScope.bintrayBaseUrl = this.repoInfo.typeSpecific.bintrayBaseUrl;
	                this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl());

	                if (this.$bintrayAuthScope.isBackFromBintray) {
	                    this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl().split("?")[0]);
	                    //this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl().substring(0, this.$location.absUrl().indexOf('?')));
	                } else {
	                    this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl());
	                }

	                this.$bintrayAuthScope.config = { bintraySecretString: "" };
	                this.$bintrayAuthScope.saveBintrayAuthInModel = function () {
	                    return _this.saveBintrayAuthInModel(_this.$bintrayAuthScope.config.bintraySecretString);
	                };
	                this.isBintrayModalOpen = true;

	                this.bintrayAuthModal = this.modal.launchModal("bintray_oauth_modal", this.$bintrayAuthScope, 600);
	                this.bintrayAuthModal.result.then(function () {
	                    _this.isBintrayModalOpen = false;
	                    _this.repositoriesForm.repoKey.$validate();
	                });
	                this.bintrayAuthModal.result["catch"](function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.list", { repoType: _this.repoType });
	                });
	            }
	        },
	        goToBintray: {
	            value: function goToBintray() {
	                var url = this.$bintrayAuthScope.bintrayBaseUrl + "/login/oauth/authorize?scope=org:?:admin&redirect_uri=" + this.$bintrayAuthScope.redirectUrl + "&artifactory_originated=Oik=";
	                window.open(url, "_self");
	            }
	        },
	        closeModalPackageType: {
	            value: function closeModalPackageType() {
	                if (!this.repoType) {
	                    return false;
	                }
	                if (this.newRepository) {
	                    this.setRepoLayout();
	                }
	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    // Resetting resolved and selected repositories lists in case we are changing package type
	                    if (this.newRepository) {
	                        this.repoInfo.basic.selectedRepositories = [];
	                        this.repoInfo.basic.resolvedRepositories = [];
	                    }
	                    this._getRepositoriesByType();
	                }
	            }
	        },
	        _getRepositoriesByType: {
	            value: function _getRepositoriesByType() {
	                var _this = this;

	                this.repositoriesDao.availableRepositoriesByType({
	                    type: this.repoInfo.typeSpecific.repoType,
	                    repoKey: this.repoInfo.general ? this.repoInfo.general.repoKey : ""
	                }).$promise.then(function (repos) {
	                    repos.availableLocalRepos = _.map(repos.availableLocalRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "local",
	                            _iconClass: "icon icon-local-repo"
	                        };
	                    });
	                    repos.availableRemoteRepos = _.map(repos.availableRemoteRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "remote",
	                            _iconClass: "icon icon-remote-repo"
	                        };
	                    });
	                    repos.availableVirtualRepos = _.map(repos.availableVirtualRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "virtual",
	                            _iconClass: "icon icon-virtual-repo"
	                        };
	                    });

	                    _this.repoInfo.basic.selectedRepositories = _.map(_this.repoInfo.basic.selectedRepositories, function (repo) {
	                        if (repo.type == "local") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "local",
	                                _iconClass: "icon icon-local-repo"
	                            };
	                        } else if (repo.type == "remote") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "remote",
	                                _iconClass: "icon icon-remote-repo"
	                            };
	                        } else if (repo.type == "virtual") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "virtual",
	                                _iconClass: "icon icon-virtual-repo"
	                            };
	                        }
	                    });

	                    _this.repositoriesList = [];
	                    _this.repositoriesList = repos.availableLocalRepos.concat(repos.availableRemoteRepos).concat(repos.availableVirtualRepos);

	                    if (!_this.newRepository) _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getReplicationActions: {
	            value: function getReplicationActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-run",
	                    tooltip: "Run Now",
	                    visibleWhen: function (row) {
	                        return !_this.globalReplicationsStatus.blockPushReplications && row.enabled;
	                    },
	                    callback: function (row) {
	                        return _this.executeReplicationNow(row);
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deleteReplication(row);
	                    }
	                }];
	            }
	        },
	        executeReplicationNow: {
	            value: function executeReplicationNow(row) {
	                if (true) {
	                    this.repositoriesDao.executeReplicationNow({ replicationUrl: row.url }, this.repoInfo).$promise.then(function (result) {});
	                }
	            }
	        },
	        setRepoLayout: {
	            value: function setRepoLayout() {
	                var _this = this;

	                var foundLayout = false;
	                if (_.has(this.repoInfo, "typeSpecific.repoType")) {
	                    (function () {
	                        var type = _this.repoInfo.typeSpecific.repoType.toLowerCase();
	                        var defaultLayouts = fieldsValuesDictionary.defaultLayouts;
	                        if (!_this.repoInfo.basic) {
	                            _this.repoInfo.basic = {};
	                            _this.repoInfo.basic.repositoryLayout = {};
	                        }
	                        _this.repositoryLayouts = _.filter(_this.repositoryLayouts, function (layout) {
	                            return layout !== "";
	                        });
	                        if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                            _this.repositoryLayouts.unshift("");
	                        }

	                        var defaultLayout = defaultLayouts[type];
	                        if (defaultLayout && _.includes(_this.repositoryLayouts, defaultLayout)) {
	                            _this.repoInfo.basic.layout = defaultLayout;
	                            foundLayout = true;
	                        } else {
	                            _this.repositoryLayouts.forEach(function (layout) {
	                                if (layout.indexOf(type) != -1) {
	                                    _this.repoInfo.basic.layout = layout;
	                                    foundLayout = true;
	                                }
	                            });
	                        }
	                        if (!foundLayout) {
	                            _this.repoInfo.basic.layout = "simple-default";
	                        }
	                    })();
	                }
	            }
	        },
	        _setDefaultValuesByType: {

	            /**
	             * set default fields for new repository
	             */

	            value: function _setDefaultValuesByType() {
	                if (!(this.repoInfo && this.repoInfo.typeSpecific)) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                var type = this.repoInfo.typeSpecific.repoType.toLowerCase();
	                if (type && this.defaultModels[type]) {
	                    angular.extend(this.repoInfo.typeSpecific, this.defaultModels[type]);
	                    // add default remote url for remote repository
	                    if (this.repoType.toLocaleLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        this.repoInfo.basic.url = this.defaultModels[type].url;
	                    }
	                }
	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    this.repoInfo.basic.repositoryLayout = "";
	                }
	            }
	        },
	        _setDefaultFields: {
	            value: function _setDefaultFields() {
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.advanced = {};
	                this.repoInfo.advanced.cache = {};
	                this.repoInfo.advanced.network = {};

	                _.forEach(this.defaultModels, function (item) {
	                    if (item.maxUniqueTags === 0) {
	                        item.maxUniqueTags = "";
	                    }
	                    if (item.maxUniqueSnapshots === 0) {
	                        item.maxUniqueSnapshots = "";
	                    }
	                    if (item.keepUnusedArtifactsHours === 0) {
	                        item.keepUnusedArtifactsHours = "";
	                    }
	                });

	                angular.extend(this.repoInfo.advanced.cache, this.defaultModels.cache);
	                angular.extend(this.repoInfo.advanced.network, this.defaultModels.network);

	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    if (!this.repoInfo.advanced) {
	                        this.repoInfo.advanced = {};
	                    }
	                    if (!this.repoInfo.basic) {
	                        this.repoInfo.basic = {};
	                    }

	                    angular.extend(this.repoInfo.advanced, this.defaultModels.remoteAdvanced);
	                    angular.extend(this.repoInfo.basic, this.defaultModels.remoteBasic);
	                } else if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    if (!this.repoInfo.advanced) {
	                        this.repoInfo.advanced = {};
	                    }
	                    if (!this.repoInfo.basic) {
	                        this.repoInfo.basic = {};
	                    }
	                    angular.extend(this.repoInfo.advanced, this.defaultModels.localAdvanced);
	                    angular.extend(this.repoInfo.basic, this.defaultModels.localBasic);
	                    this.repoInfo.typeSpecific.localChecksumPolicy = this.defaultModels.maven.localChecksumPolicy;
	                    if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        this.repoInfo.typeSpecific = this.defaultModels.distribution;
	                        this.repoInfo.basic.layout = "simple-default";
	                        this.distributionType = false;
	                    }
	                }

	                this.repoInfo.basic.includesPatternArray = ["**/*"];
	                this.repoInfo.basic.excludesPatternArray = [];

	                this._setDefaultProxy();
	            }
	        },
	        selectRepoType: {
	            value: function selectRepoType(type) {
	                if (this.features.isDisabled(type.value)) {
	                    return;
	                }

	                this.repoTypeModal.close();
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.typeSpecific.repoType = type.serverEnumName;
	                this.repoInfo.typeSpecific.icon = type.icon;
	                this.repoInfo.typeSpecific.text = type.text;
	                if (this.repoInfo.typeSpecific.repoType === "Docker" && !this.features.isAol() && !this.features.isOss()) {
	                    this._getReveresProxyConfigurations();
	                }
	                if (this.repoInfo.typeSpecific.repoType === "CocoaPods" && this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.advanced.network.socketTimeout = 45000;
	                }

	                if (this.newRepository) {
	                    this._setDefaultValuesByType();
	                }
	                this.closeModalPackageType();
	            }
	        },
	        saveBintrayAuthInModel: {
	            value: function saveBintrayAuthInModel(bintraySecretString) {
	                var _this = this;

	                //todo -- should respond to feature disabled?
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.typeSpecific.repoType = "Distribution";
	                if (this.newRepository) {
	                    this._setDefaultValuesByType();
	                }
	                this.repoInfo.typeSpecific.bintrayAuthString = bintraySecretString;
	                this.repoInfo.typeSpecific.redirectUrl = this.$location.absUrl().split("?")[0];
	                this.repoInfo.typeSpecific.paramClientId = this.$location.search().client_id;
	                this.repoInfo.typeSpecific.code = this.$location.search().code;
	                this.repoInfo.typeSpecific.scope = this.$location.search().scope;
	                this.repositoriesDao.saveBintrayOauthConfig(this.repoInfo.typeSpecific).$promise.then(function (result) {
	                    _this.bintrayAuthModal.close();
	                    //Result from backend contains the key for the newly created OAuth app that this repo must reference.
	                    _this.repoInfo.typeSpecific = result.data;
	                    var isPremium = _this.repoInfo.typeSpecific.premium;
	                    if (!isPremium) {
	                        _this.bintrayAuthentication = false;
	                    }
	                    _this._setupLicenses();
	                    _this._checkVisibility(isPremium);
	                    _this._setRulesPackages();
	                })["catch"](function () {});
	            }
	        },
	        isRightColumnEmptyInLocalRepo: {
	            value: function isRightColumnEmptyInLocalRepo() {
	                return !this.repoInfo.isType("maven", "gradle", "ivy", "sbt", "yum", "cocoapods", "debian", "docker", "nuget");
	            }
	        },
	        isRightColumnEmptyInRemoteRepo: {
	            value: function isRightColumnEmptyInRemoteRepo() {
	                return !this.repoInfo.basic.contentSynchronisation.enabled && !this.smartRepoUnknownCapabilities && !this.repoInfo.isType("maven", "gradle", "ivy", "sbt", "generic", "vcs", "bower", "cocoapods", "composer", "docker", "nuget", "debian", "yum", "p2");
	            }
	        },
	        newReplication: {

	            /**
	             * newReplication; editReplication->
	             * functions for replications modal (work only for local repos)
	             */

	            value: function newReplication() {
	                if (this.repoInfo.replications && this.repoInfo.replications.length && this.features.isDisabled("highAvailability") && !this.features.isDedicatedAol()) {
	                    this.notifications.create({ warn: "Multi-push replication will only work with an Enterprise license" });
	                    return true;
	                }
	                this.replicationScope.replication = {};
	                this.replicationScope.title = "New Replication";
	                this.replicationScope.replication.socketTimeout = 15000;
	                this.replicationScope.replication.syncProperties = true;
	                this.replicationScope.sourceReplication = null;
	                this.replicationScope.replication.enabled = true;
	                this.replicationModal(false);
	            }
	        },
	        editReplication: {
	            value: function editReplication(row) {
	                this.replicationScope.title = "Replication Properties";
	                this.replicationScope.replication = angular.copy(row);
	                this.replicationScope.sourceReplication = row;
	                this.replicationModal(true);
	            }
	        },
	        _deleteReplication: {
	            value: function _deleteReplication(row) {
	                var _this = this;

	                this.modal.confirm("Are you sure you wish to delete this replication?", "Delete Replication", { confirm: "Delete" }).then(function () {
	                    _.remove(_this.repoInfo.replications, row);
	                    _this.replicationsGridOption.setGridData(_this.repoInfo.replications);
	                });
	            }
	        },
	        replicationModal: {
	            value: function replicationModal(isEdit) {
	                this.replicationScope.replication.proxies = this.fields.proxies;
	                if (!isEdit) {
	                    this.fields.defaultProxy ? this.replicationScope.replication.proxy = this.fields.defaultProxy : "";
	                }
	                this.modalInstance = this.modal.launchModal("replication_modal", this.replicationScope);
	            }
	        },
	        addReplication: {

	            /**
	             * add replication: function that save fields in form for replication.
	             * if local: push it for grid replication
	             * if remote: clear exsit replication and set the new one
	             */

	            value: function addReplication(replication) {

	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.replications = [];
	                }
	                replication.enabled = replication.enabled ? replication.enabled : false;
	                replication.syncDeletes = replication.syncDeletes ? replication.syncDeletes : false;
	                replication.syncProperties = replication.syncProperties ? replication.syncProperties : false;
	                replication.syncStatistics = replication.syncStatistics ? replication.syncStatistics : false;
	                replication.cronExp = this.repoInfo.cronExp;
	                replication.nextTime = this.repoInfo.nextTime;
	                replication.enableEventReplication = this.repoInfo.enableEventReplication;
	                replication.type = this.repoType;
	                if (replication.proxy === "") {
	                    delete replication.proxy;
	                }
	                if (this.replicationScope.sourceReplication) {
	                    // updating replication
	                    angular.copy(replication, this.replicationScope.sourceReplication);
	                } else {
	                    // adding new replication
	                    this.repoInfo.replications = this.repoInfo.replications || [];
	                    this.repoInfo.replications.push(replication);
	                }
	                if (this.repoType.toLocaleLowerCase() == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    this.replicationsGridOption.setGridData(this.repoInfo.replications);
	                    this.closeModal();
	                }
	            }
	        },
	        saveCronAndEventFlagToAllReplicationsAndValidateHa: {

	            /**
	             * Saves the cron expression and event replication flag to all replications.
	             * Also validates that if HA license is not installed - only one active replication is saved.
	             */

	            value: function saveCronAndEventFlagToAllReplicationsAndValidateHa() {
	                var _this = this;

	                //Signifies save should disable all replications but one because multiple enabled replicaions exist without HA license
	                var notHa = this.features.isDisabled("highAvailability") && !this.features.isDedicatedAol() && this.repoInfo.replications.length > 1;
	                this.repoInfo.replications.forEach(function (replication) {
	                    replication.cronExp = _this.repoInfo.cronExp;
	                    replication.enableEventReplication = _this.repoInfo.enableEventReplication;
	                    if (notHa) {
	                        replication.enabled = false;
	                    }
	                });
	                if (notHa) {
	                    this.notifications.create({ warn: "You saved multiple enabled replication configurations.\n Multi-push " + "replication is only available with an Enterprise licenses therefore only the first replication will be" + "saved as enabled and the rest will be disabled." });
	                    this.repoInfo.replications[0].enabled = true;
	                }
	            }
	        },
	        closeModal: {
	            value: function closeModal() {
	                this.modalInstance.close();
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.replicationsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect().setRowTemplate("default").setButtons(this.getReplicationActions()).setGridData([]);
	            }
	        },
	        showNextButton: {

	            /**
	             * controller display arrows form
	             */

	            value: function showNextButton() {
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    if (this.features.isDisabled("replications")) {
	                        return this.currentTab != "advanced";
	                    }
	                    return this.currentTab != "replications";
	                } else if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    if (this.features.isDisabled("rules")) {
	                        return this.currentTab != "advanced";
	                    }
	                    return this.currentTab != "rules";
	                } else {
	                    return this.currentTab != "advanced";
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "URL",
	                    displayName: "URL",
	                    field: "url",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-click=\"grid.appScope.RepositoryForm.editReplication(row.entity)\">{{row.entity.url}}</a></div>"

	                }, {
	                    name: "Sync Deletes",
	                    displayName: "Sync Deletes",
	                    field: "syncDeletes",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.syncDeletes")
	                }, {
	                    name: "Sync Properties",
	                    displayName: "Sync Properties",
	                    field: "syncProperties",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.syncProperties")
	                }, {
	                    name: "Enabled",
	                    displayName: "Enabled",
	                    field: "enabled",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.enabled")
	                }];
	            }
	        },
	        getPackageType: {

	            /**
	             * all packages sorts by type
	             */

	            value: function getPackageType() {
	                switch (this.repoType) {
	                    case fieldsValuesDictionary.REPO_TYPE.LOCAL:
	                        {
	                            return _.filter(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.LOCAL) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.REMOTE:
	                        {
	                            return _.select(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.REMOTE) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.VIRTUAL:
	                        {
	                            return _.select(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.VIRTUAL) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION:
	                        {
	                            return fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION;
	                        }
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.list", { repoType: this.repoType });
	            }
	        },
	        _getReveresProxyConfigurations: {
	            value: function _getReveresProxyConfigurations() {
	                var _this = this;

	                this.reverseProxiesDao.get().$promise.then(function (reverseProxies) {

	                    _this.reverseProxyConfigured = reverseProxies.serverName && reverseProxies.webServerType && (reverseProxies.useHttp || reverseProxies.useHttps) && reverseProxies.dockerReverseProxyMethod !== "NOVALUE";;

	                    //            this.hideReverseProxy = this.reverseProxyConfigured

	                    if (_this.reverseProxyConfigured) {
	                        if (!_this.repoInfo.advanced.reverseProxy) {
	                            _this.repoInfo.advanced.reverseProxy = {
	                                key: reverseProxies.key,
	                                serverName: reverseProxies.serverName
	                            };
	                        }
	                        if (reverseProxies.dockerReverseProxyMethod === "PORTPERREPO") {
	                            _this.reverseProxyPortMode = true;
	                            _this.repoInfo.advanced.reverseProxy.serverName = reverseProxies.serverName;
	                        } else {
	                            _this.reverseProxyPortMode = false;
	                            if (_this.repoInfo.general && _this.repoInfo.general.repoKey) _this.repoInfo.advanced.reverseProxy.serverName = reverseProxies.serverNameExpression.replace("*", _this.repoInfo.general.repoKey);
	                            _this.reverseProxyServerNameExpression = reverseProxies.serverNameExpression;
	                        }
	                    }
	                });
	            }
	        },
	        onChangeRepoKey: {
	            value: function onChangeRepoKey() {
	                if (this.repoInfo.general && this.repoInfo.general.repoKey && this.reverseProxyServerNameExpression) this.repoInfo.advanced.reverseProxy.serverName = this.reverseProxyServerNameExpression.replace("*", this.repoInfo.general.repoKey);
	            }
	        },
	        _getBaseUrl: {
	            value: function _getBaseUrl() {
	                var _this = this;

	                this.generalConfigDao.get().$promise.then(function (data) {
	                    _this.baseUrl = data.customUrlBase || _this.NO_VALUE_STRING;
	                });
	            }
	        },
	        _getGlobalReplicationsStatus: {
	            value: function _getGlobalReplicationsStatus() {
	                var _this = this;

	                this.globalReplicationsConfigDao.status().$promise.then(function (status) {
	                    _this.globalReplicationsStatus = {
	                        blockPullReplications: status.blockPullReplications,
	                        blockPushReplications: status.blockPushReplications
	                    };
	                });
	            }
	        },
	        hostYumOriginalValue: {

	            // YUM FOLDER DEPTH TOOLTIP

	            value: function hostYumOriginalValue() {
	                this.originalYumValue;
	                if (this.originalValueFlag) {
	                    this.originalYumValue = this.repoInfo.typeSpecific.metadataFolderDepth;
	                    this.originalValueFlag = false;
	                }
	            }
	        },
	        changeYumFolderDepth: {
	            value: function changeYumFolderDepth() {
	                this.yumTooltip = this.repoInfo.typeSpecific.metadataFolderDepth < this.originalYumValue ? true : false;
	            }
	        },
	        _setRulesPackages: {

	            // DISTRIBUTION RULES

	            value: function _setRulesPackages() {
	                var _this = this;

	                this.distributionRulesPackages = _.filter(this.packageType, function (o) {
	                    if (_this.features.isOss()) {
	                        return o.value == "generic" || o.value == "maven" || o.value == "gradle" || o.value == "ivy" || o.value == "sbt";
	                    } else {
	                        return o.value != "gitlfs" && o.value != "gems" && o.value != "pypi" && o.value != "p2" && o.value != "vcs";
	                    }
	                });
	                this.distributionRulesPackages.forEach(function (pack) {
	                    return delete pack.description;
	                });
	            }
	        },
	        _checkVisibility: {
	            value: function _checkVisibility(isPremium) {
	                if (!isPremium) {
	                    this.defaultNewRepoPrivateSwitch = "Public";
	                    this.repoInfo.basic.defaultNewRepoPrivate = false;
	                    this.repoInfo.basic.defaultNewRepoPremium = false;
	                } else {
	                    this.defaultNewRepoPrivateSwitch = "Private";
	                    this.repoInfo.basic.defaultNewRepoPrivate = true;
	                    this.repoInfo.basic.defaultNewRepoPremium = true;
	                }
	            }
	        },
	        _setupLicenses: {
	            value: function _setupLicenses() {
	                // License input configuration
	                this.licensesList = _.map(this.repoInfo.typeSpecific.availableLicenses, function (lic) {
	                    return {
	                        text: lic,
	                        value: lic
	                    };
	                });
	            }
	        },
	        _setupDistribution: {
	            value: function _setupDistribution() {
	                this.rulesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setMultiSelect().setColumns(this._getDistributionRulesColumns()).setButtons(this._getRulesActions()).setBatchActions(this._getBatchActions()).setDraggable(this._reorderRules.bind(this));
	            }
	        },
	        _reorderRules: {
	            value: function _reorderRules() {
	                this.distributionRules = this.rulesGridOptions.data;
	            }
	        },
	        _getRulesActions: {
	            value: function _getRulesActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deleteRule(row);
	                    }
	                }];
	            }
	        },
	        _deleteRule: {
	            value: function _deleteRule(row) {
	                var _this = this;

	                this.modal.confirm("Are you sure you wish to delete this rule?", "Delete Rule", { confirm: "Delete" }).then(function () {
	                    _.remove(_this.distributionRules, row);
	                    _this._createDistributionRulesGrid();
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                // Get All selected rules
	                var selectedRows = this.rulesGridOptions.api.selection.getSelectedRows();

	                // Ask for confirmation before delete and if confirmed then delete bulk of rules
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " rules?").then(function () {
	                    _this.distributionRules = _.filter(_this.distributionRules, function (row) {
	                        return !_.find(selectedRows, { name: row.name });
	                    });
	                    _this._createDistributionRulesGrid();
	                });
	            }
	        },
	        changeDistribute: {
	            value: function changeDistribute() {
	                if (this.distributionType == false) {
	                    this.repoInfo.basic.productName = null;
	                }
	                /*this.modal.confirm("Artifactory has a set of default rules for " + (this.distributionType ? "product" : "packages") + " distribution.<br/>Would you like to set these rules and <strong>override</strong> existing rules?", this.distributionType ? 'Set Product Distribution Rules' : 'Set Packages Distribution Rules', {confirm: 'Override'})
	                    .then(()=> {
	                        if (this.distributionType == false) {
	                            this.distributionRules = this.distributionDefaultRules;
	                        }
	                        else {
	                            this.distributionRules = this.distributionDefaultProductRules;
	                        }
	                        this._createDistributionRulesGrid();
	                    }).catch(() => {
	                    this.distributionType = !this.distributionType;
	                });*/
	            }
	        },
	        changeDistributeVisibility: {
	            value: function changeDistributeVisibility() {
	                this.repoInfo.basic.defaultNewRepoPrivate = this.defaultNewRepoPrivateSwitch == "Private" ? true : false;
	            }
	        },
	        _createDistributionRulesGrid: {
	            value: function _createDistributionRulesGrid() {

	                if (!this.distributionRules && !this.newRepository) {
	                    this.distributionRules = this.repoInfo.advanced.distributionRules;
	                }

	                _.forEach(this.distributionRules, function (row) {
	                    var rowPackageType = _.find(fieldsValuesDictionary.repoPackageTypes, function (type) {
	                        return type.value == row.type.toLowerCase();
	                    });
	                    if (rowPackageType) {
	                        row.displayType = rowPackageType.text;
	                        row.typeIcon = rowPackageType.icon;
	                    } else row.ignore = true;
	                });
	                var distRepoRulesGridData = _.filter(this.distributionRules, function (row) {
	                    return !row.ignore;
	                });
	                this.rulesGridOptions.setGridData(distRepoRulesGridData);
	            }
	        },
	        _getDistributionRulesColumns: {
	            value: function _getDistributionRulesColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-click=\"grid.appScope.RepositoryForm.editDistributionRule(row.entity)\" id=\"rule-name\">{{row.entity.name}}</a></div>",
	                    width: "85%",
	                    enableSorting: false
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "15%",
	                    enableSorting: false
	                }];
	            }
	        },
	        rulesPopup: {
	            value: function rulesPopup() {
	                this.rulesModalScope = this.$scope.$new();
	                this.rulesModalScope.title = "Add New Rule";
	                this.rulesModalScope.itemToEdit = null;
	                this.rulesModalScope.rule = {};
	                this.availableTokens = null;
	                this.rulesModalScope.repositoryFilterTooltip = this.repositoryFilterTooltip;
	                this.rulesModalScope.pathFilterToolip = this.pathFilterToolip;

	                this.modalRules = this.modal.launchModal("add_rule_modal", this.rulesModalScope, 1000);
	            }
	        },
	        changeRuleRepoType: {
	            value: function changeRuleRepoType() {
	                var selectedPackageValue = this.rulesModalScope.rule.selectedPackageType.value;
	                if (selectedPackageValue == "generic") {
	                    this.rulesModalScope.rule.RulePackageLayoutSelect = null; // Reset selected layout
	                    this.availableTokens = this.ruleTokensByLayout[this.rulesModalScope.rule.selectedPackageType.serverEnumName];
	                } else if (selectedPackageValue == "nuget" || selectedPackageValue == "debian") {
	                    this.rulesModalScope.rule.distributionCoordinatesPackage = "[packageName]";
	                    this.availableTokens = this.ruleTokensByType[this.rulesModalScope.rule.selectedPackageType.serverEnumName];
	                } else {
	                    this.availableTokens = this.ruleTokensByType[this.rulesModalScope.rule.selectedPackageType.serverEnumName];
	                    if (!this.distributionType) {
	                        this.availableTokens = _.filter(this.availableTokens, function (val) {
	                            return val !== "${productName}";
	                        });
	                    }
	                }

	                // Auto fill coordinates from default rules module
	                var coordinates = {};
	                if (selectedPackageValue != "generic") {
	                    coordinates = _.filter(this.distributionDefaultRules, function (o) {
	                        return o.type.toLowerCase() === selectedPackageValue;
	                    });
	                    coordinates = coordinates[0].distributionCoordinates;
	                }
	                this.rulesModalScope.rule.distributionCoordinatesRepo = coordinates.repo || "";
	                this.rulesModalScope.rule.distributionCoordinatesPackage = coordinates.pkg || "";
	                this.rulesModalScope.rule.distributionCoordinatesVersion = coordinates.version || "";
	                this.rulesModalScope.rule.distributionCoordinatesPath = coordinates.path || "";
	            }
	        },
	        changeRulePackageLayout: {
	            value: function changeRulePackageLayout() {
	                this.availableTokens = this.ruleTokensByLayout[this.rulesModalScope.rule.RulePackageLayoutSelect];
	            }
	        },
	        saveDistributionRule: {
	            value: function saveDistributionRule() {
	                var ruleObject = {
	                    name: this.rulesModalScope.rule.ruleName,
	                    type: this.rulesModalScope.rule.selectedPackageType.text,
	                    repoFilter: this.rulesModalScope.rule.filterRepo || "",
	                    pathFilter: this.rulesModalScope.rule.filterPath || "",
	                    distributionCoordinates: {
	                        repo: this.rulesModalScope.rule.distributionCoordinatesRepo || "",
	                        pkg: this.rulesModalScope.rule.distributionCoordinatesPackage || "",
	                        version: this.rulesModalScope.rule.distributionCoordinatesVersion || "",
	                        path: this.rulesModalScope.rule.distributionCoordinatesPath || ""
	                    }
	                };

	                if (this.rulesModalScope.itemToEdit == null) {
	                    this.distributionRules.push(ruleObject);
	                } else {
	                    this.distributionRules[this.rulesModalScope.itemToEdit] = ruleObject;
	                }

	                this._createDistributionRulesGrid();
	                this.modalRules.close();
	            }
	        },
	        editDistributionRule: {
	            value: function editDistributionRule(row) {
	                var selectedPackageType = _.find(fieldsValuesDictionary.repoPackageTypes, function (type) {
	                    return type.value == row.type.toLowerCase();
	                });
	                this.availableTokens = this.ruleTokensByType[row.type];

	                if (!this.distributionType) {
	                    this.availableTokens = _.filter(this.availableTokens, function (val) {
	                        return val !== "${productName}";
	                    });
	                }

	                this.rulesModalScope = this.$scope.$new();
	                this.rulesModalScope.originalRuleName = row.name;
	                this.rulesModalScope.title = "Edit Rule";
	                this.rulesModalScope.itemToEdit = _.indexOf(this.distributionRules, row);
	                this.rulesModalScope.rule = {
	                    ruleName: row.name,
	                    selectedPackageType: selectedPackageType,
	                    filterRepo: row.repoFilter,
	                    filterPath: row.pathFilter,
	                    distributionCoordinatesRepo: row.distributionCoordinates.repo,
	                    distributionCoordinatesPackage: row.distributionCoordinates.pkg,
	                    distributionCoordinatesVersion: row.distributionCoordinates.version,
	                    distributionCoordinatesPath: row.distributionCoordinates.path
	                };

	                this.rulesModalScope.repositoryFilterTooltip = this.repositoryFilterTooltip;
	                this.rulesModalScope.pathFilterToolip = this.pathFilterToolip;

	                this.modalRules = this.modal.launchModal("add_rule_modal", this.rulesModalScope, 1000);
	            }
	        },
	        testRule: {

	            // RULE TEST

	            value: function testRule() {
	                this.repositoriesDao.testDistributionRules({
	                    testPath: this.rulesModalScope.rule.testPath,
	                    productName: this.repoInfo.basic.productName || null,
	                    name: this.rulesModalScope.rule.ruleName,
	                    type: this.rulesModalScope.rule.selectedPackageType.text,
	                    repoFilter: this.rulesModalScope.rule.filterRepo || "",
	                    pathFilter: this.rulesModalScope.rule.filterPath || "",
	                    distributionCoordinates: {
	                        repo: this.rulesModalScope.rule.distributionCoordinatesRepo || "",
	                        pkg: this.rulesModalScope.rule.distributionCoordinatesPackage || "",
	                        version: this.rulesModalScope.rule.distributionCoordinatesVersion || "",
	                        path: this.rulesModalScope.rule.distributionCoordinatesPath || ""
	                    }
	                }).$promise.then(function (result) {});
	            }
	        },
	        changeXrayIndexCheckbox: {

	            // XRAY INTEGRATION

	            value: function changeXrayIndexCheckbox() {
	                if (!this.repoInfo.basic.xrayConfig.enabled) {
	                    this.repoInfo.basic.xrayConfig.blockUnscannedArtifacts = false;
	                    this.repoInfo.basic.xrayConfig.minimumBlockedSeverity = "";
	                }
	            }
	        },
	        changeXrayBlockSeverity: {
	            value: function changeXrayBlockSeverity() {
	                if (!this.repoInfo.basic.xrayConfig.minimumBlockedSeverity || this.repoInfo.basic.xrayConfig.minimumBlockedSeverity === "") {
	                    this.repoInfo.basic.xrayConfig.blockUnscannedArtifacts = false;
	                }
	            }
	        },
	        isProductNameValid: {

	            // VALIDATIONS

	            value: function isProductNameValid(value) {
	                return !value || value.match(/^[a-zA-Z0-9\-_\.:]+$/);
	            }
	        },
	        checkUniqueRuleName: {
	            value: function checkUniqueRuleName(value) {
	                var found = _.find(this.distributionRules, function (o) {
	                    return o.name == value;
	                });
	                return !found || value == this.rulesModalScope.originalRuleName;
	            }
	        },
	        checkReservedName: {
	            value: function checkReservedName(value) {
	                var notAlowedStrings = ["delete", "remove", "edit", "create", "save", "new", "account", "usage", "anonymous", "status", "product", "eula", "packages", "package", "products", "jcenter", "rpm-center", "deb-center", "node-center", "ruby-center", "gems-center", "gems-central", "docker-"];
	                var found = _.includes(notAlowedStrings, value);
	                return !found;
	            }
	        },
	        validateRuleRepoName: {
	            value: function validateRuleRepoName(value) {
	                var regex = /^([A-Za-z0-9.\-_]+)$/;
	                return !value || value.match(regex);
	            }
	        },
	        firstLetterValidation: {
	            value: function firstLetterValidation(value) {
	                var firstLetterRegex = /^[A-Za-z0-9]/; //Allow letters and numbers in first letter
	                return !value || value.charAt(0).match(firstLetterRegex);
	            }
	        },
	        checkLength: {
	            value: function checkLength(value) {
	                var min = arguments[1] === undefined ? 1 : arguments[1];
	                var max = arguments[2] === undefined ? 100 : arguments[2];

	                if (value) {
	                    var result = value.length > max ? false : true;
	                    return result;
	                }
	            }
	        },
	        dockerVagrantValidate: {
	            value: function dockerVagrantValidate(value) {

	                if (value) {
	                    if (this.rulesModalScope.rule.selectedPackageType && (this.rulesModalScope.rule.selectedPackageType.serverEnumName === "Docker" || this.rulesModalScope.rule.selectedPackageType.serverEnumName === "Vagrant")) {
	                        var regex = /^([a-z0-9.\-_]+)$/;
	                        return value.match(regex);
	                    } else {
	                        return true;
	                    }
	                }
	            }
	        }
	    });

	    return AdminRepositoryFormController;
	})();

	//console.log(result);

	//            console.log(result);

	//console.log(result)

	//console.log(result);

/***/ }),
/* 204 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var VirtualRepositoryFormController = exports.VirtualRepositoryFormController = (function () {
	    function VirtualRepositoryFormController($scope, RepositoriesDao, parseUrl, JFrogNotifications, ArtifactoryFeatures) {
	        _classCallCheck(this, VirtualRepositoryFormController);

	        this.$scope = $scope;
	        this.parseUrl = parseUrl;
	        this.gridP2Option = {};
	        this.repositoriesDao = RepositoriesDao;
	        this.notifications = JFrogNotifications;
	        this.artifactoryGridFactory = $scope.RepositoryForm.artifactoryGridFactory;
	        this.repositoryForm = $scope.RepositoryForm;
	        this.virtualRepo = {};
	        this.features = ArtifactoryFeatures;
	        this._createGrid();
	        this._initVirtual();

	        this.repositoryForm.isDependencyRewriteOK = this.isDependencyRewriteOK.bind(this);
	    }

	    _createClass(VirtualRepositoryFormController, {
	        isSigningKeysDisable: {
	            value: function isSigningKeysDisable() {
	                if (this.features.isDisabled("signingKeys")) {
	                    return true;
	                } else {
	                    return false;
	                }
	            }
	        },
	        _initVirtual: {
	            value: function _initVirtual() {
	                var _this = this;

	                if (!this.repositoryForm.newRepository) {
	                    if (this.repositoryForm.repoInfo.typeSpecific && this.repositoryForm.repoInfo.typeSpecific.p2Repos) {
	                        this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	                    }
	                }
	                this.repositoriesDao.remoteUrlToRepoMap().$promise.then(function (result) {
	                    _this.remoteUrlMap = result;
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridP2Option = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getP2Columns()).setRowTemplate("default").setButtons(this._getActions()).setGridData([]);
	            }
	        },
	        addP2Local: {
	            value: function addP2Local() {
	                var repoToPush = {};
	                var baseUrl = "local://";
	                if (this.virtualRepo.pathSuffix) {
	                    repoToPush.pathSuffix = this.virtualRepo.pathSuffix.startsWith("/") ? this.virtualRepo.pathSuffix.replace(/\/+/, "") : this.virtualRepo.pathSuffix;
	                    repoToPush.repoUrl = baseUrl + this.virtualRepo.localRepoKey + "/" + repoToPush.pathSuffix;
	                } else {
	                    repoToPush.repoUrl = baseUrl + this.virtualRepo.localRepoKey;
	                }
	                repoToPush.repoKey = this.virtualRepo.localRepoKey;
	                if (this._repoKeyExists(repoToPush.repoKey)) {
	                    repoToPush.action = "included";
	                } else {
	                    repoToPush.action = "include";
	                }
	                this._pushToGrid(repoToPush);
	            }
	        },
	        _repoKeyExists: {
	            value: function _repoKeyExists(repoKey) {
	                var repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos;
	                if (repos) {
	                    return _.find(repos, { repoKey: repoKey });
	                }
	                return false;
	            }
	        },
	        _repoUrlExists: {
	            value: function _repoUrlExists(repoUrl) {
	                var repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos;
	                if (repos) {
	                    return _.find(repos, { repoUrl: repoUrl });
	                }
	                return false;
	            }
	        },
	        addP2Remote: {
	            value: function addP2Remote() {
	                var _this = this;

	                var indexRepo = 1;
	                var findMatch = false;
	                this.currentRepo = "";
	                _.forOwn(this.remoteUrlMap, function (remoteUrl, key) {
	                    if (_this.virtualRepo.remoteUrl.startsWith(remoteUrl)) {
	                        var action = "include";
	                        if (_this._repoKeyExists(key)) {
	                            action = "included";
	                        }
	                        if (_this._pushToGrid({ repoKey: key, repoUrl: _this.virtualRepo.remoteUrl, action: action })) {
	                            findMatch = true;
	                            return false;
	                        } else {
	                            return true;
	                        }
	                    }
	                });
	                if (!findMatch) {
	                    var fields = this.repositoryForm.fields;
	                    var allRepos = fields.availableLocalRepos.concat(fields.availableRemoteRepos).concat(fields.availableVirtualRepos);
	                    var parser = this.parseUrl(this.virtualRepo.remoteUrl);

	                    this.currentRepo = parser.host.replace(":", "-");

	                    if (_.indexOf(allRepos, this.currentRepo) != -1) {
	                        (function () {
	                            var regexp = new RegExp(_this.currentRepo + "-.+");
	                            var matchingRepos = _.select(allRepos, function (repo) {
	                                return regexp.test(repo);
	                            });
	                            if (matchingRepos.length) {
	                                var lastMatchingRepo = _.last(matchingRepos.sort());
	                                indexRepo = lastMatchingRepo.substring(lastMatchingRepo.indexOf("-") + 1);
	                                indexRepo = parseInt(indexRepo) + 1;
	                            }
	                            _this.currentRepo = _this.currentRepo + "-" + indexRepo;
	                        })();
	                    }

	                    this.remoteUrlMap[this.currentRepo] = this.virtualRepo.remoteUrl;
	                    this._pushToGrid({ repoKey: this.currentRepo, repoUrl: this.virtualRepo.remoteUrl, action: "create" });
	                }
	            }
	        },
	        onChangeRepo: {
	            value: function onChangeRepo() {
	                var _this = this;

	                this.repositoriesDao.getResolvedRepositories(this.repositoryForm.repoInfo).$promise.then(function (resolvedRepositories) {
	                    _this.repositoryForm.repoInfo.basic.resolvedRepositories = resolvedRepositories;
	                    _this.repositoryForm.repoInfo.basic.selectedLocalRepositories = _.pluck(_.filter(_this.repositoryForm.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "local";
	                    }), "repoName");
	                    _this.repositoryForm.repoInfo.basic.selectedRemoteRepositories = _.pluck(_.filter(_this.repositoryForm.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "remote";
	                    }), "repoName");
	                    if (!_.contains(_this.repositoryForm.repoInfo.basic.selectedLocalRepositories, _this.repositoryForm.repoInfo.basic.defaultDeploymentRepo)) {
	                        _this.repositoryForm.repoInfo.basic.defaultDeploymentRepo = null;
	                    }
	                    _this.repositoryForm.repoInfo.basic.selectedLocalRepositories.unshift("");
	                });
	            }
	        },
	        _pushToGrid: {
	            value: function _pushToGrid(repo) {
	                if (this._repoUrlExists(repo.repoUrl)) {
	                    this.notifications.create({ error: "Repo URL already exists in the list" });
	                    return false;
	                }
	                this.repositoryForm.repoInfo.typeSpecific.p2Repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos || [];
	                this.repositoryForm.repoInfo.typeSpecific.p2Repos.push(repo);
	                this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	                this.virtualRepo.remoteUrl = "";
	                return true;
	            }
	        },
	        _deleteRepo: {
	            value: function _deleteRepo(repo) {
	                _.remove(this.repositoryForm.repoInfo.typeSpecific.p2Repos, { repoUrl: repo.repoUrl });
	                this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	            }
	        },
	        isDependencyRewriteRelevant: {
	            value: function isDependencyRewriteRelevant() {
	                return this.repositoryForm.repoInfo.typeSpecific && (this.repositoryForm.repoInfo.typeSpecific.repoType === "Bower" || this.repositoryForm.repoInfo.typeSpecific.repoType === "Npm");
	            }
	        },
	        addDependencyRewritePattern: {
	            value: function addDependencyRewritePattern() {
	                this.newValue = $("#newPatternField").val();
	                this.errorMessage = null;

	                if (_.isEmpty(this.newValue)) {
	                    this.errorMessage = "Must input value";
	                }
	                //else if (!this._isValueUnique(this.newValue)) {
	                //    this.errorMessage = "Value already exists";
	                //}
	                else {
	                    this.repositoryForm.repoInfo.typeSpecific.externalPatterns.push(this.newValue);
	                    this.newValue = null;
	                    $("#newPatternField").val("");
	                    //this.invalidateType();
	                }
	            }
	        },
	        removeDependencyRewritePattern: {
	            value: function removeDependencyRewritePattern(index) {
	                this.repositoryForm.repoInfo.typeSpecific.externalPatterns.splice(index, 1);
	            }
	        },
	        onDependencyRewriteEnableChange: {
	            value: function onDependencyRewriteEnableChange() {
	                if (this.repositoryForm.repoInfo.typeSpecific.enableExternalDependencies) {
	                    if (!this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo && this.repositoryForm.repoInfo.basic.selectedRemoteRepositories) {
	                        this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo = this.repositoryForm.repoInfo.basic.selectedRemoteRepositories[0];
	                    }
	                    if (!this.repositoryForm.repoInfo.typeSpecific.externalPatterns) {
	                        this.repositoryForm.repoInfo.typeSpecific.externalPatterns = ["**"];
	                    }
	                }
	            }
	        },
	        isDependencyRewriteOK: {
	            value: function isDependencyRewriteOK() {
	                return !this.repositoryForm.repoInfo.typeSpecific.enableExternalDependencies || this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo;
	            }
	        },
	        getP2Columns: {
	            value: function getP2Columns() {
	                return [{
	                    name: "Action",
	                    displayName: "Action",
	                    field: "action",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.action || \"included\" }}</div>"
	                }, {
	                    name: "Repository",
	                    displayName: "Repository",
	                    field: "repoKey",
	                    enableCellEdit: "{{row.entity.action === 'create'}}"

	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "repoUrl",
	                    enableCellEdit: true
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (repo) {
	                        _this._deleteRepo(repo);
	                    }
	                }];
	            }
	        }
	    });

	    return VirtualRepositoryFormController;
	})();

/***/ }),
/* 205 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminRepositoriesLayoutController = exports.AdminRepositoriesLayoutController = (function () {
	    function AdminRepositoriesLayoutController($scope, $state, JFrogGridFactory, RepositoriesLayoutsDao, uiGridConstants, ArtifactoryFeatures, JFrogModal) {
	        _classCallCheck(this, AdminRepositoriesLayoutController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.layoutsDao = RepositoriesLayoutsDao;
	        this.gridOptions = {};
	        this.modal = JFrogModal;
	        this.uiGridConstants = uiGridConstants;
	        this.enableNew = ArtifactoryFeatures.getCurrentLicense() !== "OSS";

	        this._createGrid();
	        this._getLayouts();
	    }

	    _createClass(AdminRepositoriesLayoutController, {
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setSingleSelect().setButtons(this.getActions()).setRowTemplate("default");
	            }
	        },
	        _getLayouts: {
	            value: function _getLayouts() {
	                var _this = this;

	                this.layoutsDao.getLayouts().$promise.then(function (data) {
	                    _this.gridOptions.setGridData(data);
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC

	                    },
	                    name: "Name",
	                    displayName: "Name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"layout-name\" ui-sref=\"^.repo_layouts.edit({layoutname: row.entity.name,viewOnly: !row.entity.layoutActions.edit})\" ><a href=\"\">{{row.entity.name}}</a></div>",
	                    width: "15%"
	                }, {
	                    field: "artifactPathPattern",
	                    name: "Artifact Path Pattern",
	                    displayName: "Artifact Path Pattern",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"artifact-pattern\">{{row.entity.artifactPathPattern}}</div>",
	                    width: "85%"
	                }];
	            }
	        },
	        copyLayout: {
	            value: function copyLayout(row) {
	                this.$state.go("^.repo_layouts.new", { copyFrom: row.name });
	            }
	        },
	        deleteLayout: {
	            value: function deleteLayout(row) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete layout '" + row.name + "?'").then(function () {
	                    _this.layoutsDao.deleteLayout({}, { layoutName: row.name }).$promise.then(function (data) {
	                        _this._getLayouts();
	                    });
	                });
	            }
	        },
	        getActions: {
	            value: function getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-copy",
	                    tooltip: "Duplicate",
	                    callback: function (row) {
	                        return _this.copyLayout(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.layoutActions.copy;
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLayout(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.layoutActions["delete"];
	                    }
	                }];
	            }
	        }
	    });

	    return AdminRepositoriesLayoutController;
	})();

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminRepositoryLayoutFormController = exports.AdminRepositoryLayoutFormController = (function () {
	    function AdminRepositoryLayoutFormController($state, $stateParams, RepositoriesLayoutsDao, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminRepositoryLayoutFormController);

	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.layoutsDao = RepositoriesLayoutsDao;
	        this.TOOLTIP = TOOLTIP.admin.repositories.layoutsForm;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["layoutData"]);

	        this.input = {};
	        this.testReply = null;
	        this.regexViewData = null;

	        this.testReplyDictionary = {
	            organization: "Organization",
	            module: "Module",
	            baseRevision: "Base Revision",
	            folderIntegrationRevision: "Folder Integration Revision",
	            fileIntegrationRevision: "File Integration Revision",
	            classifier: "Classifier",
	            ext: "Extension",
	            type: "Type"
	        };

	        this.viewOnly = $stateParams.viewOnly === true;

	        if ($stateParams.layoutname) {
	            this.mode = "edit";
	            this.layoutName = $stateParams.layoutname;
	            this.title = "Edit " + this.layoutName + " Repository Layout";
	            this._getLayoutData(this.layoutName);
	        } else if ($stateParams.copyFrom) {
	            this.mode = "create";
	            this.title = "New Repository Layout";
	            this._getLayoutData($stateParams.copyFrom);
	        } else {
	            this.mode = "create";
	            this.title = "New Repository Layout";
	            this.layoutData = {};
	        }
	    }

	    _createClass(AdminRepositoryLayoutFormController, {
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	                if (this.mode == "edit") {
	                    var payload = angular.copy(this.layoutData);
	                    delete payload.repositoryAssociations;

	                    this.layoutsDao.update({}, payload).$promise.then(function (data) {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.repo_layouts");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }

	                if (this.mode == "create") {
	                    this.layoutsDao.save({}, this.layoutData).$promise.then(function (data) {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.repo_layouts");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        hasAnyAssoc: {
	            value: function hasAnyAssoc() {
	                return this.layoutData && (this.layoutData.repositoryAssociations.localRepositories.length || this.layoutData.repositoryAssociations.remoteRepositories.length || this.layoutData.repositoryAssociations.virtualRepositories.length);
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.repo_layouts");
	            }
	        },
	        test: {
	            value: function test() {
	                var _this = this;

	                var payload = angular.copy(this.layoutData);
	                delete payload.repositoryAssociations;
	                _.extend(payload, { pathToTest: this.input.testPath });
	                this.testReply = null;

	                this.layoutsDao.testArtifactPath({}, payload).$promise.then(function (data) {
	                    _this.testReply = data.data;
	                });
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.layoutForm || this.layoutForm.$invalid;
	            }
	        },
	        resolveRegex: {
	            value: function resolveRegex() {
	                var _this = this;

	                var payload = angular.copy(this.layoutData);
	                delete payload.repositoryAssociations;
	                this.regexViewData = null;
	                this.layoutsDao.resolveRegex({}, payload).$promise.then(function (data) {
	                    _this.regexViewData = data;
	                });
	            }
	        },
	        gotoEditRepo: {
	            value: function gotoEditRepo(type, repo) {
	                this.$state.go("admin.repositories.edit", { repoType: type, repoKey: repo });
	            }
	        },
	        _getLayoutData: {
	            value: function _getLayoutData(layoutName) {
	                var _this = this;

	                this.layoutsDao.getLayoutData({}, { layoutName: layoutName }).$promise.then(function (data) {
	                    _this.layoutData = data;
	                    _this.ArtifactoryModelSaver.save();
	                    if (_this.$stateParams.copyFrom) {
	                        _this.layoutData.name = "";
	                    }
	                });
	            }
	        }
	    });

	    return AdminRepositoryLayoutFormController;
	})();

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var ConfigDescriptor = _interopRequire(__webpack_require__(208));

	var Maintenance = _interopRequire(__webpack_require__(210));

	var SecurityDescriptor = _interopRequire(__webpack_require__(212));

	var StorageSummary = _interopRequire(__webpack_require__(214));

	var SystemInfo = _interopRequire(__webpack_require__(216));

	var SystemLogs = _interopRequire(__webpack_require__(218));

	var SupportPage = _interopRequire(__webpack_require__(220));

	var LogAnalytics = _interopRequire(__webpack_require__(222));

	var AdminAdvancedController = __webpack_require__(224).AdminAdvancedController;

	function advancedConfig($stateProvider) {
	    $stateProvider.state("admin.advanced", {
	        url: "/advanced",
	        template: "<ui-view></ui-view>",
	        controller: "AdminAdvancedController as AdminAdvanced"
	    });
	}

	module.exports = angular.module("admin.advanced", [ConfigDescriptor.name, Maintenance.name, SecurityDescriptor.name, StorageSummary.name, SystemInfo.name, SystemLogs.name, SupportPage.name, LogAnalytics.name]).config(advancedConfig).controller("AdminAdvancedController", AdminAdvancedController);

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedConfigDescriptorController = __webpack_require__(209).AdminAdvancedConfigDescriptorController;

	function configDescriptorConfig($stateProvider) {

	    $stateProvider.state("admin.advanced.config_descriptor", {
	        params: { feature: "configDescriptor" },
	        url: "/config_descriptor",
	        templateUrl: "states/admin/advanced/config_descriptor/config_descriptor.html",
	        controller: "AdminAdvancedConfigDescriptorController as ConfigDescriptorController"
	    });
	}

	module.exports = angular.module("advanced.config_descriptor", []).config(configDescriptorConfig).controller("AdminAdvancedConfigDescriptorController", AdminAdvancedConfigDescriptorController);

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AdminAdvancedConfigDescriptorController = exports.AdminAdvancedConfigDescriptorController = (function () {
	    function AdminAdvancedConfigDescriptorController($scope, $timeout, ArtifactoryHttpClient, JFrogNotifications, RESOURCE, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminAdvancedConfigDescriptorController);

	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.RESOURCE = RESOURCE;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.artifactoryHttpClient = ArtifactoryHttpClient;
	        this.configDescriptor = "";
	        this.apiAccess = {};
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["configDescriptor"]);
	        this.JFrogEventBus = JFrogEventBus;

	        this._getData();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this._getData();
	        });
	    }

	    _createClass(AdminAdvancedConfigDescriptorController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                this.artifactoryHttpClient.get(this.RESOURCE.CONFIG_DESCRIPTOR).then(function (response) {
	                    _this.configDescriptor = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$timeout(function () {
	                        _this.apiAccess.api.clearHistory();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save(configXml) {
	                var _this = this;

	                this.artifactoryHttpClient.put(this.RESOURCE.CONFIG_DESCRIPTOR, { configXml: configXml }).success(function (response) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.artifactoryNotifications.create(response);
	                }).error(function (response) {
	                    if (response.errors && response.errors.length) {
	                        _this.artifactoryNotifications.create(angular.fromJson(response.errors[0].message));
	                    }
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._getData();
	                });
	            }
	        }
	    });

	    return AdminAdvancedConfigDescriptorController;
	})();

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedMaintenanceController = __webpack_require__(211).AdminAdvancedMaintenanceController;

	function maintenanceConfig($stateProvider) {

	    $stateProvider.state("admin.advanced.maintenance", {
	        params: { feature: "maintenance" },
	        url: "/maintenance",
	        templateUrl: "states/admin/advanced/maintenance/maintenance.html",
	        controller: "AdminAdvancedMaintenanceController as Maintenance"
	    });
	}

	module.exports = angular.module("advanced.maintenance", []).config(maintenanceConfig).controller("AdminAdvancedMaintenanceController", AdminAdvancedMaintenanceController);

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminAdvancedMaintenanceController = exports.AdminAdvancedMaintenanceController = (function () {
	    function AdminAdvancedMaintenanceController(MaintenanceDao, JFrogNotifications, JFrogEventBus, JFrogModal, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminAdvancedMaintenanceController);

	        this.maintenanceDao = MaintenanceDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryModal = JFrogModal;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["maintenanceSettings"]);
	        this.maintenanceSettings = {};
	        this.TOOLTIP = TOOLTIP.admin.advanced.maintenance;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this._getData();
	    }

	    _createClass(AdminAdvancedMaintenanceController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                this.maintenanceDao.get().$promise.then(function (data) {
	                    _this.backupMaintance = angular.copy(data);
	                    _this.maintenanceSettings.cleanUnusedCachedCron = data.cleanUnusedCachedCron;
	                    _this.maintenanceSettings.cleanVirtualRepoCron = data.cleanVirtualRepoCron;
	                    _this.maintenanceSettings.garbageCollectorCron = data.garbageCollectorCron;
	                    _this.maintenanceSettings.quotaControl = data.quotaControl;
	                    _this.maintenanceSettings.storageLimit = data.storageLimit;
	                    _this.maintenanceSettings.storageWarning = data.storageWarning;
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.maintenanceForm.$valid) {
	                    this.maintenanceDao.update(this.maintenanceSettings).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        clear: {
	            value: function clear() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                    _this._getData();
	                });
	            }
	        },
	        resetQuotaFields: {
	            value: function resetQuotaFields() {
	                if (!this.maintenanceSettings.quotaControl) {
	                    this.maintenanceSettings.storageLimit = this.backupMaintance.storageLimit;
	                    this.maintenanceSettings.storageWarning = this.backupMaintance.storageWarning;
	                }
	            }
	        },
	        _runAction: {
	            value: function _runAction(name) {
	                this.maintenanceDao.perform({ module: name });
	            }
	        },
	        runGarbageCollection: {
	            value: function runGarbageCollection() {
	                this._runAction("garbageCollection");
	            }
	        },
	        runUnusedCachedArtifactsCleanup: {
	            value: function runUnusedCachedArtifactsCleanup() {
	                this._runAction("cleanUnusedCache");
	            }
	        },
	        compressInternalDatabase: {
	            value: function compressInternalDatabase() {
	                var _this = this;

	                this.artifactoryModal.confirm("Are you sure you want to compress the internal database?").then(function () {
	                    return _this._runAction("compress");
	                });
	            }
	        },
	        pruneUnreferencedData: {
	            value: function pruneUnreferencedData() {
	                this._runAction("prune");
	            }
	        },
	        cleanVirtualRepositories: {
	            value: function cleanVirtualRepositories() {
	                this._runAction("cleanVirtualRepo");
	            }
	        }
	    });

	    return AdminAdvancedMaintenanceController;
	})();

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedSecurityDescriptorController = __webpack_require__(213).AdminAdvancedSecurityDescriptorController;

	function securityDescriptorConfig($stateProvider) {

	    $stateProvider.state("admin.advanced.security_descriptor", {
	        params: { feature: "securityDescriptor" },
	        url: "/security_descriptor",
	        templateUrl: "states/admin/advanced/security_descriptor/security_descriptor.html",
	        controller: "AdminAdvancedSecurityDescriptorController as SecurityDescriptorController"
	    });
	}

	module.exports = angular.module("advanced.security_descriptor", []).config(securityDescriptorConfig).controller("AdminAdvancedSecurityDescriptorController", AdminAdvancedSecurityDescriptorController);

/***/ }),
/* 213 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminAdvancedSecurityDescriptorController = exports.AdminAdvancedSecurityDescriptorController = (function () {
	    function AdminAdvancedSecurityDescriptorController($timeout, ArtifactoryHttpClient, JFrogNotifications, RESOURCE, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminAdvancedSecurityDescriptorController);

	        this.artifactoryHttpClient = ArtifactoryHttpClient;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.RESOURCE = RESOURCE;
	        this.$timeout = $timeout;
	        this.securityDescriptor = "";
	        this.apiAccess = {};
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["securityDescriptor"]);

	        this._getData();
	    }

	    _createClass(AdminAdvancedSecurityDescriptorController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                this.artifactoryHttpClient.get(this.RESOURCE.SECURITY_DESCRIPTOR).then(function (response) {
	                    _this.securityDescriptor = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$timeout(function () {
	                        _this.apiAccess.api.clearHistory();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save(securityXML) {
	                var _this = this;

	                this.artifactoryHttpClient.put(this.RESOURCE.SECURITY_DESCRIPTOR, { securityXML: securityXML }).success(function (response) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.artifactoryNotifications.create(response);
	                }).error(function (response) {
	                    if (response.errors && response.errors.length) {
	                        _this.artifactoryNotifications.create(angular.fromJson(response.errors[0].message));
	                    }
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._getData();
	                });
	            }
	        }
	    });

	    return AdminAdvancedSecurityDescriptorController;
	})();

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedStorageSummaryController = __webpack_require__(215).AdminAdvancedStorageSummaryController;

	function storageSummaryConfig($stateProvider) {

	    $stateProvider.state("admin.advanced.storage_summary", {
	        url: "/storage_summary",
	        templateUrl: "states/admin/advanced/storage_summary/storage_summary.html",
	        controller: "AdminAdvancedStorageSummaryController as StorageSummaryController"
	    });
	}

	module.exports = angular.module("advanced.storage_summary", []).config(storageSummaryConfig).controller("AdminAdvancedStorageSummaryController", AdminAdvancedStorageSummaryController);

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var FIELD_OPTIONS = _interopRequire(__webpack_require__(163));

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AdminAdvancedStorageSummaryController = exports.AdminAdvancedStorageSummaryController = (function () {
	    function AdminAdvancedStorageSummaryController($scope, $timeout, StorageSummaryDao, JFrogGridFactory, uiGridConstants, commonGridColumns, $compile, ArtifactoryFeatures, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminAdvancedStorageSummaryController);

	        this.$scope = $scope;
	        this.$compile = $compile;
	        this.$timeout = $timeout;
	        this.commonGridColumns = commonGridColumns;
	        this.storageSummary = {};
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.storageSummaryDao = StorageSummaryDao.getInstance();
	        this.features = ArtifactoryFeatures;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.TOOLTIP = TOOLTIP.admin.advanced.storageSummary;
	        this.counterTooltip = "List includes all Local and Virtual repositories, and Remote repositories configured to store artifacts locally.";
	        this.binariesKeys = ["binariesSize", "binariesCount", "artifactsSize", "artifactsCount", "optimization", "itemsCount"];
	        this.JFrogEventBus = JFrogEventBus;

	        this.getGridPopulatedWithData();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getGridPopulatedWithData();
	        });
	    }

	    _createClass(AdminAdvancedStorageSummaryController, {
	        getGridPopulatedWithData: {
	            value: function getGridPopulatedWithData() {
	                var _this = this;

	                this.storageSummaryDao.get().$promise.then(function (result) {
	                    _this.storageSummary = result;
	                    // Creates a repository array by running each repo element in the list through the arrow function
	                    _this.storageSummary.repositoriesSummaryList = _.map(_this.storageSummary.repositoriesSummaryList, function (row) {
	                        return _this.setRowTemplate(row);
	                    });

	                    _this.getStorageTableSummaryData();

	                    // If grid does not exists - create it , else refresh the grid data
	                    if (!_this.gridOption.data) {
	                        _this.createGrid();
	                    } else {
	                        _this.gridOption.setGridData(_this.storageSummary.repositoriesSummaryList);
	                    }
	                });
	            }
	        },
	        setRowTemplate: {
	            value: function setRowTemplate(row) {

	                row = this.getStorageTableSummaryTamplate(row);

	                row = this.getDataColumns(row);

	                row = this.getPackageTypeColumn(row);

	                return row;
	            }
	        },
	        getDataColumns: {
	            value: function getDataColumns(row) {
	                var _this = this;

	                var repoKey = row.repoKey;
	                for (var key in row) {
	                    if (key !== "__doNotCount__" && key !== "percentageDisplay") {
	                        row[key] = { value: row[key], repoKey: repoKey, getCtrl: function () {
	                                return _this;
	                            } };
	                    }
	                }
	                return row;
	            }
	        },
	        getPackageTypeColumn: {
	            value: function getPackageTypeColumn(row) {
	                var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                    return type.serverEnumName == row.packageType.value || type.serverEnumName == "YUM" && row.packageType.value == "RPM";
	                    // The REST for storage has changed and now returns RPM, while other RESTs returns YUM
	                });

	                if (rowPackageType) {
	                    row.typeIcon = rowPackageType.icon;
	                    // set the correct package name (from FIELD_OPTIONS constants)
	                    row.packageType.value = rowPackageType.text;
	                }

	                if (row.packageType.value === "Trash") {
	                    row.typeIcon = "trash";
	                }

	                if (row.packageType.value === "Distribution") {
	                    row.typeIcon = "distribution-repo";
	                }

	                return row;
	            }
	        },
	        getStorageTableSummaryTamplate: {
	            value: function getStorageTableSummaryTamplate(row, repoKey) {
	                if (repoKey === "TOTAL") {
	                    row.percentage = 100;
	                    row.percentageDisplay = "100%";
	                } else {
	                    row.percentage = !_.isNaN(parseFloat(row.percentage)) ? parseFloat(row.percentage) : row.percentage;
	                    row.percentageDisplay = _.isNumber(row.percentage) ? row.percentage + "%" : "N/A";
	                }

	                if (row.repoType === "NA") row.repoType = "N/A";
	                if (row.packageType === "NA") row.packageType = "N/A";

	                if (row.repoKey === "TOTAL" || row.repoKey === "auto-trashcan") {
	                    row.__doNotCount__ = true;
	                    row.packageType = "N/A";
	                    row._specialRow = true;
	                }

	                if (row.repoKey === "auto-trashcan") {
	                    row.trashcan = true;
	                    row.packageType = "Trash";
	                    row.repoKey = "Trash Can";
	                }

	                return row;
	            }
	        },
	        getStorageTableSummaryData: {
	            value: function getStorageTableSummaryData() {
	                //This is for assuring that even without sorting, total will always be first and trash will be second
	                var total = _.findWhere(this.storageSummary.repositoriesSummaryList, { repoKey: { value: "TOTAL" } });
	                var trash = _.findWhere(this.storageSummary.repositoriesSummaryList, { repoKey: { value: "Trash Can" } });
	                var totalIndex = this.storageSummary.repositoriesSummaryList.indexOf(total);
	                var trashIndex = this.storageSummary.repositoriesSummaryList.indexOf(trash);
	                this.storageSummary.repositoriesSummaryList.splice(totalIndex, 1);
	                this.storageSummary.repositoriesSummaryList.splice(trashIndex, 1);
	                this.storageSummary.repositoriesSummaryList.unshift(trash);
	                this.storageSummary.repositoriesSummaryList.unshift(total);

	                if (this.storageSummary.fileStoreSummary && this.storageSummary.fileStoreSummary.storageDirectory.indexOf(", ") != -1) {
	                    this.storageSummary.fileStoreSummary.storageDirectory = "<div class=\"storage-multiple-mounts\">" + this.storageSummary.fileStoreSummary.storageDirectory.replace(/, /g, "<br>") + "</div>";
	                    this.storageSummary.fileStoreSummary.storageType = "Advanced Configuration";
	                }
	            }
	        },
	        createGrid: {
	            value: function createGrid() {
	                var _this = this;

	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setGridData(this.storageSummary.repositoriesSummaryList).setRowTemplate("default");

	                this.gridOption.afterRegister(function (gridApi) {
	                    gridApi.pagination.on.paginationChanged(_this.$scope, function (pageNumber, pageSize) {
	                        var specialsToRemove = $(".ui-grid-row.special-row");
	                        specialsToRemove.removeClass("special-row");
	                        _this.$timeout(function () {
	                            var specials = $(".special-row");
	                            specials.parent().parent().addClass("special-row");
	                            specials.removeClass("special-row");
	                        }, 100);
	                    });
	                });

	                this.$timeout(function () {
	                    var counterElem = $(".grid-counter");
	                    var tooltipElem = $("<jf-help-tooltip html=\"StorageSummaryController.counterTooltip\"></jf-help-tooltip>");
	                    counterElem.append(tooltipElem);
	                    _this.$compile(tooltipElem)(_this.$scope);

	                    var specials = $(".special-row");
	                    specials.parent().parent().addClass("special-row");
	                    specials.removeClass("special-row");
	                });
	            }
	        },
	        sortGeneral: {
	            value: function sortGeneral(a, b, column) {
	                var dir = "asc";
	                var ctrl = a.getCtrl();
	                if (column) {
	                    dir = _.findWhere(ctrl.gridOption.api.grid.columns, { field: column }).sort.direction;
	                }
	                if (a.repoKey === "TOTAL") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "TOTAL") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Trash Can") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Trash Can") {
	                    return dir === "desc" ? -1 : 1;
	                } else {
	                    return a.value > b.value ? 1 : a.value < b.value ? -1 : 0;
	                }
	            }
	        },
	        sortByteSizes: {
	            value: function sortByteSizes(a, b, column) {
	                var dir = "asc";
	                var ctrl = a.getCtrl();

	                if (column) {
	                    dir = _.findWhere(ctrl.gridOption.api.grid.columns, { field: column }).sort.direction;
	                }

	                var res = 0;
	                if (a === undefined || b === undefined) {
	                    return res;
	                }if (a.repoKey === "TOTAL") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "TOTAL") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Trash Can") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Trash Can") {
	                    return dir === "desc" ? -1 : 1;
	                } else {
	                    var tb = [a.value.match("TB"), b.value.match("TB")],
	                        gb = [a.value.match("GB"), b.value.match("GB")],
	                        mb = [a.value.match("MB"), b.value.match("MB")],
	                        kb = [a.value.match("KB"), b.value.match("KB")];

	                    res = tb[0] && !tb[1] ? 1 : tb[1] && !tb[0] ? -1 : gb[0] && !gb[1] ? 1 : gb[1] && !gb[0] ? -1 : mb[0] && !mb[1] ? 1 : mb[1] && !mb[0] ? -1 : kb[0] && !kb[1] ? 1 : kb[1] && !kb[0] ? -1 : parseFloat(a.value.match(/[+-]?\d+(\.\d+)?/)[0]) > parseFloat(b.value.match(/[+-]?\d+(\.\d+)?/)[0]) ? 1 : -1;
	                }

	                return res;
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                var _this = this;

	                return [{
	                    field: "repoKey",
	                    name: "Repository Key",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "repoKey");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repoKey\">{{row.entity.repoKey.value}}</div>",
	                    displayName: "Repository Key"
	                }, {
	                    field: "repoType",
	                    name: "Repository Type",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "repoType");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repoType\">{{row.entity.repoType.value}}</div>",
	                    displayName: "Repository Type"
	                }, {
	                    field: "packageType",
	                    name: "Package Type",
	                    displayName: "Package Type",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "packageType");
	                    },
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.packageType.value", "row.entity.typeIcon", "repo-type-icon")
	                }, {
	                    field: "percentage",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" id=\"storage-precentage\" >{{row.entity.percentageDisplay}}</div>",
	                    name: "Percentage",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "percentage");
	                    },
	                    displayName: "Percentage"
	                }, {
	                    field: "usedSpace",
	                    name: "Used Space",
	                    displayName: "Artifacts Size",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" id=\"used-space\" >{{row.entity.usedSpace.value}}</div>",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortByteSizes(a, b, "usedSpace");
	                    },
	                    sort: {
	                        direction: this.uiGridConstants.DESC
	                    }
	                }, {
	                    field: "filesCount",
	                    name: "Files",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "filesCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"files\" >  {{row.entity.filesCount.value}}</div>",
	                    displayName: "Files"
	                }, {
	                    field: "foldersCount",
	                    name: "Folders",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "foldersCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"folders\" >{{row.entity.foldersCount.value}}</div>",
	                    displayName: "Folders"
	                }, {
	                    field: "itemsCount",
	                    name: "Items",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "itemsCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"items\" >{{row.entity.itemsCount.value}}</div>",
	                    displayName: "Items"
	                }];
	            }
	        }
	    });

	    return AdminAdvancedStorageSummaryController;
	})();

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedSystemInfoController = __webpack_require__(217).AdminAdvancedSystemInfoController;

	function systemInfoConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.system_info", {
	        params: { feature: "systemInfo" },
	        url: "/system_info",
	        templateUrl: "states/admin/advanced/system_info/system_info.html",
	        controller: "AdminAdvancedSystemInfoController as SystemInfoController"
	    });
	}

	module.exports = angular.module("advanced.system_info", []).config(systemInfoConfig).controller("AdminAdvancedSystemInfoController", AdminAdvancedSystemInfoController);

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminAdvancedSystemInfoController = exports.AdminAdvancedSystemInfoController = (function () {
	    function AdminAdvancedSystemInfoController(SystemInfoDao) {
	        _classCallCheck(this, AdminAdvancedSystemInfoController);

	        // console.log("log: "+SystemInfoDao);
	        this.systemInfoDao = SystemInfoDao.getInstance();
	        var self = this;
	        this.systemInfo;
	        this.systemInfoJoined;
	        this.systemInfoDao.get().$promise.then(function (data) {
	            self.getSystemInfoKeys(data);
	        });
	    }

	    _createClass(AdminAdvancedSystemInfoController, {
	        getSystemInfoKeys: {
	            value: function getSystemInfoKeys(data) {
	                this.systemInfo = data.systemInfo;
	                this.systemInfoJoined = JSON.stringify(data.systemInfo);
	                //let headers = Object.keys(systemInfo);
	                //let subTitles = [];
	            }
	        },
	        replaceNewLines: {
	            value: function replaceNewLines(text) {
	                return text.replace(/\n/g, "<br>");
	            }
	        }
	    });

	    return AdminAdvancedSystemInfoController;
	})();

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedSystemLogsController = __webpack_require__(219).AdminAdvancedSystemLogsController;

	function systemLogsConifg($stateProvider) {

	    $stateProvider.state("admin.advanced.system_logs", {
	        url: "/system_logs",
	        templateUrl: "states/admin/advanced/system_logs/system_logs.html",
	        controller: "AdminAdvancedSystemLogsController as SystemLogsController"
	    });
	}

	module.exports = angular.module("advanced.system_logs", []).config(systemLogsConifg).controller("AdminAdvancedSystemLogsController", AdminAdvancedSystemLogsController);

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var API = _interopRequire(__webpack_require__(88));

	var AdminAdvancedSystemLogsController = exports.AdminAdvancedSystemLogsController = (function () {
	    function AdminAdvancedSystemLogsController($scope, SystemLogsDao, $interval, $window, $timeout) {
	        var _this = this;

	        _classCallCheck(this, AdminAdvancedSystemLogsController);

	        this.logsDao = SystemLogsDao;
	        this.$interval = $interval;
	        this.$window = $window;
	        this.$timeout = $timeout;

	        this.intervalPromise = null;
	        this.timeoutSpinner = null;
	        this.timeCount = 5;

	        this._getInitialData();

	        $scope.$on("$destroy", function () {
	            _this.stopTimeout();
	            _this.stopInterval();
	        });
	    }

	    _createClass(AdminAdvancedSystemLogsController, {
	        _getInitialData: {
	            value: function _getInitialData() {
	                var _this = this;

	                this.logsDao.getLogs().$promise.then(function (data) {
	                    _this.refreshRateSecs = data.refreshRateSecs;
	                    _this.logs = _.map(data.logs, function (logName) {
	                        return { logName: logName };
	                    });
	                    _this.selectedLog = _this.logs[0].logName;
	                    _this.data = { fileSize: 0 };
	                    _this._getLogData();
	                });
	            }
	        },
	        _getLogData: {
	            value: function _getLogData() {
	                var _this = this;

	                this.stopInterval();

	                this.logsDao.getLogData({ id: this.selectedLog, fileSize: this.data.fileSize, $no_spinner: true }).$promise.then(function (data) {
	                    _this.stopTimeout();

	                    if (_this.data.fileSize === 0) {
	                        _this.$timeout(function () {
	                            var textarea = document.getElementById("textarea");
	                            textarea.scrollTop = textarea.scrollHeight;
	                        });
	                    }

	                    if (data.fileSize) _this.data = data;

	                    _this.timeCount = _this.refreshRateSecs;
	                    if (!_this.intervalPromise && !_this.paused) _this.startInterval();
	                });

	                this.timeoutSpinner = this.$timeout(function () {
	                    _this.timeCount--;
	                }, 400);
	            }
	        },
	        download: {
	            value: function download() {
	                this.$window.open("" + API.API_URL + "/systemlogs/downloadFile?id=" + this.selectedLog, "_blank");
	            }
	        },
	        onChangeLog: {
	            value: function onChangeLog() {
	                this.stopInterval();
	                this.data = { fileSize: 0 };
	                this._getLogData();
	            }
	        },
	        startInterval: {
	            value: function startInterval() {
	                var _this = this;

	                this.intervalPromise = this.$interval(function () {
	                    if (_this.timeCount == 0) _this._getLogData();else _this.timeCount--;
	                }, 1000);
	            }
	        },
	        stopInterval: {
	            value: function stopInterval() {
	                if (this.intervalPromise) {
	                    this.$interval.cancel(this.intervalPromise);
	                    this.intervalPromise = null;
	                }
	            }
	        },
	        stopTimeout: {
	            value: function stopTimeout() {
	                if (this.timeoutSpinner) {
	                    this.$timeout.cancel(this.timeoutSpinner);
	                    this.timeoutSpinner = null;
	                }
	            }
	        },
	        togglePause: {
	            value: function togglePause() {
	                this.paused = !this.paused;
	                if (this.paused) {
	                    this.stopInterval();
	                    this.stopTimeout();
	                } else {
	                    this.startInterval();
	                }
	            }
	        },
	        getPauseLinkText: {
	            value: function getPauseLinkText() {
	                return this.paused ? "(Resume)" : "(Pause)";
	            }
	        }
	    });

	    return AdminAdvancedSystemLogsController;
	})();

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedSupportPageController = __webpack_require__(221).AdminAdvancedSupportPageController;

	function supportPageConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.support_page", {
	        params: { feature: "supportPage" },
	        url: "/support_page",
	        templateUrl: "states/admin/advanced/support_page/support_page.html",
	        controller: "AdminAdvancedSupportPageController as SupportPage"
	    });
	}

	module.exports = angular.module("advanced.support_page", []).config(supportPageConfig).controller("AdminAdvancedSupportPageController", AdminAdvancedSupportPageController);

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminAdvancedSupportPageController = exports.AdminAdvancedSupportPageController = (function () {
	    function AdminAdvancedSupportPageController(SupportPageDao, ServerTimeDao, $timeout, $scope, JFrogIFrameDownload, GeneralConfigDao, RESOURCE, JFrogNotifications, $compile, JFrogModal) {
	        var _this = this;

	        _classCallCheck(this, AdminAdvancedSupportPageController);

	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$compile = $compile;
	        this.supportPageDao = SupportPageDao;
	        this.serverTimeDao = ServerTimeDao;
	        this.iFrameDownload = JFrogIFrameDownload;
	        this.RESOURCE = RESOURCE;
	        this.TOOLTIP = TOOLTIP.admin.advanced.supportPage;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.advanced.supportZone;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;

	        this.ready = false;

	        this.timePeriodConfig = {
	            maxItems: 1,
	            create: false
	        };

	        GeneralConfigDao.get().$promise.then(function (data) {
	            _this.dateFormat = _this._getDatePartFromFormat(data.dateFormat);
	            _this._init();
	        });
	    }

	    _createClass(AdminAdvancedSupportPageController, {
	        _init: {
	            value: function _init() {
	                var _this = this;

	                this.serverTimeDao.get().$promise.then(function (serverTimeResource) {
	                    var serverTime = "";
	                    var json = serverTimeResource.toJSON();
	                    for (var i = 0; i < Object.keys(json).length; i++) {
	                        serverTime += json[i];
	                    }
	                    serverTime = parseInt(serverTime);
	                    var miliDiff = serverTime - new Date().getTime();
	                    var hourDiff = Math.round(miliDiff / (1000 * 60 * 60));
	                    _this.timeDiff = hourDiff * 1000 * 60 * 60;
	                    _this._getOldBundles();
	                    _this.ready = true;
	                });

	                var localNow = new Date();
	                var today = this.today = new Date(localNow.getFullYear(), localNow.getMonth(), localNow.getDate());
	                var minDate = this.minDate = new Date(today.getTime() - 14 * 24 * 60 * 60 * 1000);

	                this.initAndBindDatepickerElement("from-date", "SupportPage.setup.systemLogsConfiguration.startDate", function (date) {
	                    if (_this.setup.systemLogsConfiguration.startDate.getTime() > _this.setup.systemLogsConfiguration.endDate.getTime()) {
	                        _this.setup.systemLogsConfiguration.endDate = new Date(_this.setup.systemLogsConfiguration.startDate);
	                        $("#to-date").datepicker("setDate", _this.setup.systemLogsConfiguration.endDate);
	                    }
	                });
	                this.initAndBindDatepickerElement("to-date", "SupportPage.setup.systemLogsConfiguration.endDate", function (date) {
	                    if (_this.setup.systemLogsConfiguration.startDate.getTime() > _this.setup.systemLogsConfiguration.endDate.getTime()) {
	                        _this.setup.systemLogsConfiguration.startDate = new Date(_this.setup.systemLogsConfiguration.endDate);
	                        $("#from-date").datepicker("setDate", _this.setup.systemLogsConfiguration.startDate);
	                    }
	                });

	                this.setup = {
	                    hideUserDetails: true,
	                    systemLogsConfiguration: {
	                        enabled: true,
	                        startDate: new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000),
	                        endDate: today
	                    },
	                    systemInfoConfiguration: {
	                        enabled: true
	                    },
	                    securityInfoConfiguration: {
	                        enabled: true
	                    },
	                    configDescriptorConfiguration: {
	                        enabled: true
	                    },
	                    configFilesConfiguration: {
	                        enabled: true
	                    },
	                    storageSummaryConfiguration: {
	                        enabled: true
	                    },
	                    threadDumpConfiguration: {
	                        enabled: true,
	                        count: 1,
	                        interval: 0
	                    }
	                };

	                this.timePeriodOptions = [{ text: "Last 24 Hours", value: 1 }, { text: "Last 3 Days", value: 3 }, { text: "Last 5 Days", value: 5 }, { text: "Last 7 Days", value: 7 }, { text: "Custom Dates", value: "CUSTOM" }];

	                this.timePeriodSelection = 1;
	            }
	        },
	        _getOldBundles: {
	            value: function _getOldBundles() {
	                var _this = this;

	                this.supportPageDao.listBundles().$promise.then(function (data) {
	                    _this.oldBundles = _.filter(data, function (obj) {
	                        return typeof obj === "string";
	                    });
	                    _this.oldBundles = _.map(_this.oldBundles, function (filename) {
	                        var filenameNoExt = filename.split(".")[0];
	                        var time = parseInt(filenameNoExt.split("-")[filenameNoExt.split("-").length - 1]) - _this.timeDiff;
	                        return {
	                            filename: filename,
	                            date: new Date(time).toString()
	                        };
	                    });
	                });
	            }
	        },
	        onChangeTimePeriod: {
	            value: function onChangeTimePeriod() {

	                if (this.timePeriodSelection !== "CUSTOM") {
	                    this.setup.systemLogsConfiguration.endDate = this.today;
	                    this.setup.systemLogsConfiguration.startDate = new Date(this.today.getTime() - (this.timePeriodSelection - 1) * 24 * 60 * 60 * 1000);
	                    $("#from-date").datepicker("setDate", this.setup.systemLogsConfiguration.startDate);
	                    $("#to-date").datepicker("setDate", this.setup.systemLogsConfiguration.endDate);
	                }
	            }
	        },
	        initAndBindDatepickerElement: {
	            value: function initAndBindDatepickerElement(elemId, model, changeCallback) {
	                var _this = this;

	                this.$timeout(function () {
	                    $("#" + elemId).datepicker({
	                        dateFormat: _this.dateFormat, //'dd-mm-yy',
	                        maxDate: _this.today,
	                        showOn: "none",
	                        onSelect: function (date, dp) {
	                            var selectedDate = new Date(dp.selectedYear, dp.selectedMonth, dp.selectedDay);
	                            _.set(_this.$scope, model, selectedDate);
	                            _this.$scope.$apply();
	                            changeCallback(selectedDate);
	                        }
	                    });
	                    $("#" + elemId).datepicker("setDate", _.get(_this.$scope, model));
	                    changeCallback(_.get(_this.$scope, model));
	                });
	            }
	        },
	        openDatePicker: {
	            value: function openDatePicker(e) {
	                if (this.timePeriodSelection === "CUSTOM" && this.setup.systemLogsConfiguration.enabled) {
	                    $(e.srcElement).datepicker("show");
	                }
	            }
	        },
	        download: {
	            value: function download(link) {
	                this.iFrameDownload(link);
	            }
	        },
	        downloadOld: {
	            value: function downloadOld(filename) {
	                var url = this.RESOURCE.API_URL + "/userSupport/downloadBundle/" + filename;
	                this.iFrameDownload(url);
	            }
	        },
	        deleteOld: {
	            value: function deleteOld(filename) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete this bundle?").then(function () {
	                    _this.supportPageDao.deleteBundle({}, { filename: filename }).$promise.then(function (resp) {
	                        _this._getOldBundles();
	                    });
	                });
	            }
	        },
	        create: {
	            value: function create() {
	                var _this = this;

	                var payload = angular.copy(this.setup);
	                if (this.timePeriodSelection != 1) {
	                    payload.systemLogsConfiguration.startDate = payload.systemLogsConfiguration.startDate.getTime() + this.timeDiff;
	                    payload.systemLogsConfiguration.endDate = payload.systemLogsConfiguration.endDate.getTime() + this.timeDiff + 24 * 60 * 60 * 1000;
	                } else {
	                    payload.systemLogsConfiguration.endDate = new Date().getTime() + this.timeDiff;
	                    payload.systemLogsConfiguration.startDate = payload.systemLogsConfiguration.endDate - 24 * 60 * 60 * 1000;
	                }

	                payload.configDescriptorConfiguration.hideUserDetails = this.setup.hideUserDetails;
	                payload.securityInfoConfiguration.hideUserDetails = this.setup.hideUserDetails;
	                payload.configFilesConfiguration.hideUserDetails = this.setup.hideUserDetails;

	                delete payload.hideUserDetails;

	                this.supportPageDao.generateBundle({}, payload).$promise.then(function (files) {
	                    if (files.length) {
	                        //this.downloadLinks = files;
	                        _this.artifactoryNotifications.createMessageWithHtml({
	                            type: "success",
	                            body: "Successfully created support information <a href id=\"link-in-toaster\" ng-click=\"SupportPage.download('" + files[0] + "')\">bundle</a>",
	                            timeout: 10000
	                        });
	                        _this.$timeout(function () {
	                            var elem = angular.element($("#link-in-toaster"));
	                            _this.$compile(elem)(_this.$scope);
	                        });
	                    }
	                    _this._getOldBundles();
	                });
	            }
	        },
	        _getDatePartFromFormat: {
	            value: function _getDatePartFromFormat(format) {
	                var parts = this._breakFormat(format);

	                var currContext = "U"; //U = Unkown D = Date T = Time
	                var unknowns = [];

	                var gotMonth = false;
	                for (var i in parts) {
	                    var part = parts[i];

	                    if (_.contains("dy", part.char)) {
	                        part.context = "D";
	                    } else if (_.contains("hs", part.char)) {
	                        part.context = "T";
	                    } else if (part.char === "m") {
	                        if (gotMonth) currContext = "U";
	                        part.context = !gotMonth && currContext === "D" ? "D" : "U";
	                        unknowns.push(part);
	                    }
	                    if (part.context) currContext = part.context;
	                    if (currContext !== "U" && unknowns.length) {
	                        for (var _i in unknowns) {
	                            unknowns[_i].context = currContext;
	                            if (currContext === "D") gotMonth = true;
	                        }
	                        unknowns = [];
	                    }
	                }

	                var insideDate = false;
	                var justDate = [];
	                for (var i in parts) {
	                    var part = parts[i];
	                    if (part.context === "D") {
	                        insideDate = true;
	                    } else if (part.context === "T") {
	                        insideDate = false;
	                    }
	                    if (insideDate) justDate.push(part);
	                }

	                var trim = 0;
	                for (var i = justDate.length - 1; i >= 0; i--) {
	                    var part = parts[i];
	                    if (part.context) {
	                        break;
	                    } else justDate.pop();
	                }

	                var finalResult = "";
	                for (var i in justDate) {
	                    var part = justDate[i];
	                    finalResult += part.precise;
	                }

	                return finalResult;
	            }
	        },
	        _breakFormat: {
	            value: function _breakFormat(format) {
	                var parts = [];
	                while (format.length) {
	                    var part = this._getNextFormatPart(format);
	                    parts.push(part);
	                    format = format.substr(part.count);
	                }
	                return parts;
	            }
	        },
	        _getNextFormatPart: {
	            value: function _getNextFormatPart(format) {
	                var temp = format.toLowerCase();
	                var char = temp.charAt(0);
	                var count = 0;
	                while (temp.charAt(0) === char) {
	                    count++;
	                    temp = temp.substr(1);
	                }
	                var precise = format.substr(0, count);
	                return {
	                    char: char,
	                    count: count,
	                    precise: precise
	                };
	            }
	        }
	    });

	    return AdminAdvancedSupportPageController;
	})();

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminAdvancedLogAnalyticsController = __webpack_require__(223).AdminAdvancedLogAnalyticsController;

	function logAnalyticsConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.log_analytics", {
	        url: "/log_analytics",
	        templateUrl: "states/admin/advanced/log_analytics/log_analytics.html",
	        controller: "AdminAdvancedLogAnalyticsController as LogAnalytics"
	    });
	}

	module.exports = angular.module("advanced.log_analytics", []).config(logAnalyticsConfig).controller("AdminAdvancedLogAnalyticsController", AdminAdvancedLogAnalyticsController);

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var MESSAGES = _interopRequire(__webpack_require__(181));

	/*
	* TODO:
	* - if proxy is change or on load thre's default proxy - update the model
	* */

	var AdminAdvancedLogAnalyticsController = exports.AdminAdvancedLogAnalyticsController = (function () {
	    function AdminAdvancedLogAnalyticsController(SumoLogicConfigDao, $scope, $state, $location, $timeout, $interval, $window, JFrogModal, ArtifactoryModelSaver, ProxiesDao) {
	        var _this = this;

	        _classCallCheck(this, AdminAdvancedLogAnalyticsController);

	        this.sumoLogicConfigDao = SumoLogicConfigDao;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$location = $location;
	        this.$timeout = $timeout;
	        this.$interval = $interval;
	        this.$window = $window;
	        this.modal = JFrogModal;
	        this.proxiesDao = ProxiesDao;
	        this.artifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sumologic"]);
	        this.enableExistingSettings = false;
	        this.TOOLTIP = TOOLTIP.admin.logAnalytics;
	        this.MESSAGES = MESSAGES.admin.advanced.logAnalytics;
	        this.getSumoLogicData(false, true);
	        this.proxies = [""];

	        this.proxiesDao.get().$promise.then(function (proxies) {
	            _.forEach(proxies, function (o) {
	                _this.proxies.push(o.key);
	                if (o.defaultProxy && !_this.proxy) {
	                    _this.proxy = o.key;
	                }
	            });
	        });
	    }

	    _createClass(AdminAdvancedLogAnalyticsController, {
	        disabledIntegration: {
	            value: function disabledIntegration() {
	                var _this = this;

	                if (this.enableExistingSettings === false) {
	                    this.modal.confirm("If disabled, logs will not be sent to your Sumo Logic account. <br /> You can enable the integration for this instance later. <br /><br /> Are you sure you want to disable the integration for this instance?", "Disable Sumo Logic Integration", { confirm: "Disable" }).then(function () {
	                        _this.cancelInterval();
	                        _this.enableDisableSumoLogic(false);
	                    })["catch"](function () {
	                        _this.enableExistingSettings = !_this.enableExistingSettings;
	                    });
	                } else {
	                    if (!this.sumologic.email) {
	                        this.modal.confirm("To enable the Sumo Logic integration, you must provide Artifactory with your email address by adding it to your User Profile.", "Email address required", { confirm: "Go to User Profile" }).then(function () {
	                            _this.$state.go("user_profile");
	                        })["catch"](function () {
	                            _this.enableExistingSettings = !_this.enableExistingSettings;
	                        });
	                    } else {
	                        if (this.sumologic.clientId && this.sumologic.secret) {
	                            this.modal.confirm("If enabled, your logs will be populated and sent to your Sumo Logic Artifactory dashboard. <br /><br /> Are you sure you want to enable the integration for this instance?", "Enable Sumo Logic Integration", { confirm: "Enable" }).then(function () {
	                                _this.enableDisableSumoLogic(true);
	                            })["catch"](function () {
	                                _this.enableExistingSettings = !_this.enableExistingSettings;
	                            });
	                        } else {
	                            this.enableDisableSumoLogic(true);
	                        }
	                    }
	                }
	            }
	        },
	        enableDisableSumoLogic: {
	            value: function enableDisableSumoLogic(action) {
	                this.sumologic.enabled = action;
	                this.updateModel();
	            }
	        },
	        changeListener: {
	            value: function changeListener() {
	                if (this.connectionMethod === "existing") {
	                    this.disableRegisterButton = false;
	                }
	            }
	        },
	        requireAuth: {
	            value: function requireAuth() {
	                return this.sumologic.clientId != this.origSumologicData.clientId || this.sumologic.secret != this.origSumologicData.secret;
	            }
	        },
	        changeConnectionMethod: {
	            value: function changeConnectionMethod(value) {
	                var _this = this;

	                if (value === "new") {
	                    if (this.sumologic.dashboardUrl || this.isPullingRunning) {
	                        this.modal.confirm("Creating a new connection will disconnect the current connection. When you access your dashboard with a new connection for the first time, a new Client ID and Secret will be created. <br /><br />Are you sure you want to create a new connection?", "Create New Connection with Sumo Logic", { confirm: "Create" }).then(function () {
	                            _this.cancelInterval();
	                            _this.sumoLogicConfigDao.reset().$promise.then(function (sumologic) {
	                                _this.connectionMethod = "new";
	                                _this.statusConnected = false;
	                                _this.disableRegisterButton = false;
	                                _this.sumologic = sumologic;
	                                _this.artifactoryModelSaver.save();
	                            })["catch"](function () {
	                                _this.cancelInterval();
	                            });
	                        })["catch"](function () {
	                            _this.connectionMethod = "existing";
	                        });
	                    } else {
	                        this.sumologic.clientId = null;
	                        this.sumologic.secret = null;
	                    }
	                }
	            }
	        },
	        registerSumoLogicApplication: {
	            value: function registerSumoLogicApplication() {
	                var _this = this;

	                this.disableRegisterButton = true;
	                this.sumologic.dashboardUrl = null;
	                this.sumoLogicConfigDao.registerSumoLogicApplication().$promise.then(function () {
	                    _this.getSumoLogicData(true);
	                    if (!angular.isDefined(_this.getDataInterval)) {
	                        _this.getDataInterval = _this.$interval(function () {
	                            _this.isPullingRunning = true;
	                            _this.getSumoLogicData();
	                        }, 5000);
	                    }
	                })["catch"](function () {
	                    _this.cancelInterval();
	                });
	            }
	        },
	        authenticateWithSumo: {
	            value: function authenticateWithSumo(setupNewConnection) {
	                var _this = this;

	                this.sumologic.dashboardUrl = null;
	                var setupTypeSuffix = setupNewConnection ? "/new_app" : "/existing_app";
	                var redirectUrl = encodeURIComponent(this.sumologic.redirectUrl + setupTypeSuffix);
	                var email = this.sumologic.email;
	                var url = this.sumologic.sumoBaseUrl + "/partner/oauth/authorize?response_type=code&email=" + encodeURIComponent(email) + "&license_type=" + this.sumologic.licenseType + "&client_id=" + this.sumologic.clientId + "&redirect_uri=" + redirectUrl + "";

	                var popup = this.$window.open(url, "_blank");

	                if (!angular.isDefined(this.getDataInterval)) {
	                    this.getDataInterval = this.$interval(function () {
	                        _this.isPullingRunning = true;
	                        _this.getSumoLogicData();
	                    }, 5000);
	                }

	                this.$timeout(function () {
	                    if (!popup || popup.outerHeight === 0) {
	                        var modalScope = _this.$scope.$new();
	                        modalScope.url = url;
	                        _this.modalInstance = _this.modal.launchModal("popup_block_notice", modalScope, "sm");
	                    }
	                }, 100);
	            }
	        },
	        getSumoLogicData: {
	            value: function getSumoLogicData(setupNewConnection, firstLoad) {
	                var _this = this;

	                this.sumoLogicConfigDao.get().$promise.then(function (sumologic) {
	                    _this.sumologic = sumologic;
	                    _this.origSumologicData = {
	                        clientId: _this.sumologic.clientId,
	                        secret: _this.sumologic.secret
	                    };
	                    _this.enableExistingSettings = _this.sumologic.enabled;

	                    if (_this.sumologic.dashboardUrl) {
	                        _this.cancelInterval();
	                        if (firstLoad && _this.enableExistingSettings) {
	                            _this.sumoLogicConfigDao.refreshToken().$promise.then(function (refreshResponseData) {
	                                _this.sumologic.dashboardUrl = refreshResponseData.dashboardUrl;
	                                _this.statusConnected = true;
	                                _this.updateModel();
	                            })["catch"](function () {
	                                if (angular.isDefined(_this.getDataInterval)) {
	                                    _this.$interval.cancel(_this.getDataInterval);
	                                }
	                            });
	                        }
	                    }

	                    if (_this.sumologic.clientId || _this.sumologic.secret) {
	                        _this.connectionMethod = "existing";
	                    } else {
	                        _this.connectionMethod = "new";
	                    }

	                    if (setupNewConnection) {
	                        _this.authenticateWithSumo(true);
	                        _this.updateModel();
	                    }
	                    _this.artifactoryModelSaver.save();
	                })["catch"](function () {
	                    _this.cancelInterval();
	                });
	            }
	        },
	        cancelInterval: {
	            value: function cancelInterval() {
	                if (angular.isDefined(this.getDataInterval)) {
	                    this.isPullingRunning = false;
	                    this.$interval.cancel(this.getDataInterval);
	                    delete this.getDataInterval;
	                }
	            }
	        },
	        updateProxy: {
	            value: function updateProxy() {
	                this.updateModel();
	            }
	        },
	        updateModel: {
	            value: function updateModel() {
	                var _this = this;

	                this.sumoLogicConfigDao.update(this.sumologic).$promise.then(function () {
	                    _this.artifactoryModelSaver.save();
	                });
	            }
	        }
	    });

	    return AdminAdvancedLogAnalyticsController;
	})();

/***/ }),
/* 224 */
/***/ (function(module, exports) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var AdminAdvancedController = exports.AdminAdvancedController = function AdminAdvancedController() {
	  _classCallCheck(this, AdminAdvancedController);

	  var AdminAdvanced = this;
	  AdminAdvanced.stateUrl = "/advanced";
	  AdminAdvanced.controllerName = "AdminAdvancedController";
	};

/***/ }),
/* 225 */
/***/ (function(module, exports) {

	"use strict";

	function dashboardConfig($stateProvider) {
	    $stateProvider.state("admin.dashboard", {
	        url: "/dashboard",
	        templateUrl: "states/admin/dashboard/dashboard.html"
	    });
	}

	module.exports = angular.module("admin.dashboard", []).config(dashboardConfig);

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var Repositories = _interopRequire(__webpack_require__(227));

	var System = _interopRequire(__webpack_require__(229));

	var AdminImportExportController = __webpack_require__(231).AdminImportExportController;

	function importExportConfig($stateProvider) {
	    $stateProvider.state("admin.import_export", {
	        url: "/import_export",
	        template: "<ui-view></ui-view>",
	        controller: "AdminImportExportController as AdminImportExport"
	    });
	}

	module.exports = angular.module("admin.import_export", [Repositories.name, System.name]).config(importExportConfig).controller("AdminImportExportController", AdminImportExportController);

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var ImportExportRepositoriesController = __webpack_require__(228).ImportExportRepositoriesController;

	function repositoriesConfig($stateProvider) {
	    $stateProvider.state("admin.import_export.repositories", {
	        params: { feature: "repositories" },
	        url: "/repositories",
	        templateUrl: "states/admin/import_export/repositories/repositories.html",
	        controller: "ImportExportRepositoriesController as Repositories"
	    });
	}

	module.exports = angular.module("import_export.repositories", []).config(repositoriesConfig).controller("ImportExportRepositoriesController", ImportExportRepositoriesController);

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var API = _interopRequire(__webpack_require__(88));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var ImportExportRepositoriesController = exports.ImportExportRepositoriesController = (function () {
	    function ImportExportRepositoriesController($scope, BrowseFilesDao, ExportDao, ImportDao, JFrogNotifications, FileUploader, RepoDataDao, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, ImportExportRepositoriesController);

	        this.$scope = $scope;
	        this.repoDataDao = RepoDataDao;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.FileUploader = FileUploader;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.exportDao = ExportDao;
	        this.importDao = ImportDao;
	        this.TOOLTIP = TOOLTIP.admin.import_export.repositories;

	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	        this.importFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Import",
	            pathLabel: "Path to import",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: false
	        };

	        this.uploadZip = {};
	        this.uploadSuccess = false;
	        this.exportOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            excludeMetadata: false,
	            m2: false,
	            verbose: false
	        };
	        this.importOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            excludeMetadata: false,
	            verbose: false
	        };
	        this.zipOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            verbose: false
	        };
	        this.artifactoryNotifications = JFrogNotifications;
	        this._initImportExportRepo();

	        this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getAllReposList();
	        });
	    }

	    _createClass(ImportExportRepositoriesController, {
	        _getRootPath: {
	            value: function _getRootPath() {
	                var _this = this;

	                this.browseFilesDao.query({ path: "/" }).$promise.then(function (result) {
	                    if (result) {
	                        _this.rootPath = result.roots[0] || "/";
	                        _this.roots = result.roots;
	                    }
	                });
	            }
	        },
	        getAllReposList: {
	            value: function getAllReposList() {
	                var _this = this;

	                this.repoDataDao.getForBackup().$promise.then(function (result) {
	                    _this.reposList = _.sortBy(result.repoList, function (repo) {
	                        return repo;
	                    });
	                    _this.reposList.unshift("All Repositories");
	                });
	            }
	        },
	        _initImportExportRepo: {
	            value: function _initImportExportRepo() {
	                this.uploader = new this.FileUploader();
	                this.uploader.url = "" + API.API_URL + "/artifactimport/upload";
	                this.uploader.onSuccessItem = this.onUploadSuccess.bind(this);
	                this.uploader.onErrorItem = this.onUploadError.bind(this);
	                this.uploader.onAfterAddingFile = this.onAddingfile.bind(this);

	                this.uploader.removeAfterUpload = true;
	                this.getAllReposList();

	                this._getRootPath();
	            }
	        },
	        onUploadError: {
	            value: function onUploadError(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        onUploadSuccess: {
	            value: function onUploadSuccess(fileDetails, response) {
	                this.uploadSuccess = true;
	                this.zipOptions.path = response.path;
	            }
	        },
	        onAddingfile: {
	            value: function onAddingfile(fileItem) {
	                if (fileItem.file.size < 0) {
	                    fileItem.okToUploadFile = false;
	                    this.uploader.removeFromQueue(fileItem);
	                } else {
	                    fileItem.okToUploadFile = true;
	                }
	            }
	        },
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        updateImportFolderPath: {
	            value: function updateImportFolderPath(directory) {
	                this.importOptions.path = directory;
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        "export": {
	            value: function _export(form) {
	                var self = this;
	                if (form.$valid) {
	                    var ok = false;
	                    for (var i in this.roots) {
	                        var root = this.roots[i];
	                        if (_.startsWith(this.exportOptions.path.toUpperCase(), root)) {
	                            ok = true;
	                            break;
	                        }
	                    }
	                    if (!ok) {
	                        this.exportOptions.path = this.defaultRoot + this.exportOptions.path;
	                    }
	                    this.exportDao.save(this.exportOptions);
	                }
	            }
	        },
	        "import": {
	            value: function _import(form) {
	                if (form.$valid) {
	                    this.importDao.save(this.importOptions);
	                }
	            }
	        },
	        importUploadZip: {
	            value: function importUploadZip() {
	                var _this = this;

	                var importDetails = {
	                    path: this.zipOptions.path,
	                    verbose: this.zipOptions.verbose,
	                    repository: this.zipOptions.repository,
	                    zip: true
	                };
	                this.importDao.save({ action: "repository" }, importDetails).$promise["finally"](function () {
	                    return _this.uploadSuccess = false;
	                });
	            }
	        },
	        upload: {
	            value: function upload() {
	                if (this.uploader.queue[0]) this.uploader.queue[0].upload();
	            }
	        }
	    });

	    return ImportExportRepositoriesController;
	})();

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminImportExportSystemController = __webpack_require__(230).AdminImportExportSystemController;

	function systemConfig($stateProvider) {
	    $stateProvider.state("admin.import_export.system", {
	        url: "/system",
	        templateUrl: "states/admin/import_export/system/system.html",
	        controller: "AdminImportExportSystemController as SystemController"
	    });
	}

	module.exports = angular.module("import_export.system", []).config(systemConfig).controller("AdminImportExportSystemController", AdminImportExportSystemController);

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminImportExportSystemController = exports.AdminImportExportSystemController = (function () {
	    function AdminImportExportSystemController(BrowseFilesDao, ExportDao, ImportDao, JFrogNotifications, JFrogModal, JFrogEventBus) {
	        _classCallCheck(this, AdminImportExportSystemController);

	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.systemExportDao = ExportDao;
	        this.systemImportDao = ImportDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.TOOLTIP = TOOLTIP.admin.import_export.system;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	        this.importFileBrowserOptions = {
	            canSelectFiles: true,
	            selectionLabel: "Directory Or Zip File To Import",
	            pathLabel: "Path to import",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: false
	        };

	        this.exportOptions = {
	            path: "",
	            excludeContent: false,
	            excludeMetadata: false,
	            excludeBuilds: false,
	            m2: false,
	            createArchive: false,
	            verbose: false
	        };

	        this.importOptions = {
	            path: "",
	            excludeContent: false,
	            excludeMetadata: false,
	            verbose: false
	        };

	        this._getRootPath();
	    }

	    _createClass(AdminImportExportSystemController, {
	        _getRootPath: {
	            value: function _getRootPath() {
	                var _this = this;

	                this.browseFilesDao.query({ path: "/" }).$promise.then(function (result) {
	                    if (result) {
	                        _this.defaultRootPath = result.roots[0] || "/";
	                        _this.roots = result.roots;
	                    }
	                });
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        updateImportFolderPath: {
	            value: function updateImportFolderPath(directory) {
	                this.importOptions.path = directory;
	            }
	        },
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        "import": {
	            value: function _import() {
	                if (this.importForm.$valid) {
	                    this.confirmImport();
	                }
	            }
	        },
	        doImport: {
	            value: function doImport() {
	                this.importOptions.zip = _.endsWith(this.importOptions.path, ".zip");
	                this.importOptions.action = "system";
	                this.systemImportDao.save(this.importOptions);
	            }
	        },
	        "export": {
	            value: function _export() {
	                var _this = this;

	                if (this.exportForm.$valid) {
	                    var ok = false;
	                    for (var i in this.roots) {
	                        var root = this.roots[i];
	                        if (_.startsWith(this.exportOptions.path.toUpperCase(), root)) {
	                            ok = true;
	                            break;
	                        }
	                    }
	                    if (!ok) {
	                        this.exportOptions.path = this.defaultRootPath + this.exportOptions.path;
	                    }
	                    this.exportOptions.action = "system";
	                    this.systemExportDao.save(this.exportOptions).$promise.then(function (res) {
	                        if (res.status = 200) _this.exportOptions.path = "";
	                    });
	                }
	            }
	        },
	        confirmImport: {
	            value: function confirmImport() {
	                var _this = this;

	                this.modal.confirm("Full system import deletes all existing Artifactory content. <br /> Are you sure you want to continue?").then(function () {
	                    return _this.doImport();
	                });
	            }
	        }
	    });

	    return AdminImportExportSystemController;
	})();

/***/ }),
/* 231 */
/***/ (function(module, exports) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var AdminImportExportController = exports.AdminImportExportController = function AdminImportExportController() {
	  _classCallCheck(this, AdminImportExportController);

	  var AdminImportExport = this;
	  AdminImportExport.stateUrl = "/import_export";
	  AdminImportExport.controllerName = "AdminImportExportController";
	};

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var General = _interopRequire(__webpack_require__(233));

	var Groups = _interopRequire(__webpack_require__(235));

	var HttpSso = _interopRequire(__webpack_require__(238));

	var SshServer = _interopRequire(__webpack_require__(240));

	var Permissions = _interopRequire(__webpack_require__(242));

	var Users = _interopRequire(__webpack_require__(245));

	var Saml = _interopRequire(__webpack_require__(249));

	var CrowdIntegration = _interopRequire(__webpack_require__(251));

	var OAuth = _interopRequire(__webpack_require__(253));

	var LdapSettings = _interopRequire(__webpack_require__(256));

	var SigningKeys = _interopRequire(__webpack_require__(260));

	var AccessTokens = _interopRequire(__webpack_require__(262));

	var AdminSecurityController = __webpack_require__(264).AdminSecurityController;

	function securityConfig($stateProvider) {
	    $stateProvider.state("admin.security", {
	        url: "/security",
	        template: "<ui-view></ui-view>",
	        controller: "AdminSecurityController as AdminSecurity"
	    });
	}

	module.exports = angular.module("admin.security", [General.name, Groups.name, HttpSso.name, SshServer.name, Permissions.name, Users.name, Saml.name, CrowdIntegration.name, OAuth.name, LdapSettings.name, SigningKeys.name, AccessTokens.name]).config(securityConfig).controller("AdminSecurityController", AdminSecurityController);

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityGeneralController = __webpack_require__(234).AdminSecurityGeneralController;

	function securityGeneralConfig($stateProvider) {

	    $stateProvider.state("admin.security.general", {
	        url: "/general",
	        templateUrl: "states/admin/security/general/general.html",
	        controller: "AdminSecurityGeneralController as AdminSecurityGeneral"
	    });
	}

	module.exports = angular.module("security.general", []).config(securityGeneralConfig).controller("AdminSecurityGeneralController", AdminSecurityGeneralController);

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecurityGeneralController = exports.AdminSecurityGeneralController = (function () {
	    function AdminSecurityGeneralController(AdminSecurityGeneralDao, PasswordsEncryptionDao, ArtifactoryModelSaver, UserProfileDao, JFrogModal, UserDao, JFrogNotifications, User) {
	        _classCallCheck(this, AdminSecurityGeneralController);

	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.passwordsEncryptionDao = PasswordsEncryptionDao.getInstance();
	        this.options = [{ label: "Supported", value: "SUPPORTED" }, { label: "Unsupported", value: "UNSUPPORTED" }, { label: "Required", value: "REQUIRED" }];
	        this.modal = JFrogModal;
	        this.User = User;
	        this.TOOLTIP = TOOLTIP.admin.security.general;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["generalConfig"]);
	        this.userProfileDao = UserProfileDao;
	        this.userDao = UserDao.getInstance();
	        this.artifactoryNotifications = JFrogNotifications;

	        this.getGeneralConfigObject();
	        this.getMasterKeyStatus();
	    }

	    _createClass(AdminSecurityGeneralController, {
	        getEncryptionButtonText: {
	            value: function getEncryptionButtonText() {
	                return this.materKeyState.hasMasterKey ? "Decrypt" : "Encrypt";
	            }
	        },
	        getEncryptionStatusText: {
	            value: function getEncryptionStatusText() {
	                return this.materKeyState.hasMasterKey ? "All passwords in your configuration are currently encrypted." : "All passwords in your configuration are currently visible in plain text.";
	            }
	        },
	        getGeneralConfigObject: {
	            value: function getGeneralConfigObject() {
	                var _this = this;

	                this.adminSecurityGeneralDao.get().$promise.then(function (data) {
	                    _this.generalConfig = data;
	                    _this.generalConfig.passwordSettings.encryptionPolicy = _.find(_this.options, { value: _this.generalConfig.passwordSettings.encryptionPolicy });
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getMasterKeyStatus: {
	            value: function getMasterKeyStatus() {
	                this.materKeyState = this.passwordsEncryptionDao.get();
	            }
	        },
	        forcePassExpForAll: {
	            value: function forcePassExpForAll() {
	                var _this = this;

	                if (!this.generalConfig.passwordSettings.expirationPolicy.enabled) {
	                    return;
	                }this.modal.confirm("Are you sure you want to expire all user's passwords?").then(function () {
	                    _this.userDao.expireAllPassword();
	                });
	            }
	        },
	        unExpireAll: {
	            value: function unExpireAll() {
	                var _this = this;

	                if (!this.generalConfig.passwordSettings.expirationPolicy.enabled) {
	                    return;
	                }this.modal.confirm("Are you sure you want to unexpire all user's expired passwords?").then(function () {
	                    _this.userDao.unExpireAllPassword();
	                });
	            }
	        },
	        toggleEncryption: {
	            value: function toggleEncryption() {
	                var _this = this;

	                if (this.materKeyState.hasMasterKey) {
	                    this.modal.confirm("Artifactory will decrypt all encrypted data in your configuration files<br/>and user sensitive data, and it will be saved in clear text.<br/>It is recommended to backup your current artifactory.key<br/>(under $ARTIFACTORY_HOME/etc/security).<br/><br/>Are you sure you want to decrypt?", null, { confirm: "Decrypt" }).then(function () {
	                        _this.materKeyState.$decrypt().then(function () {
	                            _this.getMasterKeyStatus();
	                        });
	                    });
	                } else {
	                    this.modal.confirm("Artifactory will create a private key to encrypt your configuration data<br/>and user sensitive data under /etc directory.<br/>Make sure to backup the key (under $ARTIFACTORY_HOME/etc/security)<br/>in a secure private location, since without it Artifactory will not be able to decrypt the encrypted data, such as configuration passwords, API keys, encrypted passwords, etc.<br/><br/>Are you sure you want to encrypt?", null, { confirm: "Encrypt" }).then(function () {
	                        _this.materKeyState.$encrypt().then(function () {
	                            _this.getMasterKeyStatus();
	                        });
	                    });
	                }
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                var payload = _.cloneDeep(this.generalConfig);
	                payload.passwordSettings.encryptionPolicy = payload.passwordSettings.encryptionPolicy.value;
	                this.adminSecurityGeneralDao.update(payload).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.User.reload();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getGeneralConfigObject();
	                });
	            }
	        },
	        onClickAllowAnonymousAccess: {
	            value: function onClickAllowAnonymousAccess() {
	                if (!this.generalConfig.anonAccessEnabled) {
	                    this.generalConfig.anonAccessToBuildInfosDisabled = false;
	                }
	            }
	        },
	        revokeApiKeys: {
	            value: function revokeApiKeys() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to revoke all users API keys?").then(function () {
	                    _this.userProfileDao.revokeApiKey({ deleteAll: 1 });
	                });
	            }
	        },
	        unlockAllUsers: {
	            value: function unlockAllUsers() {
	                this.adminSecurityGeneralDao.unlockAllUsers();
	            }
	        }
	    });

	    return AdminSecurityGeneralController;
	})();

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityGroupsController = __webpack_require__(236).AdminSecurityGroupsController;

	var AdminSecurityGroupFormController = __webpack_require__(237).AdminSecurityGroupFormController;

	function groupsConfig($stateProvider) {

	    $stateProvider.state("admin.security.groups", {
	        url: "/groups",
	        templateUrl: "states/admin/security/groups/groups.html",
	        controller: "AdminSecurityGroupsController as AdminSecurityGroups"
	    }).state("admin.security.groups.edit", {
	        parent: "admin.security",
	        url: "/groups/{groupname}/edit",
	        templateUrl: "states/admin/security/groups/group_form.html",
	        controller: "AdminSecurityGroupFormController as GroupForm"
	    }).state("admin.security.groups.new", {
	        parent: "admin.security",
	        url: "/groups/new",
	        templateUrl: "states/admin/security/groups/group_form.html",
	        controller: "AdminSecurityGroupFormController as GroupForm"
	    });
	}

	module.exports = angular.module("security.groups", []).config(groupsConfig).controller("AdminSecurityGroupsController", AdminSecurityGroupsController).controller("AdminSecurityGroupFormController", AdminSecurityGroupFormController);

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminSecurityGroupsController = exports.AdminSecurityGroupsController = (function () {
	    function AdminSecurityGroupsController(JFrogModal, $scope, $state, GroupsDao, JFrogGridFactory, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminSecurityGroupsController);

	        this.DEFAULT_REALM = "artifactory";
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.groupsDao = GroupsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.noGroupsMessage = CONFIG_MESSAGES.admin.security.groups.noGroupsMessage;
	        this._createGrid();
	        this._initGroups();
	    }

	    _createClass(AdminSecurityGroupsController, {
	        _initGroups: {
	            value: function _initGroups() {
	                var _this = this;

	                this.groupsDao.getAll().$promise.then(function (groups) {
	                    _this.gridOption.setGridData(groups);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setButtons(this._getActions()).setMultiSelect().setRowTemplate("default").setBatchActions(this._getBatchActions());
	            }
	        },
	        deleteGroup: {
	            value: function deleteGroup(group) {
	                var _this = this;

	                var json = { groupNames: [group.groupName] };
	                this.modal.confirm("Are you sure you want to delete group '" + group.name + "' ?").then(function () {
	                    return _this.groupsDao["delete"](json).$promise.then(function () {
	                        return _this._initGroups();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                //Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                //Create an array of the selected groups names
	                var names = _.map(selectedRows, function (group) {
	                    return group.groupName;
	                });
	                //Create Json for the bulk request
	                var json = { groupNames: names };
	                //console.log('Bulk delete....');
	                //Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to delete " + names.length + " groups ?").then(function () {
	                    return _this.groupsDao["delete"](json).$promise.then(function () {
	                        return _this._initGroups();
	                    });
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "groupName",
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.groups.edit({groupname: row.entity.groupName})\"><a href=\"\">{{row.entity.groupName}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "20%"
	                }, {
	                    field: "permissions",
	                    name: "Permissions",
	                    displayName: "Permissions",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.permissions", "row.entity.groupName"),
	                    width: "50%"
	                }, {
	                    name: "External",
	                    displayName: "External",
	                    field: "External",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.external"),
	                    width: "10%"
	                }, {
	                    name: "Admin",
	                    displayName: "Admin",
	                    field: "adminPrivileges",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.adminPrivileges"),
	                    width: "10%"
	                }, {
	                    name: "Auto Join",
	                    displayName: "Auto Join",
	                    field: "Auto Join",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.autoJoin"),
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteGroup(row);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        }
	    });

	    return AdminSecurityGroupsController;
	})();

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminSecurityGroupFormController = exports.AdminSecurityGroupFormController = (function () {
	    function AdminSecurityGroupFormController($scope, $state, $stateParams, $timeout, $q, JFrogGridFactory, GroupsDao, UserDao, GroupPermissionsDao, commonGridColumns, ArtifactoryModelSaver, RepositoriesDao) {
	        _classCallCheck(this, AdminSecurityGroupFormController);

	        this.DEFAULT_REALM = "artifactory";
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.repositoriesDao = RepositoriesDao;
	        this.userDao = UserDao.getInstance();
	        this.groupsDao = GroupsDao.getInstance();
	        this.groupPermissionsDao = GroupPermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.permissionsGridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["groupdata"]);
	        this.input = {};
	        this.MESSAGES = MESSAGES.admin.security.groups.groupForm;

	        if ($stateParams.groupname) {
	            this.mode = "edit";
	            this.groupname = $stateParams.groupname;
	            this.title = "Edit " + this.groupname + " Group";
	            this._getGroupData();
	            this._createGrid();
	            this._getPermissions();
	        } else {
	            this.mode = "create";
	            this.title = "Add New Group";
	            this.groupdata = {};
	            this.saveLastNewUsersCheckbox = false;
	        }

	        this._getAllRepos();
	        this._getAllUsers();
	    }

	    _createClass(AdminSecurityGroupFormController, {
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;

	                this.reposData = {};
	                this.repositoriesDao.getRepositories({ type: "local" }).$promise.then(function (data) {
	                    _this.reposData.locals = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "remote" }).$promise.then(function (data) {
	                    _this.reposData.remotes = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	            }
	        },
	        _getGroupData: {
	            value: function _getGroupData() {
	                var _this = this;

	                this.groupsDao.getSingle({ name: this.groupname }).$promise.then(function (data) {
	                    _this.groupdata = data.data;
	                    _this.saveLastNewUsersCheckbox = _this.groupdata.newUserDefault;
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _getAllUsers: {
	            value: function _getAllUsers() {
	                var _this = this;

	                this.userDao.getAll().$promise.then(function (data) {
	                    _this.usersData = data;
	                    _this.usersList = _.map(data, function (user) {
	                        return user.name;
	                    });
	                    _this.userDndTemplate = "<div style=\"min-width:200px\">\n                                        {{getItemInfo().text}}\n                                        <i ng-if=\"userScope.GroupForm.userIsAdmin(getItemInfo().text)\" \n                                            jf-tooltip=\"Admin Privileges\"\n                                            class=\"icon icon-admin-new pull-left\"></i>\n                                        <i ng-if=\"!userScope.GroupForm.userIsAdmin(getItemInfo().text)\" \n                                            class=\"icon icon-blank pull-left\"></i>\n                                    </div>";
	                });
	            }
	        },
	        userIsAdmin: {
	            value: function userIsAdmin(user) {
	                // console.log(user,this.usersData);
	                return _.find(this.usersData, function (userData) {
	                    return userData.name === user && (userData.admin === true || userData.groupAdmin);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.permissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getPermissionCloumns()).setRowTemplate("default");
	            }
	        },
	        _getPermissions: {
	            value: function _getPermissions() {
	                var _this = this;

	                this.groupPermissionsDao.get({ groups: [this.groupname] }).$promise.then(function (data) {
	                    //console.log(data);
	                    _this._fixDataFormat(data).then(function (fixedData) {
	                        _this.permissionsGridOptions.setGridData(fixedData);
	                    });
	                });
	            }
	        },
	        _fixDataFormat: {
	            value: function _fixDataFormat(data) {
	                var _this = this;

	                var defer = arguments[1] === undefined ? null : arguments[1];

	                var defer = defer || this.$q.defer();
	                if (this.reposData.locals && this.reposData.remotes) {
	                    data.forEach(function (record) {
	                        if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY LOCAL") {
	                            record.repoKeysView = "ANY LOCAL";
	                            record.reposList = angular.copy(_this.reposData.locals);
	                        } else if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY REMOTE") {
	                            record.repoKeysView = "ANY REMOTE";
	                            record.reposList = angular.copy(_this.reposData.remotes);
	                        } else if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY") {
	                            record.repoKeysView = "ANY";
	                            record.reposList = angular.copy(_this.reposData.remotes).concat(_this.reposData.locals);
	                        } else {
	                            record.repoKeysView = record.repoKeys.join(", ");
	                            record.reposList = angular.copy(record.repoKeys);
	                        }
	                    });
	                    defer.resolve(data);
	                } else {
	                    this.$timeout(function () {
	                        _this._fixDataFormat(data, defer);
	                    });
	                }
	                return defer.promise;
	            }
	        },
	        updateGroup: {
	            value: function updateGroup() {
	                var _this = this;

	                var payload = angular.copy(this.groupdata);
	                _.extend(payload, this.input);
	                this.groupsDao.update({ name: this.groupdata.groupName }, payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.groups");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        createNewGroup: {
	            value: function createNewGroup() {
	                var _this = this;

	                var payload = angular.copy(this.groupdata);
	                payload.realm = this.DEFAULT_REALM;
	                _.extend(payload, this.input);
	                this.groupsDao.create(payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.groups");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                if (this.mode === "edit") this.updateGroup();
	                if (this.mode === "create") this.createNewGroup();
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || this.groupForm.$invalid;
	            }
	        },
	        onAdminPrivelegesChange: {
	            value: function onAdminPrivelegesChange() {
	                if (this.groupdata.adminPrivileges) {
	                    this.saveLastNewUsersCheckbox = this.groupdata.newUserDefault;
	                    this.groupdata.newUserDefault = false;
	                } else {
	                    this.groupdata.newUserDefault = this.saveLastNewUsersCheckbox;
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.groups");
	            }
	        },
	        _getPermissionCloumns: {
	            value: function _getPermissionCloumns() {

	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";

	                return [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    cellTemplate: nameCellTemplate,
	                    width: "20%"
	                },
	                /*
	                            {
	                                field: "effectivePermission.principal",
	                                displayName: "Inherited From"
	                            },
	                */
	                {
	                    field: "repoKeys",
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.reposList", "row.entity.permissionName", "row.entity.repoKeysView", true),
	                    width: "25%"
	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    width: "14%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "8%"
	                }];
	            }
	        }
	    });

	    return AdminSecurityGroupFormController;
	})();

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityHttpSSoController = __webpack_require__(239).AdminSecurityHttpSSoController;

	function httpSsoConfig($stateProvider) {

	    $stateProvider.state("admin.security.http_sso", {
	        params: { feature: "HTTPSSO" },
	        url: "/http_sso",
	        templateUrl: "states/admin/security/http_sso/http_sso.html",
	        controller: "AdminSecurityHttpSSoController as AdminSecurityHttpSSo"
	    });
	}

	module.exports = angular.module("security.http_sso", []).config(httpSsoConfig).controller("AdminSecurityHttpSSoController", AdminSecurityHttpSSoController);

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecurityHttpSSoController = exports.AdminSecurityHttpSSoController = (function () {
	    function AdminSecurityHttpSSoController(HttpSsoDao, JFrogEventBus, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminSecurityHttpSSoController);

	        this.JFrogEventBus = JFrogEventBus;
	        this.httpSsoDao = HttpSsoDao.getInstance();
	        this.sso = this.getSsoData();
	        this.TOOLTIP = TOOLTIP.admin.security.HTTPSSO;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sso"]);
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }

	    _createClass(AdminSecurityHttpSSoController, {
	        getSsoData: {
	            value: function getSsoData() {
	                var _this = this;

	                this.httpSsoDao.get().$promise.then(function (sso) {
	                    _this.sso = sso;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getSsoData();
	                });
	            }
	        },
	        save: {
	            value: function save(sso) {
	                var _this = this;

	                this.httpSsoDao.update(sso).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        }
	    });

	    return AdminSecurityHttpSSoController;
	})();

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecuritySshServerController = __webpack_require__(241).AdminSecuritySshServerController;

	function sshServerConfig($stateProvider) {

	    $stateProvider.state("admin.security.ssh_server", {
	        params: { feature: "SSHSERVER" },
	        url: "/ssh_server",
	        templateUrl: "states/admin/security/ssh_server/ssh_server.html",
	        controller: "AdminSecuritySshServerController as AdminSecuritySshServer"
	    });
	}

	module.exports = angular.module("security.ssh_server", []).config(sshServerConfig).controller("AdminSecuritySshServerController", AdminSecuritySshServerController);

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var API = _interopRequire(__webpack_require__(88));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecuritySshServerController = exports.AdminSecuritySshServerController = (function () {
	    function AdminSecuritySshServerController($timeout, $scope, $state, FileUploader, SshServerDao, JFrogEventBus, ArtifactoryModelSaver, JFrogNotifications, JFrogModal) {
	        _classCallCheck(this, AdminSecuritySshServerController);

	        this.$timeout = $timeout;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.FileUploader = FileUploader;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.SshServerDao = SshServerDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.security.SSHSERVER;
	        this.modal = JFrogModal;

	        // Set flags for case added server keys (prior to upload)
	        this.serverKeysStatuses = {
	            addedPublicKeyFile: false,
	            addedPrivateKeyFile: false
	        };

	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sshServer", "serverKeysStatuses"]);
	        this.publicKeyValue = "No public key installed";
	        this.privateKeyValue = "No private key installed";
	        this.NO_VALUE_STRING = "** NO VALUE **";
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.getSshData();
	        this.initKeys();
	    }

	    _createClass(AdminSecuritySshServerController, {
	        initKeys: {
	            value: function initKeys() {
	                var _this = this;

	                this.uploaderPublicKey = new this.FileUploader();
	                this.uploaderPublicKey.onSuccessItem = this.onUploadPublicKeySuccess.bind(this);
	                this.uploaderPublicKey.url = "" + API.API_URL + "/sshserver/install?public=true";
	                this.uploaderPublicKey.removeAfterUpload = true;

	                // Raise flag when adding a public key to input
	                this.uploaderPublicKey.onAfterAddingAll = function (addedItems) {
	                    _this.serverKeysStatuses.addedPublicKeyFile = true;
	                };

	                this.uploaderPrivateKey = new this.FileUploader();
	                this.uploaderPrivateKey.url = "" + API.API_URL + "/sshserver/install?public=false";
	                this.uploaderPrivateKey.onSuccessItem = this.onUploadPrivateKeySuccess.bind(this);
	                this.uploaderPrivateKey.removeAfterUpload = true;

	                // Raise flag when adding a private key to input
	                this.uploaderPrivateKey.onAfterAddingAll = function (addedItems) {
	                    _this.serverKeysStatuses.addedPrivateKeyFile = true;
	                };
	            }
	        },
	        getSshData: {
	            value: function getSshData() {
	                var _this = this;

	                var updateKeysStateOnly = arguments[0] === undefined ? false : arguments[0];

	                this.SshServerDao.get().$promise.then(function (sshServer) {
	                    if (!updateKeysStateOnly) _this.sshServer = sshServer;
	                    _this.publicKeyInstalled = sshServer.serverKey && sshServer.serverKey.publicKeyInstalled;
	                    _this.privateKeyInstalled = sshServer.serverKey && sshServer.serverKey.privateKeyInstalled;
	                    _this.publicKeyValue = _this.publicKeyInstalled ? "Public key is installed" : "No public key installed";
	                    _this.privateKeyValue = _this.privateKeyInstalled ? "Private key is installed" : "No private key installed";
	                    _this.publicKeyLink = sshServer.serverKey ? sshServer.serverKey.publicKeyLink : undefined;
	                    _this.passPhrase = sshServer.serverKey ? sshServer.serverKey.passPhrase : undefined;
	                    _this.sshServer.customUrlBase = _this.sshServer.customUrlBase || _this.NO_VALUE_STRING;
	                    if (!updateKeysStateOnly) _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        clearServerKeysInputs: {
	            value: function clearServerKeysInputs() {
	                this.uploaderPrivateKey.clearQueue();
	                this.serverKeysStatuses.addedPrivateKeyFile = false;
	                this.uploaderPublicKey.clearQueue();
	                this.serverKeysStatuses.addedPublicKeyFile = false;
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getSshData();
	                    _this.clearServerKeysInputs();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.sshServer.enableSshServer && this.sshServer.customUrlBase === this.NO_VALUE_STRING) {
	                    this._showUrlBaseAlert().then(function (gotoGenConf) {
	                        if (gotoGenConf) {
	                            _this.SshServerDao.update(_this.sshServer).$promise.then(function () {
	                                _this.ArtifactoryModelSaver.save();
	                                _this.$state.go("admin.configuration.general", { focusOnBaseUrl: true });
	                            });
	                        } else {
	                            _this.SshServerDao.update(_this.sshServer).$promise.then(function () {
	                                _this.ArtifactoryModelSaver.save();
	                            });
	                        }
	                    });
	                } else {
	                    this.SshServerDao.update(this.sshServer).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        _showUrlBaseAlert: {
	            value: function _showUrlBaseAlert() {
	                var modalScope = this.$scope.$new();
	                modalScope.context = "ssh";
	                return this.modal.launchModal("base_url_alert_modal", modalScope, "md").result;
	            }
	        },
	        onUploadPublicKeySuccess: {
	            value: function onUploadPublicKeySuccess(fileDetails, response) {
	                this.getSshData(true);
	                this.artifactoryNotifications.create(response.feedbackMsg);
	                this.serverKeysStatuses.addedPublicKeyFile = false;
	            }
	        },
	        onUploadPrivateKeySuccess: {
	            value: function onUploadPrivateKeySuccess(fileDetails, response) {
	                this.getSshData(true);
	                this.artifactoryNotifications.create(response.feedbackMsg);
	                this.serverKeysStatuses.addedPrivateKeyFile = false;
	            }
	        },
	        upload: {
	            value: function upload(type) {
	                if (type === "public") {
	                    this.uploaderPublicKey.queue[0].upload();
	                }
	                if (type === "private") {
	                    this.uploaderPrivateKey.queue[0].upload();
	                }
	            }
	        },
	        removeKey: {
	            value: function removeKey(isPublic) {
	                var _this = this;

	                this.SshServerDao["delete"]({ "public": isPublic }).$promise.then(function (result) {
	                    return _this.getSshData(true);
	                });
	            }
	        },
	        verifyPhrase: {
	            value: function verifyPhrase() {
	                var shouldNotify = arguments[0] === undefined ? true : arguments[0];

	                var method = shouldNotify ? "post" : "postWithoutNotifications";
	                if (this.SshServerDao[method]) {
	                    return this.SshServerDao[method]({ action: "verify", passPhrase: this.passPhrase }).$promise;
	                }
	            }
	        },
	        updatePhrase: {
	            value: function updatePhrase() {
	                var _this = this;

	                var verifyPromise = this.verifyPhrase(false);
	                if (verifyPromise) {
	                    verifyPromise.then(function () {
	                        _this.SshServerDao.put({ action: "update", passPhrase: _this.passPhrase });
	                    })["catch"](function (response) {
	                        return _this.artifactoryNotifications.create(response.data);
	                    });
	                    ;
	                }
	            }
	        },
	        canUploadSshKey: {
	            value: function canUploadSshKey(uploader) {
	                return this[uploader].queue.length;
	            }
	        },
	        canUpdatePhrase: {
	            value: function canUpdatePhrase() {
	                return this.publicKeyInstalled && this.privateKeyInstalled && this.passPhrase;
	            }
	        }
	    });

	    return AdminSecuritySshServerController;
	})();

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityPermissionsController = __webpack_require__(243).AdminSecurityPermissionsController;

	var AdminSecurityPermissionsFormController = __webpack_require__(244).AdminSecurityPermissionsFormController;

	function permissionsConfig($stateProvider) {

	    $stateProvider.state("admin.security.permissions", {
	        url: "/permissions",
	        templateUrl: "states/admin/security/permissions/permissions.html",
	        controller: "AdminSecurityPermissionsController as Permissions"
	    }).state("admin.security.permissions.edit", {
	        parent: "admin.security",
	        url: "/permissions/{permission}/edit",
	        templateUrl: "states/admin/security/permissions/permission_form.html",
	        controller: "AdminSecurityPermissionsFormController as PermissionForm"
	    }).state("admin.security.permissions.new", {
	        parent: "admin.security",
	        url: "/permission/new",
	        templateUrl: "states/admin/security/permissions/permission_form.html",
	        controller: "AdminSecurityPermissionsFormController as PermissionForm"
	    });
	}

	module.exports = angular.module("security.permissions", []).config(permissionsConfig).controller("AdminSecurityPermissionsController", AdminSecurityPermissionsController).controller("AdminSecurityPermissionsFormController", AdminSecurityPermissionsFormController);

/***/ }),
/* 243 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminSecurityPermissionsController = exports.AdminSecurityPermissionsController = (function () {
	    function AdminSecurityPermissionsController($scope, $state, JFrogGridFactory, PermissionsDao, JFrogModal, uiGridConstants, User, commonGridColumns) {
	        _classCallCheck(this, AdminSecurityPermissionsController);

	        this.$state = $state;
	        this.currentTab = "repo";
	        this.modal = JFrogModal;
	        this.permissionsDao = PermissionsDao.getInstance();
	        this.$scope = $scope;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.uiGridConstants = uiGridConstants;
	        this.user = User.getCurrent();
	        this._createGrid();
	        this.initPermission();
	    }

	    _createClass(AdminSecurityPermissionsController, {
	        initPermission: {
	            value: function initPermission() {
	                var _this = this;

	                this.permissionsDao.getAll().$promise.then(function (permissions) {
	                    permissions.forEach(function (permission) {
	                        permission.groupsList = _.pluck(permission.groups, "principal");
	                        permission.usersList = _.pluck(permission.users, "principal");
	                        permission.reposList = _.pluck(permission.repoKeys, "repoKey");
	                        permission.repoKeysView = permission.repoKeysView ? permission.repoKeysView.indexOf("|") !== -1 ? permission.repoKeysView.split("|")[1].trim() : permission.repoKeysView : "";
	                    });

	                    _this.gridOption.setGridData(permissions);
	                });
	            }
	        },
	        showNew: {
	            value: function showNew() {
	                return this.user.isAdmin();
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;

	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setGridData([]).setBatchActions(this._getBatchActions());

	                this.gridOption.isRowSelectable = function (row) {
	                    return row.entity.name !== _this.user.name;
	                };
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deletePermission(row);
	                    },
	                    visibleWhen: function (row) {
	                        return !_.findWhere(row.users, { principal: _this.user.name });
	                    }
	                }
	                /*
	                            {
	                                icon: 'icon icon-builds',
	                                tooltip: 'Edit',
	                                callback: row => this._editPermission(row)
	                            }
	                */
	                ];
	            }
	        },
	        editPermission: {
	            value: function editPermission(row) {
	                this.$state.go("^.permissions.edit", { permission: row.name });
	            }
	        },
	        _deletePermission: {
	            value: function _deletePermission(row) {
	                var _this = this;

	                var json = { permissionTargetNames: [row.name] };
	                this.modal.confirm("Are you sure you want to delete permission '" + row.name + "?'").then(function () {
	                    return _this.permissionsDao.deletePermission(json).$promise.then(function () {
	                        return _this.initPermission();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                //Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                //Create an array of the selected permission names
	                var names = _.map(selectedRows, function (row) {
	                    return row.name;
	                });
	                //Create Json for the bulk request
	                var json = { permissionTargetNames: names };
	                //console.log('Bulk delete....');
	                //Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to delete " + names.length + " permissions?").then(function () {
	                    return _this.permissionsDao.deletePermission(json).$promise.then(function () {
	                        return _this.initPermission();
	                    });
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Permission Target Name",
	                    displayName: "Permission Target Name",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a href ng-click=\"grid.appScope.Permissions.editPermission(row.entity)\">{{row.entity.name}}</a></div>"
	                }, {
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.reposList", "row.entity.name", "row.entity.repoKeysView", true),
	                    field: "repoKeysView"
	                }, {
	                    name: "Groups",
	                    displayName: "Groups",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.groupsList", "row.entity.name"),
	                    field: "groupsList"

	                }, {
	                    name: "Users",
	                    displayName: "Users",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.usersList", "row.entity.name"),
	                    field: "usersList"
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        }
	    });

	    return AdminSecurityPermissionsController;
	})();

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AdminSecurityPermissionsFormController = exports.AdminSecurityPermissionsFormController = (function () {
	    function AdminSecurityPermissionsFormController($scope, $state, $stateParams, $q, JFrogModal, JFrogGridFactory, RepoDataDao, PermissionsDao, commonGridColumns, User, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminSecurityPermissionsFormController);

	        this.$scope = $scope;
	        this.$q = $q;
	        this.repoDataDao = RepoDataDao;
	        this.commonGridColumns = commonGridColumns;
	        this.user = User.getCurrent();
	        this.modal = JFrogModal;
	        this.currentTab = "repo";
	        this.$state = $state;
	        this.title = "New Permission";
	        this.$stateParams = $stateParams;
	        this.permission = {};
	        this.permissionsDao = PermissionsDao.getInstance();
	        this.newPermission = false;
	        this.groupsGrid = [];
	        this.usersGrid = [];
	        this.selectedItems = [];
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.groupsGridOption = {};
	        this.usersGridOption = {};
	        this.TOOLTIP = TOOLTIP.admin.security.permissionsForm;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["permission"]);
	        this._createGroupsGrid();
	        this._createUsersGrid();
	        this.ArtifactoryModelSaver.save();
	        this.JFrogEventBus = JFrogEventBus;

	        this.dndComm = {};

	        this.initPermissionForm();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this._getAllRepos().then(function () {
	                _this.allRepos.forEach(function (repo) {
	                    if (!_.find(_this.permission.availableRepoKeys, { repoKey: repo.repoKey }) && !_.find(_this.permission.repoKeys, { repoKey: repo.repoKey })) {
	                        if (repo.type == "local" && _this.permission.anyLocal || repo.type == "remote" && _this.permission.anyRemote || repo.type == "distribution" && _this.permission.anyDistribution) {
	                            repo.__fixed__ = true;
	                            _this.permission.repoKeys.push(_this.getRepoWithIcon(repo));
	                        } else {
	                            _this.permission.availableRepoKeys.push(_this.getRepoWithIcon(repo));
	                        }
	                    }
	                });
	                _this.ArtifactoryModelSaver.save();
	            });
	        });
	    }

	    _createClass(AdminSecurityPermissionsFormController, {
	        initPermissionForm: {
	            value: function initPermissionForm() {
	                if (this.$stateParams.permission) {
	                    this.initUpdatePermissionForm(this.$stateParams.permission);
	                    this.title = "Edit " + this.$stateParams.permission + " Permission";
	                    this.newPermission = false;
	                } else {
	                    this.newPermission = true;
	                    this.title = "New Permission";
	                    this._initNewPermissionForm();
	                }
	            }
	        },
	        _getUsersAndGroups: {
	            value: function _getUsersAndGroups() {
	                var _this = this;

	                return this.permissionsDao.getAllUsersAndGroups().$promise.then(function (response) {
	                    _this.allUsersData = response.allUsers;
	                    _this.allGroupsData = response.allGroups;
	                    _this._filterAvailableUsers();
	                    _this._filterAvailableGroups();
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        formInvalid: {
	            value: function formInvalid() {
	                return this.savePending || this.form.$invalid || !this.permission.repoKeys || !this.permission.repoKeys.length;
	            }
	        },
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;

	                var deferred = this.$q.defer();

	                this.repoDataDao.getAllForPerms({ permission: true }).$promise.then(function (result) {
	                    _this.allRepos = result.repoTypesList;
	                    deferred.resolve();
	                });
	                return deferred.promise;
	            }
	        },
	        _initNewPermissionForm: {
	            value: function _initNewPermissionForm() {
	                var _this = this;

	                this.permission.anyLocal = false;
	                this.permission.anyRemote = false;

	                this.permission.includePatternArray = ["**"];
	                this.permission.excludePatternArray = [];

	                this.permission.availableRepoKeys = [];
	                this.permission.repoKeys = [];

	                this._getUsersAndGroups();
	                this._getAllRepos().then(function () {
	                    _this.permission.availableRepoKeys = _.map(_this.allRepos, function (repo) {
	                        return repo;
	                    });
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getRepoWithIcon: {
	            value: function getRepoWithIcon(repo) {
	                repo._iconClass = "icon " + (repo.type === "local" ? "icon-local-repo" : repo.type === "remote" ? "icon-remote-repo" : repo.type === "virtual" ? "icon-virtual-repo" : repo.type === "distribution" ? "icon-distribution-repo" : "icon-notif-error");
	                return repo;
	            }
	        },
	        initUpdatePermissionForm: {
	            value: function initUpdatePermissionForm(permission) {
	                var _this = this;

	                this.permissionsDao.getPermission({ name: permission }).$promise.then(function (result) {

	                    //console.log(result);
	                    _this.permission = result;

	                    _this.permission.repoKeys = _.map(_this.permission.repoKeys, function (repo) {
	                        repo.__fixed__ = repo.type === "local" && _this.permission.anyLocal || repo.type === "remote" && _this.permission.anyRemote || repo.type === "distribution" && _this.permission.anyDistribution;
	                        return _this.getRepoWithIcon(repo);
	                    });

	                    _this.permission.availableRepoKeys = _.map(_this.permission.availableRepoKeys, function (repo) {
	                        return _this.getRepoWithIcon(repo);
	                    });

	                    _this._getUsersAndGroups().then(function () {

	                        // Build a map of all users as: user => isAdmin
	                        var userAdminMap = _this.getEntityGroupMap(_this.allUsersData);
	                        // Get the users with admin icons and tooltips
	                        result.users = _this.getEntitiyGroupPermissionsList(result.users, userAdminMap);

	                        // Build a map of all groups as: group => is admin
	                        var groupAdminMap = _this.getEntityGroupMap(_this.allGroupsData);
	                        // Get the groups with admin icons and tooltips
	                        result.groups = _this.getEntitiyGroupPermissionsList(result.groups, groupAdminMap);

	                        _this.usersGridOption.setGridData(result.users);
	                        _this.groupsGridOption.setGridData(result.groups);

	                        _this.permission.includePatternArray = _this.permission.includePattern ? _this.permission.includePattern.split(",") : [];
	                        _this.permission.excludePatternArray = _this.permission.excludePattern ? _this.permission.excludePattern.split(",") : [];

	                        _this.ArtifactoryModelSaver.save();
	                    });
	                });
	            }
	        },
	        setCurrentTab: {

	            /**check and set current tab**/

	            value: function setCurrentTab(tab) {
	                this.currentTab = tab;
	            }
	        },
	        isCurrentTab: {
	            value: function isCurrentTab(tab) {
	                return this.currentTab === tab;
	            }
	        },
	        prevStep: {

	            /**
	             * button pre and  forwd at the bottom page**/

	            value: function prevStep() {
	                if (this.currentTab == "groups") {
	                    this.setCurrentTab("repo");
	                    return;
	                }
	                if (this.currentTab == "users") {
	                    this.setCurrentTab("groups");
	                    return;
	                }
	            }
	        },
	        fwdStep: {
	            value: function fwdStep() {
	                if (this.currentTab == "repo") {
	                    this.setCurrentTab("groups");
	                    return;
	                }
	                if (this.currentTab == "groups") {
	                    this.setCurrentTab("users");
	                    return;
	                }
	            }
	        },
	        addGroup: {
	            value: function addGroup(group) {
	                if (group.icon_class && group.icon_class.indexOf("admin") >= 0) {
	                    return;
	                }if (!this.permission.groups) {
	                    this.permission.groups = [];
	                }
	                this.permission.groups.push(group);
	                this.groupsGridOption.setGridData(this.permission.groups);
	                this._filterAvailableGroups();

	                /*
	                 if (group.name) {
	                 this.groups = _.remove(this.permission.groups, {name: group.name});
	                 this.groupsGrid.push({principal: group.name});
	                 }
	                 else {
	                 this.groups = _.remove(this.permission.groups, group);
	                 this.groupsGrid.push(group);
	                 }
	                  this.groupsGridOption.setGridData(this.groupsGrid);
	                 */
	            }
	        },
	        addUser: {
	            value: function addUser(user) {
	                if (user.icon_class && user.icon_class.indexOf("admin") >= 0) {
	                    return;
	                }if (!this.permission.users) {
	                    this.permission.users = [];
	                }
	                this.permission.users.push(user);
	                this.usersGridOption.setGridData(this.permission.users);
	                this._filterAvailableUsers();
	                /*
	                 if (user.name) {
	                 this.users = _.remove(this.permission.users, {name: user.name});
	                 this.usersGrid.push({principal: user.name});
	                 }
	                 else {
	                 this.users = _.remove(this.permission.users, user);
	                 this.usersGrid.push(user);
	                 }
	                 this.usersGridOption.setGridData(this.usersGrid);
	                 */
	            }
	        },
	        setAnyRepoOfType: {
	            value: function setAnyRepoOfType(type, isAnyRepoOfThisTypeCheckboxIsChecked) {
	                var _this = this;

	                if (isAnyRepoOfThisTypeCheckboxIsChecked) {
	                    this.permission.availableRepoKeys.forEach(function (repo) {
	                        if (repo.type == type) {
	                            repo.__fixed__ = true;
	                            if (!_.contains(_this.permission.repoKeys, repo)) {
	                                _this.permission.repoKeys.push(repo);
	                            }
	                        }
	                    });
	                    this.permission.repoKeys.forEach(function (repo) {
	                        if (repo.type == type) {
	                            repo.__fixed__ = true;
	                        }
	                    });
	                    _.remove(this.permission.availableRepoKeys, { type: type });
	                } else {
	                    this.permission.repoKeys.forEach(function (repo) {
	                        if (repo.type == type) {
	                            if (!_.contains(_this.permission.availableRepoKeys, repo)) {
	                                _this.permission.availableRepoKeys.push(repo);
	                            }
	                        }
	                    });
	                    _.remove(this.permission.repoKeys, { type: type });
	                }
	                this.dndComm.updateFilter();
	            }
	        },
	        _createGroupsGrid: {
	            value: function _createGroupsGrid() {
	                this.groupsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setMultiSelect().setColumns(this._getGroupsColumns()).setButtons(this._getGroupsActions()).setGridData([]).setBatchActions(this._getGroupsBatchActions());
	            }
	        },
	        _createUsersGrid: {
	            value: function _createUsersGrid() {
	                var _this = this;

	                this.usersGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setMultiSelect().setColumns(this._getUsersColumns()).setGridData([]).setButtons(this._getUsersActions()).setBatchActions(this._getUsersBatchActions());

	                this.usersGridOption.isRowSelectable = function (row) {
	                    return row.entity.principal !== _this.user.name;
	                };
	            }
	        },
	        _getUsersColumns: {
	            value: function _getUsersColumns() {
	                return [{
	                    name: "User",
	                    displayName: "User",
	                    field: "principal",
	                    cellTemplate: "<div class=\"principal-cell\">\n                                    <i ng-class=\"row.entity.icon_class ? row.entity.icon_class : 'icon-blank'\"\n                                       jf-tooltip=\"{{ ( row.entity.icon_class && row.entity.icon_class.indexOf('admin') >= 0 ) ? 'Admin Privlages' : row.entity.icon_tooltip}}\"\n                                       class=\"icon pull-left\"></i>\n                                       <span>{{row.entity.principal}}</span>\n                               </div>",
	                    width: "26%"
	                }, {
	                    name: "Manage",
	                    displayName: "Manage",
	                    field: "managed",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.managed", "row.entity.managed?row.entity.delete=row.entity.deploy=row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "12%"
	                }, {
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    field: "delete",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.delete", "row.entity.delete?row.entity.deploy=row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "20%"
	                }, {
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    field: "deploy",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.deploy", "row.entity.deploy?row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "20%"
	                }, {
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    field: "annotate",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.annotate", "row.entity.annotate?row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "12%"
	                }, {
	                    name: "Read",
	                    displayName: "Read",
	                    field: "read",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.read", null, "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "10%",
	                    minWidth: "100"
	                }];
	            }
	        },
	        _getGroupsColumns: {
	            value: function _getGroupsColumns() {
	                return [{
	                    name: "Group",
	                    displayName: "Group",
	                    field: "principal",
	                    cellTemplate: "<div class=\"principal-cell\">\n                                    <i ng-class=\"row.entity.icon_class ? row.entity.icon_class : 'icon-blank'\"\n                                       jf-tooltip=\"{{( row.entity.icon_class && row.entity.icon_class.indexOf('admin') >= 0 ) ? 'Admin Privlages' : row.entity.icon_tooltip}}\"\n                                       class=\"icon pull-left\"></i>\n                                       <span>{{row.entity.principal}}</span>\n                               </div>",
	                    width: "26%"
	                }, {
	                    name: "Manage",
	                    displayName: "Manage",
	                    field: "managed",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.managed", "row.entity.managed?row.entity.delete=row.entity.deploy=row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "12%"
	                }, {
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    field: "delete",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.delete", "row.entity.delete?row.entity.deploy=row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "20%"
	                }, {
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    field: "deploy",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.deploy", "row.entity.deploy?row.entity.annotate=row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "20%"
	                }, {
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    field: "annotate",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.annotate", "row.entity.annotate?row.entity.read=true:null", "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "12%"
	                }, {
	                    name: "Read",
	                    displayName: "Read",
	                    field: "read",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.read", null, "grid.appScope.PermissionForm.isDisable(row.entity)"),
	                    width: "10%",
	                    minWidth: "100"
	                }];
	            }
	        },
	        _getUsersBatchActions: {
	            value: function _getUsersBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Remove",
	                    callback: function () {
	                        return _this._deleteSelectedUsers();
	                    }
	                }];
	            }
	        },
	        _getGroupsBatchActions: {
	            value: function _getGroupsBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Remove",
	                    callback: function () {
	                        return _this._deleteSelectedGroups();
	                    }
	                }];
	            }
	        },
	        _deleteSelectedGroups: {
	            value: function _deleteSelectedGroups() {
	                var _this = this;

	                var self = this;
	                var selectedGroups = this.groupsGridOption.api.selection.getSelectedRows();
	                var confirmMessage = "Are you sure you wish to delete " + selectedGroups.length;

	                selectedGroups.forEach(function (group) {
	                    _.remove(_this.permission.groups, group);
	                });
	                this.groupsGridOption.setGridData(this.permission.groups);
	                this._filterAvailableGroups();
	            }
	        },
	        _deleteSelectedUsers: {
	            value: function _deleteSelectedUsers() {
	                var _this = this;

	                var selectedUsers = this.usersGridOption.api.selection.getSelectedRows();
	                selectedUsers.forEach(function (user) {
	                    _.remove(_this.permission.users, user);
	                });
	                this.usersGridOption.setGridData(this.permission.users);
	                this._filterAvailableUsers();
	            }
	        },
	        _getGroupsActions: {
	            value: function _getGroupsActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Remove",
	                    callback: function (row) {
	                        return _this._deleteGroup(row);
	                    }
	                }];
	            }
	        },
	        _deleteGroup: {
	            value: function _deleteGroup(row) {
	                _.remove(this.permission.groups, row);
	                this.groupsGridOption.setGridData(this.permission.groups);
	                this._filterAvailableGroups();
	            }
	        },
	        _getUsersActions: {
	            value: function _getUsersActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Remove",
	                    callback: function (row) {
	                        return _this._deleteUser(row);
	                    } }];
	            }
	        },
	        _deleteUser: {
	            value: function _deleteUser(row) {
	                //    this.modal.confirm('Are you sure you wish to delete this user?')
	                //      .then(()=> {
	                _.remove(this.permission.users, row);
	                this.usersGridOption.setGridData(this.permission.users);

	                this._filterAvailableUsers();

	                /*
	                 _.remove(this.usersGrid, row);
	                 this.permission.users.push(row);
	                 this.usersGridOption.setGridData(this.usersGrid);
	                 */
	                //    });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }

	                this.savePending = true;

	                this.permission.includePattern = this.permission.includePatternArray.join(",") || "";
	                this.permission.excludePattern = this.permission.excludePatternArray.join(",") || "";

	                if (this.newPermission) {
	                    this.permissionsDao.create(this.permission).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.permissions");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else {
	                    this.permissionsDao.update(this.permission).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.permissions");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        isDisableRepositories: {
	            value: function isDisableRepositories() {
	                return !this.user.isAdmin() && !this.newPermission;
	            }
	        },
	        isDisable: {
	            value: function isDisable(row) {
	                return row.icon_class === "icon-admin-new";
	            }
	        },
	        isDisableManager: {
	            value: function isDisableManager(row) {
	                return row.principal === this.user.name;
	            }
	        },
	        _filterAvailableGroups: {
	            value: function _filterAvailableGroups() {
	                var _this = this;

	                var availableGroups = _.filter(this.allGroupsData, function (group) {
	                    return _.findWhere(_this.permission.groups, { principal: group.principal }) === undefined;
	                });

	                this.availableGroups = this.getEntitiyGroupPermissionsList(availableGroups);
	            }
	        },
	        _filterAvailableUsers: {
	            value: function _filterAvailableUsers() {
	                var _this = this;

	                var availableUsers = _.filter(this.allUsersData, function (user) {
	                    return _.findWhere(_this.permission.users, { principal: user.principal }) === undefined;
	                });

	                this.availableUsers = this.getEntitiyGroupPermissionsList(availableUsers);
	            }
	        },
	        getEntityGroupMap: {

	            /**
	            *   Build a map of an entity group as following: entityName => isAdmin
	             */

	            value: function getEntityGroupMap(allEntitysData) {
	                var entityAdminMap = allEntitysData.map(function (entity) {
	                    return [entity.principal, entity.admin];
	                });
	                return new Map(entityAdminMap);
	            }
	        },
	        getEntitiyGroupPermissionsList: {

	            /**
	             *  Get an entity group permissions array
	             * */

	            value: function getEntitiyGroupPermissionsList(entities, isAdminMap) {
	                var _this = this;

	                return _.map(entities, function (entity) {
	                    return _this.getEntityPermissionObject(entity, isAdminMap);
	                });
	            }
	        },
	        getEntityPermissionObject: {

	            /**
	            *  Get an entity's permission object
	            * */

	            value: function getEntityPermissionObject(entity, isAdminMap) {
	                var isAdmin = isAdminMap && isAdminMap.get(entity.principal) || entity.admin;
	                return {
	                    name: entity.principal || entity.name || "",
	                    principal: entity.principal || entity.name || "",
	                    icon_class: isAdmin ? "icon-admin-new" : "icon-blank",
	                    icon_tooltip: isAdmin ? "Users with admin privileges cannot be added to a Permission Target" : "",
	                    annotate: entity.annotate || false,
	                    "delete": entity["delete"] || false,
	                    deploy: entity.deploy || false,
	                    managed: entity.managed || false,
	                    read: entity.read || false,
	                    clickable: !isAdmin,
	                    mask: entity.mask || 31
	                };
	            }
	        }
	    });

	    return AdminSecurityPermissionsFormController;
	})();

	// visibleWhen: row => row.principal !== this.user.name

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityUserController = __webpack_require__(246).AdminSecurityUserController;

	var AdminSecurityUserFormController = __webpack_require__(247).AdminSecurityUserFormController;

	function usersConfig($stateProvider) {

	    $stateProvider.state("admin.security.users", {
	        url: "/users",
	        templateUrl: "states/admin/security/users/users.html",
	        controller: "AdminSecurityUserController as AdminSecurityUser"
	    }).state("admin.security.users.edit", {
	        parent: "admin.security",
	        url: "/users/{username}/edit",
	        templateUrl: "states/admin/security/users/user_form.html",
	        controller: "AdminSecurityUserFormController as UserForm"
	    }).state("admin.security.users.new", {
	        parent: "admin.security",
	        url: "/users/new",
	        templateUrl: "states/admin/security/users/user_form.html",
	        controller: "AdminSecurityUserFormController as UserForm"
	    });
	}

	module.exports = angular.module("security.users", []).config(usersConfig).controller("AdminSecurityUserController", AdminSecurityUserController).controller("AdminSecurityUserFormController", AdminSecurityUserFormController);

/***/ }),
/* 246 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminSecurityUserController = exports.AdminSecurityUserController = (function () {
	    function AdminSecurityUserController($state, JFrogModal, UserDao, $scope, GroupsDao, JFrogGridFactory, uiGridConstants, AdminSecurityGeneralDao, commonGridColumns) {
	        _classCallCheck(this, AdminSecurityUserController);

	        this.userDao = UserDao.getInstance();
	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.uiGridConstants = uiGridConstants;
	        this.groupsDao = GroupsDao.getInstance();
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.$scope = $scope;
	        this.$state = $state;
	        this._createGrid();
	        this._initUsers();
	    }

	    _createClass(AdminSecurityUserController, {
	        _initUsers: {
	            value: function _initUsers() {
	                var _this = this;

	                this.userDao.getAll().$promise.then(function (users) {
	                    //console.log(users);
	                    users.forEach(function (user) {
	                        user.permissions = _.pluck(user.permissionsList, "permissionName");
	                        user.effectiveAdmin = user.admin || user.groupAdmin;
	                    });
	                    _this.gridOption.setGridData(users);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setMultiSelect().setButtons(this._getActions()).setRowTemplate("default").setBatchActions(this._getBatchActions());

	                this.gridOption.isRowSelectable = function (row) {
	                    return row.entity.name !== "anonymous";
	                };
	            }
	        },
	        deleteUser: {
	            value: function deleteUser(user) {
	                var _this = this;

	                var json = { userNames: [user.name] };
	                this.modal.confirm("Are you sure you want to delete user '" + user.name + "?'").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this._initUsers();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                // Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                // Create an array of the selected users names
	                var names = _.map(selectedRows, function (user) {
	                    return user.name;
	                });
	                // Create Json for the bulk request
	                var json = { userNames: names };
	                // console.log('Bulk delete....');
	                // Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to delete " + names.length + " users?").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this._initUsers();
	                    });
	                });
	            }
	        },
	        updateUser: {
	            value: function updateUser(user) {
	                var _this = this;

	                this.userDao.update(user).$promise.then(function () {
	                    return _this._initUsers();
	                });
	            }
	        },
	        checkExternalStatus: {
	            value: function checkExternalStatus(user) {
	                this.userDao.checkExternalStatus(user).$promise.then(function (dataRes) {
	                    //            console.log(dataRes);
	                    user.externalRealmStatus = dataRes.data.externalRealmStatus;
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.users.edit({username: row.entity.name})\"><a href=\"\">{{row.entity.name}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "33%"
	                    //width: '15%'
	                }, {
	                    name: "Email",
	                    displayName: "Email",
	                    field: "email",
	                    width: "15%"
	                }, {
	                    name: "Realm",
	                    displayName: "Realm",
	                    field: "realm",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.realm}}" + "<span ng-if=\"row.entity.externalRealmStatus\"> | {{row.entity.externalRealmStatus}}</span>" + "<span ng-if=\"!row.entity.externalRealmStatus && row.entity.externalRealmLink\"> | <a href=\"\" ng-click=\"grid.appScope.AdminSecurityUser.checkExternalStatus(row.entity)\">{{row.entity.externalRealmLink}}</a></span></div>",
	                    width: "10%"
	                }, {
	                    field: "groups",
	                    name: "Related Groups",
	                    displayName: "Related Groups",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.groups", "row.entity.name"),
	                    width: "18%"
	                }, /*
	                   {
	                     field: "permissions",
	                     name: "Related Permissions",
	                     displayName: "Related Permissions",
	                     cellTemplate: this.commonGridColumns.listableColumn('row.entity.permissions','row.entity.name'),
	                     width: '18%'
	                   },*/
	                {
	                    name: "Admin",
	                    displayName: "Admin",
	                    field: "admin",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectiveAdmin"),
	                    width: "7%"
	                }, {
	                    name: "Lock",
	                    displayName: "Locked",
	                    field: "locked",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-lock\" ng-if=\"row.entity.locked\" cm-aditional-action=\"Unlock\" ng-click=\"grid.appScope.AdminSecurityUser.unlockUsers(row.entity.name)\" jf-tooltip=\"Unlock\"></a></div>",
	                    width: "7%"
	                }, {
	                    field: "lastLoggedInMillis",
	                    name: "Last Login",
	                    displayName: "Last Login",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.lastLoggedIn}}</div>",
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteUser(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.name != "anonymous";
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }, {
	                    icon: "unlock",
	                    name: "Unlock",
	                    callback: function () {
	                        return _this.bulkUnlock();
	                    },
	                    disabledWhen: function () {
	                        return !_this.hasSelectedUnlockedUsers();
	                    }
	                }];
	            }
	        },
	        unlockUsers: {
	            value: function unlockUsers(users) {
	                var _this = this;

	                if (!_.isArray(users)) users = [users];

	                this.adminSecurityGeneralDao.unlockUsers({}, users).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this._initUsers();
	                    }
	                });
	            }
	        },
	        hasSelectedUnlockedUsers: {
	            value: function hasSelectedUnlockedUsers() {
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                return _.findWhere(selectedRows, { locked: true });
	            }
	        },
	        bulkUnlock: {
	            value: function bulkUnlock() {
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                var locked = _.filter(selectedRows, function (row) {
	                    return row.locked;
	                });
	                var names = _.pluck(locked, "name");
	                this.unlockUsers(names);
	            }
	        }
	    });

	    return AdminSecurityUserController;
	})();

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var ACTIONS = _interopRequire(__webpack_require__(248));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminSecurityUserFormController = exports.AdminSecurityUserFormController = (function () {
	    function AdminSecurityUserFormController($scope, $state, $stateParams, $timeout, $q, JFrogGridFactory, UserDao, GroupsDao, GroupPermissionsDao, AdminSecurityGeneralDao, User, uiGridConstants, commonGridColumns, ArtifactoryModelSaver, RepositoriesDao, UserProfileDao, JFrogModal, JFrogNotifications, ArtifactoryState) {
	        _classCallCheck(this, AdminSecurityUserFormController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.User = User;
	        this.repositoriesDao = RepositoriesDao;
	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.modal = JFrogModal;
	        this.userDao = UserDao.getInstance();
	        this.groupsDao = GroupsDao.getInstance();
	        this.groupPermissionsDao = GroupPermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["userdata", "input"], ["locked"]);
	        this.permissionsGridOptions = {};
	        this.userProfileDao = UserProfileDao;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.TOOLTIP = TOOLTIP.admin.security.usersForm;
	        this.MESSAGES = MESSAGES.admin.security.users.userForm;
	        this.input = {};
	        this.artifactoryState = ArtifactoryState;
	        this.emailChanged = false;
	        this.setDisabledChecked = true;
	        this.passwordRank = 0;
	        this.lastSavedUserSettings = {};

	        this._getPasswordExpirationState();

	        if ($stateParams.username) {
	            this.mode = "edit";
	            this.username = $stateParams.username;
	            this.title = "Edit " + this.username + " User";
	            this._getUserData();
	        } else {
	            this.mode = "create";
	            this.title = "Add New User";
	            this.userdata = {
	                groups: [],
	                profileUpdatable: true,
	                disableUIAccess: false,
	                internalPasswordDisabled: false
	            };
	            this.saveCheckboxes();
	        }
	        this._createGrid();
	        this._getAllRepos();
	        this._getAllGroups();
	    }

	    _createClass(AdminSecurityUserFormController, {
	        userIsEffectiveAdmin: {
	            value: function userIsEffectiveAdmin() {
	                return this.userdata.admin || this.isInAdminGroup;
	            }
	        },
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;

	                this.reposData = {};
	                this.repositoriesDao.getRepositories({ type: "local" }).$promise.then(function (data) {
	                    _this.reposData.locals = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "remote" }).$promise.then(function (data) {
	                    _this.reposData.remotes = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.permissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getPermissionCloumns()).setRowTemplate("default");
	            }
	        },
	        _getAllGroups: {
	            value: function _getAllGroups() {
	                var _this = this;

	                this.userDao.getAllGroups().$promise.then(function (data) {
	                    _this.groupsData = data;
	                    _this.groupsList = _.map(_this.groupsData, function (group) {
	                        if (group.autoJoin && _this.mode === "create") {
	                            _this.userdata.groups.push(group.groupName);
	                            _this.ArtifactoryModelSaver.save();
	                        }
	                        return group.groupName;
	                    });
	                    if (_this.mode === "create") {
	                        _this._getGroupsPermissions();
	                    }

	                    _this.groupDndTemplate = "<div style=\"min-width:200px\">\n                                        {{getItemInfo().text}}\n                                        <i ng-if=\"userScope.UserForm.groupIsAdmin(getItemInfo().text)\" \n                                           jf-tooltip=\"Admin Privileges\"\n                                           class=\"icon icon-admin-new pull-left\"></i>\n                                        <i ng-if=\"!userScope.UserForm.groupIsAdmin(getItemInfo().text)\" \n                                            class=\"icon icon-blank pull-left\"></i>\n                                    </div>";
	                });
	            }
	        },
	        _getUserPermissions: {
	            value: function _getUserPermissions() {
	                var _this = this;

	                this.userDao.getPermissions({ userOnly: true }, { name: this.username }).$promise.then(function (data) {
	                    _this.userPermissions = data;
	                    _this._setGridData();
	                });
	            }
	        },
	        _getGroupsPermissions: {
	            value: function _getGroupsPermissions() {
	                var _this = this;

	                if (!this.userdata) {
	                    return;
	                }if (!this.userdata.groups || !this.userdata.groups.length) {
	                    this.groupsPermissions = [];
	                    if (this.mode === "create") {
	                        this.permissionsGridOptions.setGridData(this.groupsPermissions);
	                    } else if (this.userPermissions) {
	                        this._setGridData();
	                    }
	                } else {
	                    this.groupPermissionsDao.get({ groups: this.userdata.groups }).$promise.then(function (data) {
	                        _this.groupsPermissions = data;
	                        if (_this.mode === "create") {
	                            _this.permissionsGridOptions.setGridData(_this.groupsPermissions);
	                        } else if (_this.userPermissions) {
	                            _this._setGridData();
	                        }
	                    });
	                }
	            }
	        },
	        _setGridData: {
	            value: function _setGridData() {
	                var _this = this;

	                var data = [];
	                if (this.groupsPermissions) {
	                    data = data.concat(this.groupsPermissions);
	                }
	                if (this.userPermissions) {
	                    data = data.concat(this.userPermissions);
	                }
	                this._fixDataFormat(data).then(function (fixedData) {
	                    _this.permissionsGridOptions.setGridData(fixedData);
	                });
	            }
	        },
	        _fixDataFormat: {
	            value: function _fixDataFormat(data) {
	                var _this = this;

	                var defer = arguments[1] === undefined ? null : arguments[1];

	                var defer = defer || this.$q.defer();
	                if (this.reposData.locals && this.reposData.remotes) {
	                    data.forEach(function (record) {
	                        if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY LOCAL") {
	                            record.repoKeysView = "ANY LOCAL";
	                            record.reposList = angular.copy(_this.reposData.locals);
	                        } else if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY REMOTE") {
	                            record.repoKeysView = "ANY REMOTE";
	                            record.reposList = angular.copy(_this.reposData.remotes);
	                        } else if (record.repoKeys.length === 1 && record.repoKeys[0] === "ANY") {
	                            record.repoKeysView = "ANY";
	                            record.reposList = angular.copy(_this.reposData.remotes).concat(_this.reposData.locals);
	                        } else {
	                            record.repoKeysView = record.repoKeys.join(", ");
	                            record.reposList = angular.copy(record.repoKeys);
	                        }
	                    });
	                    defer.resolve(data);
	                } else {
	                    this.$timeout(function () {
	                        _this._fixDataFormat(data, defer);
	                    });
	                }
	                return defer.promise;
	            }
	        },
	        _getUserData: {
	            value: function _getUserData() {
	                var _this = this;

	                this._getUserPermissions();
	                this.userDao.getSingle({ name: this.username }).$promise.then(function (data) {
	                    _this.userdata = data.data;
	                    _this.isInAdminGroup = _this.userdata.groupAdmin;

	                    if (_this.userdata.internalPasswordDisabled) {
	                        _this.passwordOriginalyDisabled = true;
	                    }
	                    if (!_this.userdata.groups) {
	                        _this.userdata.groups = [];
	                    } else {
	                        _this._getGroupsPermissions();
	                    }
	                    _this.saveCheckboxes();
	                    _this.ArtifactoryModelSaver.save();
	                });
	                this._getApiKeyState();
	            }
	        },
	        _getApiKeyState: {
	            value: function _getApiKeyState() {
	                var _this = this;

	                this.userProfileDao.getApiKey({}, { username: this.username }).$promise.then(function (res) {
	                    _this.apiKeyExist = !!res.apiKey;
	                });
	            }
	        },
	        _fixGroups: {
	            value: function _fixGroups(userdata) {
	                var _this = this;

	                var groups = userdata.groups;
	                var groupsObjects = [];
	                groups.forEach(function (group) {
	                    var realm = _.findWhere(_this.groupsData, { groupName: group }).realm;
	                    groupsObjects.push({ groupName: group, realm: realm });
	                });
	                delete userdata.groups;
	                userdata.userGroups = groupsObjects;
	            }
	        },
	        onEmailChanged: {
	            value: function onEmailChanged() {
	                this.emailChanged = true;
	            }
	        },
	        updateUser: {
	            value: function updateUser() {
	                var _this = this;

	                var payload = angular.copy(this.userdata);
	                _.extend(payload, this.input);
	                this._fixGroups(payload);
	                this.userDao.update({ name: this.userdata.name }, payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    if (_this.userdata.name === _this.User.currentUser.name) {
	                        if (_this.emailChanged) {
	                            _this.artifactoryState.removeState("setMeUpUserData");
	                        }
	                        _this.User.reload();
	                    }
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.users");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        createNewUser: {
	            value: function createNewUser() {
	                var _this = this;

	                var payload = angular.copy(this.userdata);
	                _.extend(payload, this.input);
	                this._fixGroups(payload);
	                this.userDao.create(payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.users");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                if (this.mode == "edit") this.updateUser();
	                if (this.mode == "create") this.createNewUser();
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.users");
	            }
	        },
	        deleteUser: {
	            value: function deleteUser() {
	                var _this = this;

	                var json = { userNames: [this.username] };
	                this.modal.confirm("Are you sure you want to delete user '" + this.username + "?'").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this.cancel();
	                    });
	                });
	            }
	        },
	        userIsInAdminGroup: {
	            value: function userIsInAdminGroup() {
	                var groups = this.userdata.groups;
	                var groupsData = this.groupsData;
	                for (var i in groups) {
	                    for (var j = 0; j < groupsData.length; j++) {
	                        if (groupsData[j].name === groups[i] && groupsData[j].adminPrivileges) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            }
	        },
	        groupIsAdmin: {
	            value: function groupIsAdmin(group) {
	                return _.find(this.groupsData, { groupName: group, adminPrivileges: true });
	            }
	        },
	        onCheckboxChanged: {
	            value: function onCheckboxChanged() {
	                this.saveCheckboxes();
	            }
	        },
	        saveCheckboxes: {
	            value: function saveCheckboxes() {
	                this.lastSavedUserSettings = {
	                    disableUIAccess: this.userdata.disableUIAccess,
	                    profileUpdatable: this.userdata.profileUpdatable,
	                    internalPasswordDisabled: this.userdata.internalPasswordDisabled };
	            }
	        },
	        onChangeGroups: {
	            value: function onChangeGroups() {
	                var _this = this;

	                this.userPermissions = undefined;
	                this.groupsPermissions = undefined;
	                this._getGroupsPermissions();
	                if (this.mode === "edit") this._getUserPermissions();
	                this.$timeout(function () {
	                    _this.isInAdminGroup = _this.userIsInAdminGroup();
	                    // Save last user settings before making changes
	                    if (_this.isInAdminGroup || _this.userdata.admin) {
	                        _this.userdata.disableUIAccess = false;
	                        _this.userdata.profileUpdatable = true;
	                        _this.userdata.internalPasswordDisabled = false;
	                    } else {
	                        _this.userdata.disableUIAccess = _this.lastSavedUserSettings.disableUIAccess;
	                        _this.userdata.profileUpdatable = _this.lastSavedUserSettings.profileUpdatable;
	                        _this.userdata.internalPasswordDisabled = _this.lastSavedUserSettings.internalPasswordDisabled;
	                    }
	                });
	            }
	        },
	        onClickAdmin: {
	            value: function onClickAdmin() {
	                if (this.userdata.admin) {
	                    this.userdata.profileUpdatable = true;
	                    this.userdata.internalPasswordDisabled = false;
	                    this.userdata.disableUIAccess = false;
	                }
	            }
	        },
	        _getPermissionCloumns: {
	            value: function _getPermissionCloumns() {

	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";

	                return [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: nameCellTemplate,
	                    width: "16%"
	                }, {
	                    field: "effectivePermission.principal",
	                    name: "Applied To",
	                    displayName: "Applied To",
	                    width: "13%"
	                }, {
	                    field: "repoKeys",
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.reposList", "row.entity.permissionName", "row.entity.repoKeysView", true),
	                    width: "16%"

	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    width: "14%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "8%"
	                }];
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.userForm || this.userForm.$invalid || (this.input.password || this.input.retypePassword) && this.input.password !== this.input.retypePassword;
	            }
	        },
	        checkPwdMatch: {
	            value: function checkPwdMatch(retypeVal) {
	                return !retypeVal || retypeVal && this.input.password === retypeVal;
	            }
	        },
	        isAnonymous: {
	            value: function isAnonymous() {
	                return this.userdata.name === "anonymous";
	            }
	        },
	        revokeApiKey: {
	            value: function revokeApiKey() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to revoke API key for user '" + this.username + "'?").then(function () {
	                    _this.userProfileDao.revokeApiKey({}, { username: _this.username }).$promise.then(function () {
	                        _this._getApiKeyState();
	                    });
	                });
	            }
	        },
	        unlockUser: {
	            value: function unlockUser() {
	                var _this = this;

	                this.adminSecurityGeneralDao.unlockUsers({}, [this.username]).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this.userdata.locked = false;
	                    }
	                });
	            }
	        },
	        expirePassword: {
	            value: function expirePassword() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to expire this user's password?").then(function () {
	                    _this.userDao.expirePassword({}, { username: _this.username }).$promise.then(function () {
	                        _this._getUserData();
	                    });
	                });
	            }
	        },
	        unexpirePassword: {
	            value: function unexpirePassword() {
	                var _this = this;

	                this.userDao.unExpirePassword({}, { username: this.username }).$promise.then(function () {
	                    _this._getUserData();
	                });
	            }
	        },
	        _getPasswordExpirationState: {
	            value: function _getPasswordExpirationState() {
	                var _this = this;

	                this.adminSecurityGeneralDao.get().$promise.then(function (data) {
	                    _this.passwordExpirationEnabled = data.passwordSettings.expirationPolicy.enabled;
	                    _this.userLockEnabled = data.userLockPolicy.enabled;
	                });
	            }
	        },
	        clearPasswordFields: {
	            value: function clearPasswordFields() {
	                delete this.input.password;
	                delete this.input.retypePassword;
	            }
	        },
	        onChangePasswordDisabled: {
	            value: function onChangePasswordDisabled() {
	                if (this.userdata.internalPasswordDisabled) {
	                    this.changePassword = false;
	                    this.clearPasswordFields();
	                    this.passwordReEnabled = false;
	                } else {
	                    if (this.passwordOriginalyDisabled) {
	                        this.passwordReEnabled = true;
	                    }
	                }
	                this.onCheckboxChanged();
	            }
	        },
	        initActions: {
	            value: function initActions(actionsController) {
	                var _this = this;

	                this.actionsController = actionsController;
	                actionsController.setActionsDictionary(ACTIONS);
	                actionsController.setActions([{
	                    name: "RevokeApiKey",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.apiKeyExist && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.revokeApiKey();
	                    }
	                }, {
	                    name: "UnlockUser",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.userdata.locked && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.unlockUser();
	                    }
	                }, {
	                    name: "ExpirePassword",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.passwordExpirationEnabled && _this.mode === "edit" && !_this.userdata.credentialsExpired && (_this.userdata.realm === "internal" || !_this.userdata.realm) && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.expirePassword();
	                    }
	                }, {
	                    name: "UnexpirePassword",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.userdata.credentialsExpired && !_this.userdata.locked && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.unexpirePassword();
	                    }
	                }, {
	                    name: "DeleteUser",
	                    visibleWhen: function () {
	                        return _this.mode === "edit" && _this.userdata && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.deleteUser();
	                    }
	                }]);
	            }
	        },
	        checkUserName: {

	            // Validations

	            value: function checkUserName(value) {
	                return !/[A-Z]/.test(value);
	            }
	        }
	    });

	    return AdminSecurityUserFormController;
	})();

/***/ }),
/* 248 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    RevokeApiKey: { title: "Revoke Api Key", icon: "icon-revoke-api" },
	    UnlockUser: { title: "Unlock User", icon: "icon-unlock" },
	    ExpirePassword: { title: "Expire Password", icon: "icon-expire" },
	    UnexpirePassword: { title: "Unexpire Password", icon: "icon-unexpire" },
	    DeleteUser: { title: "Delete User", icon: "icon-clear" }
	};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecuritySamlIntegrationController = __webpack_require__(250).AdminSecuritySamlIntegrationController;

	function samlIntegrationConfig($stateProvider) {

	    $stateProvider.state("admin.security.saml_integration", {
	        params: { feature: "samlsso" },
	        url: "/saml_integration",
	        templateUrl: "states/admin/security/saml_integration/saml_integration.html",
	        controller: "AdminSecuritySamlIntegrationController as AdminSecuritySamlIntegration"
	    });
	}

	module.exports = angular.module("security.saml_integration", []).config(samlIntegrationConfig).controller("AdminSecuritySamlIntegrationController", AdminSecuritySamlIntegrationController);

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecuritySamlIntegrationController = exports.AdminSecuritySamlIntegrationController = (function () {
	    function AdminSecuritySamlIntegrationController(SamlDao, ArtifactoryModelSaver, JFrogEventBus) {
	        _classCallCheck(this, AdminSecuritySamlIntegrationController);

	        this.samlDao = SamlDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.security.SAMLSSOSettings;
	        this.artifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["saml"]);
	        this.artifactoryEventBus = JFrogEventBus;
	        this._init();
	    }

	    _createClass(AdminSecuritySamlIntegrationController, {
	        _init: {
	            value: function _init() {
	                var _this = this;

	                this.samlDao.get().$promise.then(function (data) {
	                    _this.saml = data;
	                    if (!angular.isDefined(_this.saml.noAutoUserCreation)) {
	                        _this.saml.noAutoUserCreation = true;
	                    }
	                    _this.artifactoryModelSaver.save();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                this.samlDao.update(this.saml).$promise.then(function () {
	                    _this.artifactoryModelSaver.save();
	                    _this.artifactoryEventBus.dispatch(EVENTS.FOOTER_DATA_UPDATED);
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.artifactoryModelSaver.ask(true).then(function () {
	                    _this._init();
	                });
	            }
	        },
	        canSave: {
	            value: function canSave() {
	                return this.samlForm.$valid;
	            }
	        }
	    });

	    return AdminSecuritySamlIntegrationController;
	})();

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var CrowdIntegrationController = __webpack_require__(252).CrowdIntegrationController;

	function crowdIntegrationConfig($stateProvider) {

	    $stateProvider.state("admin.security.crowd_integration", {
	        params: { feature: "crowd" },
	        url: "/crowd_integration",
	        templateUrl: "states/admin/security/crowd_integration/crowd_integration.html",
	        controller: "CrowdIntegrationController as Crowd"
	    });
	}

	module.exports = angular.module("security.crowd_integration", []).config(crowdIntegrationConfig).controller("CrowdIntegrationController", CrowdIntegrationController);

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var CrowdIntegrationController = exports.CrowdIntegrationController = (function () {
	    function CrowdIntegrationController($scope, CrowdIntegrationDao, JFrogGridFactory, commonGridColumns, uiGridConstants, ArtifactoryModelSaver) {
	        _classCallCheck(this, CrowdIntegrationController);

	        this.crowdIntegrationDao = CrowdIntegrationDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.crowdGroupsOptions = null;
	        this.crowd = {};
	        this.groupsData = [];
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["crowd"]);
	        this._createGrid();
	        this.crowdGroupsError = null;
	        this.batchActions = this._getBatchActions();
	        this.initCrowd();
	        this.usernameFilter = "";
	        this.filterType = "User Name";
	        this.TOOLTIP = TOOLTIP.admin.security.crowd_integration;
	        this.connectionMethod = "Crowd";
	    }

	    _createClass(CrowdIntegrationController, {
	        importCrowd: {
	            value: function importCrowd(row) {
	                var _this = this;

	                row.importIntoArtifactory = true;
	                this.crowdIntegrationDao["import"]({
	                    action: "import"
	                }, [row]).$promise.then(function (data) {
	                    _this.initCrowd();
	                });
	            }
	        },
	        importCrowds: {
	            value: function importCrowds() {
	                var _this = this;

	                var selectedCrowds = this.crowdGroupsOptions.api.selection.getSelectedRows();
	                selectedCrowds.forEach(function (row) {
	                    row.importIntoArtifactory = true;
	                });
	                this.crowdIntegrationDao["import"]({
	                    action: "import"
	                }, selectedCrowds).$promise.then(function (data) {
	                    _this.initCrowd();
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "import",
	                    name: "Import",
	                    callback: function () {
	                        return _this.importCrowds();
	                    }
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-import",
	                    tooltip: "Import",
	                    callback: function (row) {
	                        return _this.importCrowd(row);
	                    }
	                }];
	            }
	        },
	        initCrowd: {
	            value: function initCrowd() {
	                var _this = this;

	                this.loadFromServer().then(function () {
	                    if (!_this.initialized) {
	                        _this.initialized = true;
	                    } else _this.getCrowdGroups();
	                });
	            }
	        },
	        loadFromServer: {
	            value: function loadFromServer() {
	                var _this = this;

	                var retainEnabled = arguments[0] === undefined ? false : arguments[0];

	                return this.crowdIntegrationDao.get().$promise.then(function (data) {
	                    // Keep enabled
	                    if (retainEnabled && _this.crowd) data.enableIntegration = _this.crowd.enableIntegration;
	                    _this.connectionMethod = data.directAuthentication ? "JIRA" : "Crowd";
	                    _this.crowd = data;
	                    if (!retainEnabled) _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getCrowdGroups: {
	            value: function getCrowdGroups() {
	                var _this = this;

	                if (this.crowd.enableIntegration && this.crowd.serverUrl && this.crowd.applicationName) {
	                    this.crowdIntegrationDao.refresh({ name: this.usernameFilter }, {
	                        serverUrl: this.crowd.serverUrl,
	                        applicationName: this.crowd.applicationName,
	                        enableIntegration: this.crowd.enableIntegration,
	                        noAutoUserCreation: this.crowd.noAutoUserCreation,
	                        useDefaultProxy: this.crowd.useDefaultProxy,
	                        directAuthentication: this.crowd.directAuthentication,
	                        sessionValidationInterval: this.crowd.sessionValidationInterval,
	                        password: this.crowd.password
	                    }).$promise.then(function (result) {
	                        _this.groupsData = result.data.crowdGroupModels;
	                        _this.crowdGroupsOptions.setGridData(_this.groupsData);
	                    })["catch"](function (result) {
	                        console.log("exception");
	                        _this.crowdGroupsError = result.data.error;
	                        _this.crowdGroupsOptions.setGridData([]);
	                    });
	                } else {
	                    this.crowdGroupsError = null;
	                    if (this.crowdGroupsOptions) this.crowdGroupsOptions.setGridData([]);
	                }
	            }
	        },
	        changeFilter: {
	            value: function changeFilter() {
	                this.usernameFilter = "";
	                this.getCrowdGroups();
	            }
	        },
	        isFilteringBy: {
	            value: function isFilteringBy(filterType) {
	                return this.filterType == filterType;
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.crowdGroupsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(this._getBatchActions()).setButtons(this._getActions()).setGridData(this.groupsData);
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    field: "groupName",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "45%"
	                }, {
	                    name: "Description",
	                    displayName: "Description",
	                    field: "description",
	                    width: "45%"
	                }, {
	                    name: "Synced",
	                    displayName: "Synced",
	                    field: "existsInArtifactory",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.existsInArtifactory"),
	                    width: "10%"
	                } /*,
	                  {
	                     name: 'Import',
	                     field: 'importIntoArtifactory'
	                  }*/
	                ];
	            }
	        },
	        saveCrowd: {
	            value: function saveCrowd() {
	                var _this = this;

	                this.crowd.directAuthentication = this.connectionMethod === "JIRA";
	                this.crowdIntegrationDao.update(this.crowd).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.getCrowdGroups();
	                });
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.initCrowd();
	                });
	            }
	        },
	        testCrowd: {
	            value: function testCrowd() {
	                this.crowd.directAuthentication = this.connectionMethod === "JIRA";
	                this.crowd.action = "test";
	                this.crowdIntegrationDao.test({
	                    action: "test",
	                    serverUrl: this.crowd.serverUrl,
	                    applicationName: this.crowd.applicationName,
	                    enableIntegration: this.crowd.enableIntegration,
	                    noAutoUserCreation: this.crowd.noAutoUserCreation,
	                    useDefaultProxy: this.crowd.useDefaultProxy,
	                    directAuthentication: this.directAuthentication,
	                    sessionValidationInterval: this.crowd.sessionValidationInterval,
	                    password: this.crowd.password

	                }).$promise.then(function (data) {});
	            }
	        }
	    });

	    return CrowdIntegrationController;
	})();

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminSecurityOAuthController = __webpack_require__(254).AdminSecurityOAuthController;

	var AdminSecurityOAuthProviderFormController = __webpack_require__(255).AdminSecurityOAuthProviderFormController;

	function oauthConfig($stateProvider) {

	    $stateProvider.state("admin.security.oauth", {
	        params: { feature: "oauthsso" },
	        url: "/oauth",
	        templateUrl: "states/admin/security/oauth/oauth.html",
	        controller: "AdminSecurityOAuthController as AdminSecurityOAuth"
	    }).state("admin.security.oauth.edit", {
	        params: { feature: "oauthsso" },
	        parent: "admin.security",
	        url: "/oauth/{providerName}/edit",
	        templateUrl: "states/admin/security/oauth/oauth_provider_form.html",
	        controller: "AdminSecurityOAuthProviderFormController as ProviderForm"
	    }).state("admin.security.oauth.new", {
	        params: { feature: "oauthsso" },
	        parent: "admin.security",
	        url: "/oauth/newprovider",
	        templateUrl: "states/admin/security/oauth/oauth_provider_form.html",
	        controller: "AdminSecurityOAuthProviderFormController as ProviderForm"
	    });
	}

	module.exports = angular.module("security.oauth", []).config(oauthConfig).controller("AdminSecurityOAuthController", AdminSecurityOAuthController).controller("AdminSecurityOAuthProviderFormController", AdminSecurityOAuthProviderFormController);

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecurityOAuthController = exports.AdminSecurityOAuthController = (function () {
	    function AdminSecurityOAuthController($scope, ArtifactoryModelSaver, JFrogModal, OAuthDao, JFrogGridFactory, commonGridColumns, uiGridConstants) {
	        _classCallCheck(this, AdminSecurityOAuthController);

	        this.$scope = $scope;
	        this.OAuthDao = OAuthDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["oauthData"]);
	        this.providersGridOptions = null;
	        this.TOOLTIP = TOOLTIP.admin.security.OAuthSSO;
	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	        this._createGrid();
	        this._init();
	    }

	    _createClass(AdminSecurityOAuthController, {
	        _init: {
	            value: function _init() {
	                var _this = this;

	                this.OAuthDao.get().$promise.then(function (data) {
	                    _this.oauthData = data;
	                    _this.selectizeOptions = [{ text: " ", value: "*" }];
	                    var githubProviders = _.filter(data.providers, function (p) {
	                        return p.providerType === "github";
	                    });
	                    _this.selectizeOptions = _this.selectizeOptions.concat(_.map(githubProviders, function (p) {
	                        return Object({ text: p.name, value: p.name });
	                    }));
	                    if (!_.findWhere(githubProviders, { name: data.defaultNpm })) {
	                        _this.selectizeOptions.push({ text: data.defaultNpm, value: data.defaultNpm });
	                    }
	                    data.providers.forEach(function (provider) {
	                        provider.typeDisplayName = _.findWhere(data.availableTypes, { type: provider.providerType }).displayName;
	                    });
	                    _this.providersGridOptions.setGridData(data.providers);
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.providersGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect().setButtons(this._getActions()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.oauth.edit({providerName: row.entity.name})\"><a href=\"\">{{row.entity.name}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "20%"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "typeDisplayName",
	                    width: "15%"
	                }, {
	                    name: "ID",
	                    displayName: "ID",
	                    field: "id",
	                    width: "20%"
	                }, {
	                    name: "Auth Url",
	                    displayName: "Auth Url",
	                    field: "authUrl",
	                    width: "35%"
	                }, {
	                    name: "Enabled",
	                    displayName: "Enabled",
	                    field: "enabled",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.enabled"),
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteProvider(row);
	                    }
	                }];
	            }
	        },
	        deleteProvider: {
	            value: function deleteProvider(row) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete provider '" + row.name + "?'").then(function () {
	                    _this.OAuthDao.deleteProvider({}, { provider: row.name }).$promise.then(function () {
	                        _this._init();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                var payload = _.cloneDeep(this.oauthData);

	                if (payload.defaultNpm === "*") delete payload.defaultNpm;
	                delete payload.providers;
	                delete payload.availableTypes;

	                this.OAuthDao.update(payload).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._init();
	                });
	            }
	        },
	        canSave: {
	            value: function canSave() {
	                return this.oauthForm.$valid;
	            }
	        }
	    });

	    return AdminSecurityOAuthController;
	})();

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var AdminSecurityOAuthProviderFormController = exports.AdminSecurityOAuthProviderFormController = (function () {
	    function AdminSecurityOAuthProviderFormController($state, $stateParams, ArtifactoryModelSaver, OAuthDao) {
	        _classCallCheck(this, AdminSecurityOAuthProviderFormController);

	        this.OAuthDao = OAuthDao;
	        this.$state = $state;
	        this.TOOLTIP = TOOLTIP.admin.security.OAuthSSO;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["providerData"]);

	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };

	        if ($stateParams.providerName) {
	            this.mode = "edit";
	            this.providerName = $stateParams.providerName;
	            this.title = "Edit " + this.providerName + " Provider";
	        } else {
	            this.mode = "create";
	            this.providerData = {
	                enabled: true
	            };
	            this.title = "Add New Provider";
	        }

	        this._getData();
	    }

	    _createClass(AdminSecurityOAuthProviderFormController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                this.OAuthDao.get().$promise.then(function (data) {
	                    _this._setMandatoryFieldsData(data.availableTypes);

	                    _this.selectizeOptions = _.map(data.availableTypes, function (t) {
	                        return Object({ text: t.displayName, value: t.type });
	                    });
	                    if (_this.mode === "create") {
	                        _this.providerData.providerType = data.availableTypes[0].type;
	                        _this._setDefaultValues();
	                    } else if (_this.mode === "edit") {
	                        _this.providerData = _.findWhere(data.providers, { name: _this.providerName });
	                    }
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _setMandatoryFieldsData: {
	            value: function _setMandatoryFieldsData(typesData) {
	                var _this = this;

	                this.mandatoryFields = {};
	                this.fieldHolders = {};
	                typesData.forEach(function (typeRec) {
	                    _this.mandatoryFields[typeRec.type] = {};
	                    _this.fieldHolders[typeRec.type] = {};
	                    typeRec.mandatoryFields.forEach(function (field) {
	                        _this.fieldHolders[typeRec.type][field] = typeRec.fieldHolders[typeRec.mandatoryFields.indexOf(field)] || "";
	                        _this.mandatoryFields[typeRec.type][field] = typeRec.fieldsValues[typeRec.mandatoryFields.indexOf(field)] || "";
	                    });
	                });
	            }
	        },
	        _setDefaultValues: {
	            value: function _setDefaultValues() {
	                this.providerData.apiUrl = this.providerData.authUrl = this.providerData.tokenUrl = this.providerData.basicUrl = this.providerData.apiUrlHolder = this.providerData.authUrlHolder = this.providerData.tokenUrlHolder = this.providerData.basicUrlHolder = "";
	                for (var key in this.mandatoryFields[this.providerData.providerType]) {
	                    this.providerData[key] = this.mandatoryFields[this.providerData.providerType][key];
	                    this.providerData[key + "Holder"] = this.fieldHolders[this.providerData.providerType][key];
	                };
	            }
	        },
	        onChangeProviderType: {
	            value: function onChangeProviderType() {
	                this._setDefaultValues();
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                if (this.mode === "edit") {
	                    this.OAuthDao.updateProvider(this.providerData).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.oauth");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else if (this.mode === "create") {
	                    this.OAuthDao.createProvider(this.providerData).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.oauth");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.oauth");
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.providerForm.$valid;
	            }
	        }
	    });

	    return AdminSecurityOAuthProviderFormController;
	})();

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var LdapSettingsController = __webpack_require__(257).LdapSettingsController;

	var LdapSettingFormController = __webpack_require__(258).LdapSettingFormController;

	var LdapGroupFormController = __webpack_require__(259).LdapGroupFormController;

	function ldapSettingConfig($stateProvider) {

	    $stateProvider.state("admin.security.ldap_settings", {
	        url: "/ldap_settings",
	        templateUrl: "states/admin/security/ldap_settings/ldap_settings.html",
	        controller: "LdapSettingsController as Ldap"
	    }).state("admin.security.ldap_settings.new", {
	        parent: "admin.security",
	        url: "/ldap_settings/new",
	        templateUrl: "states/admin/security/ldap_settings/ldap_setting_form.html",
	        controller: "LdapSettingFormController as LdapSettingForm"
	    }).state("admin.security.ldap_settings.edit", {
	        parent: "admin.security",
	        url: "/ldap_settings/:ldapSettingKey/edit",
	        templateUrl: "states/admin/security/ldap_settings/ldap_setting_form.html",
	        controller: "LdapSettingFormController as LdapSettingForm"
	    }).state("admin.security.ldap_settings.new_ldap_group", {
	        parent: "admin.security",
	        url: "/ldap_groups/new",
	        templateUrl: "states/admin/security/ldap_settings/ldap_group_form.html",
	        controller: "LdapGroupFormController as LdapGroupForm"
	    }).state("admin.security.ldap_settings.edit_ldap_group", {
	        parent: "admin.security",
	        url: "/ldap_groups/:ldapGroupName/edit",
	        templateUrl: "states/admin/security/ldap_settings/ldap_group_form.html",
	        controller: "LdapGroupFormController as LdapGroupForm"
	    });
	}

	module.exports = angular.module("security.ldap_settings", []).config(ldapSettingConfig).controller("LdapSettingsController", LdapSettingsController).controller("LdapSettingFormController", LdapSettingFormController).controller("LdapGroupFormController", LdapGroupFormController);

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var LdapSettingsController = exports.LdapSettingsController = (function () {
	    /*
	     z-index: 999;
	     background-color: red;
	     height: 100%;
	     width: 97%;
	     opacity: tr;
	     position: absolute;
	     */

	    function LdapSettingsController(JFrogModal, ArtifactoryFeatures, LdapDao, LdapGroupsDao, $timeout, $scope, JFrogGridFactory, uiGridConstants) {
	        _classCallCheck(this, LdapSettingsController);

	        this.ldapDao = LdapDao;
	        this.ldapGroupsDao = LdapGroupsDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.settingsGridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.groupsGridOption = {};
	        this.ldapSettingsData = {};
	        this.ldapGroupsData = {};
	        this.$timeout = $timeout;
	        this.artifactoryFeatures = ArtifactoryFeatures;
	        this.$scope = $scope;
	        this.noLdapConfigurationMessage = CONFIG_MESSAGES.admin.security.ldap.noLdapConfigurationMessage;
	        this._initLdap();
	    }

	    _createClass(LdapSettingsController, {
	        resetLdapSettings: {
	            value: function resetLdapSettings() {
	                this._getLdapSettingsView();
	            }
	        },
	        deleteLdapSetting: {

	            //Call REST API for deletion of ldap settings

	            value: function deleteLdapSetting(key) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete LDAP: '" + key + "'?").then(function () {
	                    return _this._doDeleteLdapSetting(key);
	                });
	            }
	        },
	        _doDeleteLdapSetting: {
	            value: function _doDeleteLdapSetting(key) {
	                var _this = this;

	                this.ldapDao["delete"]({ key: key }).$promise.then(function (data) {
	                    _this._getLdapSettingsView();
	                });
	            }
	        },
	        deleteLdapGroup: {

	            /***************************
	             ** Delete
	             ****************************/

	            //Call REST API for deletion of ldap group

	            value: function deleteLdapGroup(name) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete LDAP group: '" + name + "'?").then(function () {
	                    return _this._doDeleteLdapGroup(name);
	                });
	            }
	        },
	        _doDeleteLdapGroup: {
	            value: function _doDeleteLdapGroup(name) {
	                var _this = this;

	                this.ldapGroupsDao["delete"]({ name: name }).$promise.then(function (data) {
	                    _this._getLdapGroupsView();
	                });
	            }
	        },
	        deleteSelectedLdapSettings: {
	            value: function deleteSelectedLdapSettings() {
	                var _this = this;

	                var selectedRows = this.settingsGridOption.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " LDAP settings?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteLdapSetting(row.entity.key);
	                    });
	                });
	            }
	        },
	        deleteSelectedLdapGroups: {
	            value: function deleteSelectedLdapGroups() {
	                var _this = this;

	                var selectedRows = this.groupsGridOption.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " LDAP groups?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteLdapGroup(row.entity.name);
	                    });
	                });
	            }
	        },
	        canMove: {

	            /***************************
	             ** Move up / down
	             ****************************/
	            //check if a row (in the settings grid) can move up or down

	            value: function canMove(key, dir) {
	                var data = this.ldapSettingsData;
	                var index = this._indexOf(key);
	                return dir === "up" && index > 0 || dir === "down" && index < data.length - 1;
	            }
	        },
	        moveLdapSetting: {

	            //move a row (in the settings grid) up or down

	            value: function moveLdapSetting(key, dir) {
	                var data = this.ldapSettingsData;
	                var index = this._indexOf(key);
	                if (dir === "up" && index > 0) {
	                    this._swapSettings(index, index - 1);
	                } else if (dir === "down" && index < data.length - 1) {
	                    this._swapSettings(index, index + 1);
	                }
	            }
	        },
	        _initLdap: {

	            /***************************
	             ** Initialization
	             ****************************/

	            //initialize everything...

	            value: function _initLdap() {
	                var _this = this;

	                this._createGrids();
	                this._getLdapSettingsView();
	                this._getLdapGroupsView().then(function () {
	                    return _this._disableAsOss();
	                });
	            }
	        },
	        _getLdapSettingsView: {

	            //get settings ('view') data from the REST API

	            value: function _getLdapSettingsView() {
	                var _this = this;

	                this.ldapDao.query().$promise.then(function (data) {
	                    _this.ldapSettingsData = data;
	                    _this.settingsGridOption.setGridData(_this.ldapSettingsData);
	                });
	            }
	        },
	        _getLdapGroupsView: {

	            //get ldap groups ('view') data from the REST API

	            value: function _getLdapGroupsView() {
	                var _this = this;

	                return this.ldapGroupsDao.query().$promise.then(function (data) {
	                    _this.ldapGroupsData = data;
	                    _this.groupsGridOption.setGridData(_this.ldapGroupsData);
	                });
	            }
	        },
	        _disableAsOss: {
	            value: function _disableAsOss() {}
	        },
	        _createGrids: {

	            //create both ldap settings grid and ldap groups grid

	            value: function _createGrids() {
	                this.settingsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getSettingsColumns()).setSingleSelect().setDraggable(this.reorderLdap.bind(this)).setButtons(this._getSettingsActions());
	                //.setBatchActions(this._getSettingsBatchActions());

	                this.groupsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getGroupsColumns()).setSingleSelect().setRowTemplate("default").setButtons(this._getGroupsActions());
	                //.setBatchActions(this._getGroupsBatchActions());
	            }
	        },
	        reorderLdap: {
	            value: function reorderLdap() {
	                return this.ldapDao.reorder(this.getLdapOrder()).$promise;
	            }
	        },
	        getLdapOrder: {
	            value: function getLdapOrder() {
	                var ldapOrderList = [];
	                this.settingsGridOption.data.forEach(function (data) {
	                    ldapOrderList.push(data.key);
	                });
	                return ldapOrderList;
	            }
	        },
	        noData: {
	            value: function noData() {
	                return (!this.ldapSettingsData || this.ldapSettingsData.length === 0) && (!this.ldapGroupsData || this.ldapGroupsData.length === 0);
	            }
	        },
	        _getSettingsColumns: {

	            /***************************
	             ** Settings Grid
	             ****************************/
	            //get the columns for the settings grid

	            value: function _getSettingsColumns() {

	                return [{
	                    name: "Settings Name",
	                    displayName: "Settings Name",
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.ldap_settings.edit({ldapSettingKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    enableSorting: false
	                }, {
	                    name: "LDAP URL",
	                    displayName: "LDAP URL",
	                    field: "ldapUrl",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-href=\"{{ COL_FIELD }}\">{{ COL_FIELD }}</a></div>",
	                    enableSorting: false
	                }];
	            }
	        },
	        _getSettingsActions: {

	            //get the actions for the settings grid

	            value: function _getSettingsActions() {
	                var _this = this;

	                return [
	                /*{
	                 icon: 'icon icon-angle-double-up',
	                 tooltip: 'Move Up',
	                 visibleWhen: row => this.canMove(row.key,'up'),
	                 callback: row => this.moveLdapSetting(row.key,'up')
	                 },
	                 {
	                 icon: 'icon icon-angle-double-down',
	                 tooltip: 'Move Down',
	                 visibleWhen: row => this.canMove(row.key,'down'),
	                 callback: row => this.moveLdapSetting(row.key,'down')
	                 },*/
	                {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLdapSetting(row.key);
	                    }
	                }];
	            }
	        },
	        _getGroupsColumns: {

	            //
	            //_getSettingsBatchActions() {
	            //    return [
	            //        {
	            //            icon: 'clear',
	            //            name: 'Delete',
	            //            callback: () => this.deleteSelectedLdapSettings()
	            //        },
	            //    ]
	            //}
	            /***************************
	             ** Groups Grid
	             ****************************/

	            value: function _getGroupsColumns() {
	                return [{
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.ldap_settings.edit_ldap_group({ldapGroupName: row.entity.name})\">{{ COL_FIELD }}</a></div>"
	                }, {
	                    name: "LDAP Settings",
	                    displayName: "LDAP Settings",
	                    field: "enabledLdap"
	                }, {
	                    name: "Strategy",
	                    displayName: "Strategy",
	                    field: "strategy"
	                }];
	            }
	        },
	        _getGroupsActions: {
	            value: function _getGroupsActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLdapGroup(row.name);
	                    }
	                }];
	            }
	        },
	        _getGroupsBatchActions: {
	            value: function _getGroupsBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedLdapGroups();
	                    }
	                }];
	            }
	        },
	        _indexOf: {

	            //get the index of the ldap settings (key) in this.ldapSettingsData

	            value: function _indexOf(key) {
	                var data = this.ldapSettingsData;

	                var index = -1;

	                for (var i = 0; i < data.length; i++) {
	                    if (data[i].key === key) {
	                        index = i;
	                        break;
	                    }
	                }

	                return index;
	            }
	        },
	        _swapSettings: {

	            //swap the order of two ldap settings

	            value: function _swapSettings(index1, index2) {
	                var data = this.ldapSettingsData;

	                var temp = data[index2];
	                data[index2] = data[index1];
	                data[index1] = temp;
	            }
	        }
	    });

	    return LdapSettingsController;
	})();

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var $stateParams = undefined,
	    LdapDao = undefined,
	    $state = undefined,
	    JFrogGridFactory = undefined;

	var LdapSettingFormController = exports.LdapSettingFormController = (function () {
	    function LdapSettingFormController(_$stateParams_, _$state_, _LdapDao_, _JFrogGridFactory_, JFrogNotifications, ArtifactoryModelSaver, ArtifactoryFeatures) {
	        _classCallCheck(this, LdapSettingFormController);

	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        LdapDao = _LdapDao_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.testConnection = {};
	        this.isNew = !$stateParams.ldapSettingKey;
	        this.TOOLTIP = TOOLTIP.admin.security.LDAPSettingsForm;
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["ldap"]);
	        this._initLdapSetting();
	    }

	    _createClass(LdapSettingFormController, {
	        _initLdapSetting: {
	            value: function _initLdapSetting() {
	                var _this = this;

	                if (this.isNew) {
	                    this.ldap = {
	                        enabled: true,
	                        autoCreateUser: true,
	                        search: { searchSubTree: true },
	                        emailAttribute: "mail",
	                        ldapPoisoningProtection: true
	                    };
	                } else {
	                    LdapDao.get({ key: $stateParams.ldapSettingKey }).$promise.then(function (ldapSetting) {
	                        _this.ldap = ldapSetting;
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                if (this.ldapEditForm.$valid) {
	                    if (!this.ldap.userDnPattern && !this.ldap.search.searchFilter) {
	                        this.messageUserOrSearch();
	                    } else {
	                        if (this.ldap.search && this._isSearchFieldsNull(this.ldap.search)) {
	                            this.ldap.search = undefined;
	                        }
	                        var whenSaved = this.isNew ? LdapDao.save(this.ldap) : LdapDao.update(this.ldap);
	                        whenSaved.$promise.then(function () {
	                            _this.savePending = false;
	                            _this.ArtifactoryModelSaver.save();
	                            _this._end();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    }
	                }
	            }
	        },
	        _isSearchFieldsNull: {
	            value: function _isSearchFieldsNull(search) {
	                return !search.managerDn && !search.managerPassword && !search.searchBase && !search.searchFilter;
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.ldap_settings");
	            }
	        },
	        doTestConnection: {
	            value: function doTestConnection() {
	                if (this.ldapEditForm.$valid) {
	                    if (!this.ldap.userDnPattern && !this.ldap.search.searchFilter) {
	                        this.messageUserOrSearch();
	                    } else {
	                        var testData = {};
	                        _.extend(testData, this.ldap);
	                        _.extend(testData, this.testConnection);

	                        LdapDao.test(testData);
	                    }
	                }
	            }
	        },
	        messageUserOrSearch: {
	            value: function messageUserOrSearch() {
	                this.artifactoryNotifications.create({ error: "LDAP settings should provide a userDnPattern or a searchFilter (or both)" });
	            }
	        }
	    });

	    return LdapSettingFormController;
	})();

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	// Injectables:
	var $q = undefined,
	    $scope = undefined,
	    $state = undefined,
	    $stateParams = undefined,
	    JFrogGridFactory = undefined,
	    LdapGroupsDao = undefined,
	    LdapDao = undefined,
	    ArtifactoryModelSaver = undefined;

	var LdapGroupFormController = exports.LdapGroupFormController = (function () {
	    function LdapGroupFormController(_$q_, _$scope_, _$state_, _$stateParams_, _JFrogGridFactory_, _LdapGroupsDao_, _LdapDao_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, LdapGroupFormController);

	        $q = _$q_;
	        $scope = _$scope_;
	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["ldapGroup"]);
	        LdapGroupsDao = _LdapGroupsDao_;
	        LdapDao = _LdapDao_;

	        this.isNew = !$stateParams.ldapGroupName;
	        this._initLdapSetting();
	        this._initGroupLabels();
	        this._initSelectizeConfig();
	        this._initGroupSyncGrid();
	        this._initStrategyOptions();
	        this.isImportDisabled = true;
	        this.TOOLTIP = TOOLTIP.admin.security.LDAPGroupsForm;
	    }

	    _createClass(LdapGroupFormController, {
	        _initLdapSetting: {

	            /***************************
	            ** Initialization
	            ****************************/

	            value: function _initLdapSetting() {
	                var _this = this;

	                if (this.isNew) {
	                    this.ldapGroup = {
	                        enabledLdap: " ",
	                        strategy: "STATIC",
	                        subTree: true
	                    };
	                    this.ldapGroupPromise = $q.when(this.ldapGroup);
	                } else {
	                    this.ldapGroupPromise = LdapGroupsDao.get({ name: $stateParams.ldapGroupName }).$promise.then(function (ldapGroup) {
	                        _this.ldapGroup = ldapGroup;
	                        ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        _initGroupLabels: {
	            value: function _initGroupLabels() {
	                var _this = this;

	                if (this.isNew) this.onStrategyChange();else {
	                    this.ldapGroupPromise.then(function () {
	                        _this._setGroupLabels(_this.ldapGroup.strategy);
	                    });
	                }
	            }
	        },
	        _initSelectizeConfig: {
	            value: function _initSelectizeConfig() {
	                var _this = this;

	                LdapDao.query().$promise.then(function (ldapSettingsData) {
	                    _this.selectizeConfig = {
	                        sortField: "text",
	                        create: true,
	                        maxItems: 1
	                    };

	                    _this.selectizeOptions = ldapSettingsData.map(function (ldapSetting) {
	                        return ldapSetting.key;
	                    });
	                    _this.selectizeOptions.push(" ");
	                });
	            }
	        },
	        _initGroupSyncGrid: {
	            value: function _initGroupSyncGrid() {
	                var _this = this;

	                this.syncGroupsGridOptions = JFrogGridFactory.getGridInstance($scope).setColumns(this._getSyncGroupsGridColumns()).setRowTemplate("default").setBatchActions(this._getBatchActions()).setMultiSelect().setGridData([]);

	                this.syncGroupsGridOptions.onSelectionChange = this.syncGroupsGridOptions.onSelectionChangeBatch = function () {
	                    var selectedRows = _this.syncGroupsGridOptions.api.selection.getSelectedRows();
	                    _this.isImportDisabled = !selectedRows.length;
	                };
	            }
	        },
	        _initStrategyOptions: {
	            value: function _initStrategyOptions() {
	                this.strategyOptions = [{ value: "STATIC", text: "Static" }, { value: "DYNAMIC", text: "Dynamic" }, { value: "HIERARCHICAL", text: "Hierarchy" }];
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                var whenSaved = this.isNew ? LdapGroupsDao.save(this.ldapGroup) : LdapGroupsDao.update(this.ldapGroup);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.ldap_settings");
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "import",
	                    name: "Import",
	                    callback: function () {
	                        return _this.importSyncGroups();
	                    }
	                }];
	            }
	        },
	        importSyncGroups: {
	            value: function importSyncGroups() {
	                var _this = this;

	                if (this.isImportDisabled) {
	                    return;
	                }var importData = {};
	                var selectedRows = this.syncGroupsGridOptions.api.selection.getSelectedRows();
	                _.extend(importData, { importGroups: selectedRows, ldapGroupSettings: this.ldapGroup });
	                _.extend(importData, { name: this.ldapGroup.name });

	                LdapGroupsDao["import"](importData).$promise.then(function (data) {
	                    _this.refreshSyncGroups(_this.ldapGroup.usernameFilter);
	                });
	            }
	        },
	        importSyncGroup: {
	            value: function importSyncGroup(row) {
	                var _this = this;

	                var importData = {};
	                _.extend(importData, { importGroups: [row], ldapGroupSettings: this.ldapGroup });
	                _.extend(importData, { name: this.ldapGroup.name });

	                LdapGroupsDao["import"](importData).$promise.then(function (data) {
	                    _this.refreshSyncGroups(_this.ldapGroup.usernameFilter);
	                });
	            }
	        },
	        refreshSyncGroups: {
	            value: function refreshSyncGroups(username) {
	                var _this = this;

	                if (!this.ldapGroupsEditForm.$valid) {
	                    return;
	                }var refreshData = {};
	                _.extend(refreshData, this.ldapGroup);
	                _.extend(refreshData, { name: refreshData.name, username: username });

	                LdapGroupsDao.refresh(refreshData).$promise.then(function (result) {
	                    result.data.forEach(function (group) {
	                        group.syncState = group.requiredUpdate === "IN_ARTIFACTORY";
	                    });
	                    _this.syncGroupsGridOptions.setGridData(result.data);
	                })["catch"](function () {
	                    _this.syncGroupsGridOptions.setGridData([]);
	                })["finally"](function () {
	                    if (_this) _this.isImportDisabled = true;
	                });
	            }
	        },
	        _setGroupLabels: {

	            /***************************
	            ** Strategy
	            ****************************/

	            value: function _setGroupLabels(strategy) {
	                switch (strategy.toLowerCase()) {
	                    case "static":
	                    case "dynamic":
	                        this.labels = { groupKeyMember: "Group Member Attribute" };
	                        break;
	                    case "hierarchical":
	                        this.labels = { groupKeyMember: "User DN Group Key" };
	                        break;
	                }
	            }
	        },
	        onStrategyChange: {
	            value: function onStrategyChange() {
	                var _this = this;

	                var strategy = this.ldapGroup.strategy;
	                this._getStrategy(strategy).then(function (data) {
	                    _this.ldapGroup.groupMemberAttribute = data.groupKeyMember;
	                    _this.ldapGroup.groupNameAttribute = data.groupNameAttribute;
	                    _this.ldapGroup.descriptionAttribute = data.description;
	                    _this.ldapGroup.filter = data.filter;
	                });

	                this._setGroupLabels(strategy);
	            }
	        },
	        _getStrategy: {
	            value: function _getStrategy(strategy) {
	                return LdapGroupsDao.getstrategy({ name: "dummy", strategy: strategy.toLowerCase() }).$promise;
	            }
	        },
	        _getSyncGroupsGridColumns: {

	            /***************************
	            ** Grid
	            ****************************/
	            //get the columns for the synchronize groups grid (inside the ldap groups' modal)

	            value: function _getSyncGroupsGridColumns() {
	                var _this = this;

	                return [{
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    field: "groupName",
	                    width: "30%"
	                }, {
	                    name: "Description",
	                    displayName: "Description",
	                    field: "description",
	                    width: "60%"
	                }, {
	                    name: "Sync State",
	                    displayName: "Sync State",
	                    field: "syncState",
	                    cellTemplate: "<div ng-if=\"row.entity.syncState\" class=\"grid-checkbox\"><input class=\"text-center\" " + "ng-model=\"row.entity.syncState\" type=\"checkbox\" disabled/><span class=\"icon icon-v\"></span></div>",
	                    width: "10%",
	                    customActions: [{
	                        icon: "icon icon-import",
	                        tooltip: "Import",
	                        name: "Import",
	                        callback: function (row) {
	                            return _this.importSyncGroup(row);
	                        }
	                    }]
	                }];
	            }
	        }
	    });

	    return LdapGroupFormController;
	})();

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var SigningKeysController = __webpack_require__(261).SigningKeysController;

	function signingKeysConfig($stateProvider) {

	    $stateProvider.state("admin.security.signing_keys", {
	        params: { feature: "signingkeys" },
	        url: "/signing_keys",
	        templateUrl: "states/admin/security/signing_keys/signing_keys.html",
	        controller: "SigningKeysController as SigningKeys"
	    });
	}

	module.exports = angular.module("security.signing_keys", []).config(signingKeysConfig).controller("SigningKeysController", SigningKeysController);

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var API = _interopRequire(__webpack_require__(88));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var SigningKeysController = exports.SigningKeysController = (function () {
	    function SigningKeysController($timeout, FileUploader, JFrogEventBus, SigningKeysDao, KeystoreDao, JFrogNotifications) {
	        _classCallCheck(this, SigningKeysController);

	        this.$timeout = $timeout;
	        this.signingKeysDao = SigningKeysDao;
	        this.keystoreDao = KeystoreDao;
	        this.keyStore = {};
	        this.FileUploader = FileUploader;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.TOOLTIP = TOOLTIP.admin.security.signingKeys;
	        this.publicKeyValue = "No public key installed";
	        this.privateKeyValue = "No private key installed";
	        this.initSigningKeys();
	    }

	    _createClass(SigningKeysController, {
	        initSigningKeys: {
	            value: function initSigningKeys() {

	                this.getSigningKeysData();
	                this.keyPairNames = [];
	                this.keystoreFileUploaded = false;
	                this.getKeyStoreData();
	                //-----public key-----//
	                this.uploaderPublicKey = new this.FileUploader();
	                this.uploaderPublicKey.onSuccessItem = this.onUploadPublicKeySuccess.bind(this);
	                this.uploaderPublicKey.onErrorItem = this.onUploadPublicKeyFail.bind(this);
	                this.uploaderPublicKey.url = "" + API.API_URL + "/signingkeys/install?public=true";
	                this.uploaderPublicKey.removeAfterUpload = true;
	                //-----private key-----//
	                this.uploaderPrivateKey = new this.FileUploader();
	                this.uploaderPrivateKey.url = "" + API.API_URL + "/signingkeys/install?public=false";
	                this.uploaderPrivateKey.onSuccessItem = this.onUploadPrivateKeySuccess.bind(this);
	                this.uploaderPrivateKey.onErrorItem = this.onUploadPrivateKeyFail.bind(this);
	                this.uploaderPrivateKey.removeAfterUpload = true;
	                //------key pair-----//
	                this.uploaderKeyStore = new this.FileUploader();
	                this.uploaderKeyStore.onSuccessItem = this.onUploadKeyStoreSuccess.bind(this);
	                this.uploaderKeyStore.onErrorItem = this.onUploadKeyStoreFail.bind(this);
	                this.uploaderKeyStore.onAfterAddingAll = this.onUploadKeyFileAdded.bind(this);
	                this.uploaderKeyStore.url = "" + API.API_URL + "/keystore/upload?pass=";
	                this.uploaderKeyStore.removeAfterUpload = true;
	            }
	        },
	        getSigningKeysData: {
	            value: function getSigningKeysData() {
	                var _this = this;

	                this.signingKeysDao.get().$promise.then(function (result) {
	                    _this.publicKeyInstalled = result.publicKeyInstalled;
	                    _this.privateKeyInstalled = result.privateKeyInstalled;
	                    _this.publicKeyValue = result.publicKeyInstalled ? "Public key is installed" : "No public key installed";
	                    _this.privateKeyValue = result.privateKeyInstalled ? "Private key is installed" : "No private key installed";
	                    _this.publicKeyLink = result.publicKeyLink;
	                    _this.passPhrase = result.passPhrase;
	                });
	            }
	        },
	        getKeyStoreData: {
	            value: function getKeyStoreData() {
	                var _this = this;

	                this.keystoreDao.get().$promise.then(function (keyStore) {
	                    _this.keyStoreExist = keyStore.keyStoreExist;
	                    _.map(keyStore.keyStorePairNames, function (keypairName) {
	                        _this.keyPairNames.push(keypairName);
	                    });
	                });
	            }
	        },
	        onUploadPublicKeySuccess: {
	            value: function onUploadPublicKeySuccess(fileDetails, response) {
	                this.getSigningKeysData();
	                this.artifactoryNotifications.create(response.feedbackMsg);
	            }
	        },
	        onUploadPrivateKeySuccess: {
	            value: function onUploadPrivateKeySuccess(fileDetails, response) {
	                this.getSigningKeysData();
	                this.artifactoryNotifications.create(response.feedbackMsg);
	            }
	        },
	        onUploadPublicKeyFail: {
	            value: function onUploadPublicKeyFail(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        onUploadPrivateKeyFail: {
	            value: function onUploadPrivateKeyFail(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        upload: {
	            value: function upload(type) {
	                if (type === "public") {
	                    this.uploaderPublicKey.queue[0].upload();
	                }
	                if (type === "private") {
	                    this.uploaderPrivateKey.queue[0].upload();
	                }
	                if (type === "keyStore") {
	                    this.uploaderKeyStore.queue[0].url = "" + API.API_URL + "/keystore/upload?pass=" + this.keyPair.keyStorePassword;
	                    this.uploaderKeyStore.queue[0].upload();
	                }
	            }
	        },
	        removeKey: {
	            value: function removeKey(isPublic) {
	                var _this = this;

	                this.signingKeysDao["delete"]({ "public": isPublic }).$promise.then(function (result) {
	                    return _this.getSigningKeysData();
	                });
	            }
	        },
	        verifyPhrase: {
	            value: function verifyPhrase() {
	                var shouldNotify = arguments[0] === undefined ? true : arguments[0];

	                //this.signingKeysDao.setNotification('post', shouldNotify);
	                var method = shouldNotify ? "post" : "postWithoutNotifications";
	                if (this.signingKeysDao[method]) {
	                    return this.signingKeysDao[method]({ action: "verify", passPhrase: this.passPhrase }).$promise;
	                }
	            }
	        },
	        updatePhrase: {
	            value: function updatePhrase() {
	                var _this = this;

	                var verifyPromise = this.verifyPhrase(false);
	                if (verifyPromise) {
	                    verifyPromise.then(function () {
	                        _this.signingKeysDao.put({ action: "update", passPhrase: _this.passPhrase });
	                    })["catch"](function (response) {
	                        return _this.artifactoryNotifications.create(response.data);
	                    });
	                    ;
	                }
	            }
	        },
	        checkMatchingPasswords: {
	            value: function checkMatchingPasswords() {
	                var _this = this;

	                this.$timeout(function () {
	                    if (_this.signingKeysForm.password.$valid && _this.signingKeysForm.repeatPassword.$valid) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION);
	                    }
	                });
	            }
	        },
	        updatePassword: {
	            value: function updatePassword() {
	                var _this = this;

	                this.keystoreDao.updatePassword({ action: "updatePass" }, { password: this.user.password }).$promise.then(function () {
	                    _this.keyStoreExist = true;
	                });
	            }
	        },
	        removeKeyStore: {
	            value: function removeKeyStore() {
	                var _this = this;

	                this.keystoreDao.removeKeystore({ action: "password" }).$promise.then(function () {
	                    //_.forEach(this.keyPairNames, this.removeKeypair, this);
	                    _this.keyStoreExist = false;
	                    _this.keyPairNames = [];
	                    _this.keyPairName = "";
	                    _this.user.password = "";
	                    _this.repeatPassword = "";
	                });
	            }
	        },
	        onUploadKeyFileAdded: {
	            value: function onUploadKeyFileAdded() {
	                this.keyStorePassRequired = true;
	            }
	        },
	        onUploadKeyStoreSuccess: {
	            value: function onUploadKeyStoreSuccess(fileDetails, keyStore) {
	                this.keyStorePassRequired = false;
	                this.keystoreFileUploaded = true;
	                this.keyStore = keyStore;
	                this.aliases = keyStore.availableAliases;
	                this.alias = this.aliases[0];
	                this.keyPair.keyStorePassword = "";
	                this.artifactoryNotifications.create(keyStore.feedbackMsg);
	            }
	        },
	        onUploadKeyStoreFail: {
	            value: function onUploadKeyStoreFail(fileDetails, response) {
	                this.keyStorePassRequired = false;
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        saveKeypair: {
	            value: function saveKeypair() {
	                var _this = this;

	                var payload = _.cloneDeep(this.keyStore);
	                delete payload.feedbackMsg;
	                delete payload.availableAliases;
	                payload.alias = this.alias;

	                this.keystoreDao.save({ action: "add" }, payload).$promise.then(function (response) {
	                    _this.keyPairNames.push(_this.keyStore.keyPairName);
	                    _this.keyStore.keyPairName = "";
	                    _this.keyStore.privateKeyPassword = "";
	                    _this.alias = "";
	                    _this.aliases = [];
	                });
	                //.finally(() => this.keystoreFileUploaded = false);
	            }
	        },
	        removeKeypair: {
	            value: function removeKeypair() {
	                var _this = this;

	                this.keystoreDao.removeKeypair({ name: this.keyPairName }).$promise.then(function (response) {
	                    _.pull(_this.keyPairNames, _this.keyPairName);
	                    _this.keyPairName = "";
	                })["catch"](function (response) {
	                    if (response.error) {
	                        var keyPairNames = _.words(response.error);
	                        _.pull(_this.keyPairNames, keyPairNames.pop());
	                    }
	                });
	            }
	        },
	        cancelKeypairUpload: {
	            value: function cancelKeypairUpload() {
	                //this.keystoreFileUploaded = false;
	                this.keyStore.keyPairName = "";
	                this.keyStore.privateKeyPassword = "";
	            }
	        },
	        canUpdatePassword: {
	            value: function canUpdatePassword() {
	                return this.signingKeysForm.password.$valid && this.signingKeysForm.repeatPassword.$valid;
	            }
	        },
	        canUploadKeystore: {
	            value: function canUploadKeystore() {
	                return this.keyStoreExist && this.signingKeysForm.keyStorePassword.$valid && this.uploaderKeyStore.queue.length;
	            }
	        },
	        canUploadDebianKey: {
	            value: function canUploadDebianKey(uploader) {
	                return this[uploader].queue.length;
	            }
	        },
	        canRemoveKeyPairs: {
	            value: function canRemoveKeyPairs() {
	                return this.keyStoreExist && this.keyPairNames.length && this.keyPairName;
	            }
	        },
	        canUpdatePhrase: {
	            value: function canUpdatePhrase() {
	                return this.publicKeyInstalled && this.privateKeyInstalled && this.passPhrase;
	            }
	        }
	    });

	    return SigningKeysController;
	})();

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AccessTokensController = __webpack_require__(263).AccessTokensController;

	function accessTokensConfig($stateProvider) {

	    $stateProvider.state("admin.security.access_tokens", {
	        params: { feature: "accesstokens" },
	        url: "/access_tokens",
	        templateUrl: "states/admin/security/access_tokens/access_tokens.html",
	        controller: "AccessTokensController as AccessTokens"
	    });
	}

	module.exports = angular.module("security.access_tokens", []).config(accessTokensConfig).controller("AccessTokensController", AccessTokensController);

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AccessTokensController = exports.AccessTokensController = (function () {
	    function AccessTokensController($scope, AccessTokensDao, uiGridConstants, commonGridColumns, JFrogGridFactory, JFrogModal) {
	        _classCallCheck(this, AccessTokensController);

	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.AccessTokensDao = AccessTokensDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.modal = JFrogModal;
	        this.noTokensMessage = CONFIG_MESSAGES.admin.security.accessTokens.noTokensMessage;
	        this._createGrid();
	        this._getData();
	    }

	    _createClass(AccessTokensController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                // get all tokens
	                this.AccessTokensDao.getTokens().$promise.then(function (tokens) {
	                    _this.gridOption.setGridData(tokens);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setButtons(this._getActions()).setMultiSelect().setRowTemplate("default").setBatchActions(this._getBatchActions());
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "subject",
	                    name: "Subject",
	                    displayName: "Subject",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.subject}}</div>",
	                    width: "28%"
	                }, {
	                    field: "tokenId",
	                    name: "Token ID",
	                    displayName: "Token ID",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.tokenId}}</div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "24%"
	                }, {
	                    field: "issuedAt",
	                    name: "Issued At",
	                    displayName: "Issued At",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.issuedAt}}</div>",
	                    width: "18%"
	                }, {
	                    field: "expiryDate",
	                    name: "Expiry Date",
	                    displayName: "Expiry Date",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.expiry}}</div>",
	                    width: "18%"
	                }, {
	                    field: "refreshable",
	                    name: "Refreshable",
	                    displayName: "Refreshable",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.refreshable}}</div>",
	                    width: "12%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Revoke",
	                    callback: function (row) {
	                        return _this.revokeToken(row);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Revoke",
	                    callback: function () {
	                        return _this.bulkRevoke();
	                    }
	                }];
	            }
	        },
	        revokeToken: {
	            value: function revokeToken(token) {
	                var _this = this;

	                // Create array with single token ID to revoke
	                var json = [token.tokenId];
	                this.modal.confirm("Are you sure you want to revoke this access token? Once revoked,\n                            it can not be used again.", "Revoke access token", { confirm: "Revoke" }).then(function () {
	                    return _this.AccessTokensDao.revokeTokens(json).$promise.then(function () {
	                        return _this._getData();
	                    });
	                });
	            }
	        },
	        bulkRevoke: {
	            value: function bulkRevoke() {
	                var _this = this;

	                // Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                // Create an array of the selected tokens
	                var tokenIds = _.map(selectedRows, function (token) {
	                    return token.tokenId;
	                });

	                //Ask for confirmation before revoke and if confirmed then revoke bulk of tokens
	                this.modal.confirm("Are you sure you want to revoke these access tokens? Once revoked, \n                            they can not be used again.", "Revoke access tokens", { confirm: "Revoke" }).then(function () {
	                    return _this.AccessTokensDao.revokeTokens(tokenIds).$promise.then(function () {
	                        return _this._getData();
	                    });
	                });
	            }
	        }
	    });

	    return AccessTokensController;
	})();

/***/ }),
/* 264 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminSecurityController = exports.AdminSecurityController = (function () {
	    function AdminSecurityController($modal) {
	        _classCallCheck(this, AdminSecurityController);

	        this.userData = this.getUserGridData();
	        this.modal = $modal;
	    }

	    _createClass(AdminSecurityController, {
	        getUserGridData: {
	            value: function getUserGridData() {

	                return [{ "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }];
	            }
	        },
	        addUser: {
	            value: function addUser() {
	                this.modal.open({ template: "<div>test test</div>" });
	                this.userData.push({});
	            }
	        }
	    });

	    return AdminSecurityController;
	})();

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var Backups = _interopRequire(__webpack_require__(266));

	var Indexer = _interopRequire(__webpack_require__(269));

	var AdminServicesController = __webpack_require__(271).AdminServicesController;

	function adminServicesConfig($stateProvider) {
	    $stateProvider.state("admin.services", {
	        url: "/services",
	        template: "<ui-view></ui-view>",
	        controller: "AdminServicesController as AdminServices"
	    });
	}

	module.exports = angular.module("admin.services", [Backups.name, Indexer.name]).config(adminServicesConfig).controller("AdminServicesController", AdminServicesController);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminServicesBackupsController = __webpack_require__(267).AdminServicesBackupsController;

	var AdminServicesBackupFormController = __webpack_require__(268).AdminServicesBackupFormController;

	function backupsConfig($stateProvider) {

	    $stateProvider.state("admin.services.backups", {
	        params: { feature: "backups" },
	        url: "/backups",
	        templateUrl: "states/admin/services/backups/backups.html",
	        controller: "AdminServicesBackupsController as AdminServicesBackups"
	    }).state("admin.services.backups.new", {
	        params: { feature: "backups" },
	        parent: "admin.services",
	        url: "/backups/new",
	        templateUrl: "states/admin/services/backups/backup_form.html",
	        controller: "AdminServicesBackupFormController as BackupForm"
	    }).state("admin.services.backups.edit", {
	        params: { feature: "backups" },
	        parent: "admin.services",
	        url: "/backups/:backupKey/edit",
	        templateUrl: "states/admin/services/backups/backup_form.html",
	        controller: "AdminServicesBackupFormController as BackupForm"
	    });
	}

	module.exports = angular.module("backups", []).config(backupsConfig).controller("AdminServicesBackupsController", AdminServicesBackupsController).controller("AdminServicesBackupFormController", AdminServicesBackupFormController);

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AdminServicesBackupsController = exports.AdminServicesBackupsController = (function () {
	    function AdminServicesBackupsController($scope, BackupDao, JFrogGridFactory, JFrogModal, RepoDataDao, $q, commonGridColumns) {
	        _classCallCheck(this, AdminServicesBackupsController);

	        this.backupDao = BackupDao;
	        this.repoDataDao = RepoDataDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.commonGridColumns = commonGridColumns;
	        this.noBackupsMessage = CONFIG_MESSAGES.admin.services.backups.noBackupsMessage;
	        this._createGrid();
	        this._initBackups();
	        this.$q = $q;
	    }

	    _createClass(AdminServicesBackupsController, {
	        _initBackups: {
	            value: function _initBackups() {
	                var _this = this;

	                this.backupDao.query().$promise.then(function (backups) {
	                    _this.gridBackupsOptions.setGridData(backups);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridBackupsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect().setButtons(this._getActions()).setRowTemplate("default");
	                //.setMultiSelect()
	                //.setBatchActions(this._getBatchActions());
	            }
	        },
	        _doDeleteBackup: {
	            value: function _doDeleteBackup(key) {
	                return this.backupDao["delete"]({ key: key }).$promise;
	            }
	        },
	        deleteBackup: {

	            /* deleteSelectedBackups() {
	                 let selectedRows = this.gridBackupsOptions.api.selection.getSelectedGridRows();
	                 this.modal.confirm(`Are you sure you want to delete ${selectedRows.length} backups?`)
	                     .then(() => {
	                         return this.$q.all(selectedRows.map((row) => this._doDeleteBackup(row.entity.key)))
	                     })
	                     .then(() => this._initBackups())
	             }*/

	            value: function deleteBackup(key) {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete the backup '" + key + "'?").then(function () {
	                    return _this._doDeleteBackup(key);
	                }).then(function () {
	                    return _this._initBackups();
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.backups.edit({backupKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    width: "15%"
	                }, {
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    field: "includeRepos",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.includeRepos", "row.entity.key"),
	                    width: "30%"
	                }, {
	                    name: "Cron Expression",
	                    displayName: "Cron Expression",
	                    field: "cronExp",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ COL_FIELD }}</div>",
	                    width: "15%"
	                }, {
	                    name: "Next Schedule Backup",
	                    displayName: "Next Schedule Backup",
	                    field: "cronExp",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><input class=\"not-like-input\" type=\"text\" jf-cron-formatter ng-model=\"row.entity.cronExp\" disabled></div>",
	                    width: "20%"
	                }, {
	                    field: "enabled",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.enabled"),
	                    width: "10%"
	                }, {
	                    name: "Run Now",
	                    displayName: "Run Now",
	                    field: "runnow",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-run\" ng-click=\"grid.appScope.AdminServicesBackups.runNow(row.entity)\" ng-disabled=\"!row.entity.enabled\"></a></div>",
	                    width: "10%",
	                    enableSorting: false
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (entity) {
	                        return _this.deleteBackup(entity.key);
	                    }
	                }];
	            }
	        },
	        runNow: {
	            value: function runNow(row) {
	                var _this = this;

	                if (row.enabled) {
	                    this.backupDao.get({ key: row.key }).$promise.then(function (backup) {
	                        _this.backupDao.runNow({}, backup).$promise.then(function (res) {});
	                    });
	                }
	            }
	            /*    _getBatchActions() {
	                    return [
	                        {
	                            icon: 'clear',
	                            name: 'Delete',
	                            callback: () => this.deleteSelectedBackups()
	                        },
	                    ]
	                }*/

	        }
	    });

	    return AdminServicesBackupsController;
	})();

	//console.log(res);

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var EVENTS = _interopRequire(__webpack_require__(48));

	var $state = undefined,
	    $stateParams = undefined,
	    RepoDataDao = undefined,
	    BackupDao = undefined;

	var AdminServicesBackupFormController = exports.AdminServicesBackupFormController = (function () {
	    function AdminServicesBackupFormController($scope, _$state_, _$stateParams_, _RepoDataDao_, _BackupDao_, BrowseFilesDao, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminServicesBackupFormController);

	        $state = _$state_;
	        this.$scope = $scope;
	        $stateParams = _$stateParams_;
	        RepoDataDao = _RepoDataDao_;
	        BackupDao = _BackupDao_;
	        this.JFrogEventBus = JFrogEventBus;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["backup"]);

	        this.isNew = !$stateParams.backupKey;
	        this.TOOLTIP = TOOLTIP.admin.services.backupsForm;
	        this.formTitle = "" + (this.isNew ? "New" : "Edit " + $stateParams.backupKey) + " Backup";
	        this._initBackup();

	        this.fileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export Backup",
	            pathLabel: "Path to Export Backup",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            RepoDataDao.getForBackup().$promise.then(function (repoData) {
	                _this.addRepos(repoData.repoList);
	            });
	        });
	    }

	    _createClass(AdminServicesBackupFormController, {
	        addRepos: {
	            value: function addRepos(repoList) {
	                var _this = this;

	                repoList.forEach(function (repo) {
	                    if (_this.backup.excludeRepos.indexOf(repo) == -1 && _this.backup.includeRepos.indexOf(repo) == -1) {
	                        _this.backup.includeRepos.push(repo);
	                    }
	                });

	                this.ArtifactoryModelSaver.save();
	            }
	        },
	        _initBackup: {
	            value: function _initBackup() {
	                var _this = this;

	                if (this.isNew) {
	                    RepoDataDao.getForBackup().$promise.then(function (repoData) {
	                        _this.backup = {
	                            enabled: true,
	                            sendMailOnError: true,
	                            retentionPeriodHours: 168,
	                            includeRepos: repoData.repoList,
	                            excludeRepos: [],
	                            precalculate: false
	                        };

	                        _this.ArtifactoryModelSaver.save();
	                    });
	                } else {
	                    BackupDao.get({ key: $stateParams.backupKey }).$promise.then(function (backup) {
	                        _this.backup = backup;
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        updateFolderPath: {
	            value: function updateFolderPath(directory) {
	                this.backup.dir = directory;
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.savePending) {
	                    return;
	                }this.savePending = true;

	                var whenSaved = this.isNew ? BackupDao.save(this.backup) : BackupDao.update(this.backup);
	                whenSaved.$promise.then(function () {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this._end();
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.backups");
	            }
	        },
	        onClickIncremental: {
	            value: function onClickIncremental() {
	                if (this.backup.incremental) {
	                    this.backup.retentionPeriodHours = 0;
	                    this.backup.createArchive = false;
	                }
	            }
	        },
	        onClickZip: {
	            value: function onClickZip() {
	                if (this.backup.createArchive) {
	                    this.backup.incremental = false;
	                }
	            }
	            /*
	                MOVED TO MAIN BACKUPS GRID
	                runNow() {
	                    BackupDao.runNow({},this.backup).$promise.then((res)=>{
	                       //console.log(res);
	                    });
	                }
	            */

	        }
	    });

	    return AdminServicesBackupFormController;
	})();

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var AdminServicesIndexerController = __webpack_require__(270).AdminServicesIndexerController;

	function indexerConfig($stateProvider) {
	    $stateProvider.state("admin.services.indexer", {
	        params: { feature: "indexer" },
	        url: "/indexer",
	        templateUrl: "states/admin/services/indexer/indexer.html",
	        controller: "AdminServicesIndexerController as AdminServicesIndexer"
	    });
	}

	module.exports = angular.module("indexer", []).config(indexerConfig).controller("AdminServicesIndexerController", AdminServicesIndexerController);

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AdminServicesIndexerController = exports.AdminServicesIndexerController = (function () {
	    function AdminServicesIndexerController($scope, IndexerDao, RepositoriesDao, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AdminServicesIndexerController);

	        this.$scope = $scope;
	        this.indexerDao = IndexerDao.getInstance();
	        this.repositoriesDao = RepositoriesDao;
	        this.indexer = {};
	        this.TOOLTIP = TOOLTIP.admin.services.mavenIndexer;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["indexer"]);
	        this.JFrogEventBus = JFrogEventBus;
	        this.getIndexerObject();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.repositoriesDao.indexerAvailableRepositories({ type: "Maven", layout: "maven-2-default" }).$promise.then(function (repoData) {
	                var repoList = repoData.availableLocalRepos.concat(repoData.availableRemoteRepos).concat(repoData.availableVirtualRepos);
	                _this.addRepos(repoList);
	            });
	        });
	    }

	    _createClass(AdminServicesIndexerController, {
	        getIndexerObject: {
	            value: function getIndexerObject() {
	                var _this = this;

	                this.indexerDao.get().$promise.then(function (result) {
	                    _this.indexer = result;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.getRepoData();
	                });
	            }
	        },
	        addRepos: {
	            value: function addRepos(repoList) {
	                var _this = this;

	                repoList.forEach(function (repo) {
	                    if (_this.indexer.excludedRepos.indexOf(repo) == -1 && _this.indexer.includedRepos.indexOf(repo) == -1) {
	                        _this.indexer.includedRepos.push(repo);
	                    }
	                });

	                this.ArtifactoryModelSaver.save();
	            }
	        },
	        getRepoData: {
	            value: function getRepoData() {
	                var _this = this;

	                if (!this.indexer.includedRepos) {
	                    this.repositoriesDao.indexerAvailableRepositories({ type: "Maven", layout: "maven-2-default" }).$promise.then(function (repos) {
	                        _this.indexer.includedRepos = [];
	                        _this.indexer.excludedRepos = [];
	                        _this.indexer.includedRepos = repos.availableLocalRepos.concat(repos.availableRemoteRepos).concat(repos.availableVirtualRepos);
	                    });
	                }
	            }
	        },
	        runIndexer: {
	            value: function runIndexer() {
	                this.indexerDao.run(this.indexer);
	            }
	        },
	        save: {
	            value: function save(indexer) {
	                var _this = this;

	                this.indexerDao.save(indexer).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;

	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getIndexerObject();
	                });
	            }
	        }
	    });

	    return AdminServicesIndexerController;
	})();

/***/ }),
/* 271 */
/***/ (function(module, exports) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var AdminServicesController = exports.AdminServicesController = function AdminServicesController() {
	  _classCallCheck(this, AdminServicesController);

	  var AdminServices = this;
	  AdminServices.stateUrl = "/services";
	  AdminServices.controllerName = "AdminServicesController";
	};

/***/ }),
/* 272 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var AdminController = exports.AdminController = (function () {
	    function AdminController($state, AdminMenuItems, ArtifactoryState, User, ArtifactoryFeatures) {
	        _classCallCheck(this, AdminController);

	        this.items = AdminMenuItems;
	        this.state = $state;
	        this.user = User.getCurrent();
	        this.artifactoryState = ArtifactoryState;
	        this.features = ArtifactoryFeatures;
	        this._goToSpecificAdminState();
	    }

	    _createClass(AdminController, {
	        _goToSpecificAdminState: {
	            value: function _goToSpecificAdminState() {
	                if (this.state.current.name !== "admin") {
	                    if (!this.state.current.name.match(/(?:.new|.edit)\b/)) {
	                        this.artifactoryState.setState("lastAdminState", this.state.current);
	                        this.artifactoryState.setState("lastAdminStateParams", this.state.params);
	                    }
	                    return;
	                }

	                var state = this.artifactoryState.getState("lastAdminState");
	                var stateParams = this.artifactoryState.getState("lastAdminStateParams");
	                var feature = state && state.params && state.params.feature;
	                if (!state || !this.user.canView(state.name) || this.features.isDisabled(feature) || this.features.isHidden(feature)) {
	                    state = this.user.isAdmin() ? "admin.repositories.list" : "admin.security.permissions";
	                    stateParams = this.user.isAdmin() ? { repoType: "local" } : {};
	                }
	                this.state.go(state, stateParams);
	            }
	        },
	        isDashboard: {
	            value: function isDashboard() {
	                return this.state.$current.includes["admin.dashboard"];
	            }
	        }
	    });

	    return AdminController;
	})();

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var ArtifactsController = __webpack_require__(274).ArtifactsController;

	var BrowsersController = __webpack_require__(276).BrowsersController;

	var jfTreeSearch = __webpack_require__(277).jfTreeSearch;

	var jfTreeBrowser = __webpack_require__(279).jfTreeBrowser;

	var jfStashBrowser = __webpack_require__(283).jfStashBrowser;

	var jfSimpleBrowser = __webpack_require__(285).jfSimpleBrowser;

	var selectTargetPathFactory = __webpack_require__(287).selectTargetPathFactory;

	var commonGridColumns = __webpack_require__(288).commonGridColumns;

	var selectDeleteVersionsFactory = __webpack_require__(289).selectDeleteVersionsFactory;

	var jfArtifactInfo = __webpack_require__(290).jfArtifactInfo;

	var infoTabs = _interopRequire(__webpack_require__(292));

	function artifactsConfig($stateProvider, $urlMatcherFactoryProvider) {

	    $urlMatcherFactoryProvider.type("pathParam", {
	        encode: function encode(item) {
	            return item;
	        },
	        decode: function decode(item) {
	            return item;
	        },
	        is: function is(item) {
	            return true;
	        }
	    });
	    $stateProvider.state("artifacts", {
	        url: "/artifacts",
	        parent: "app-layout",
	        abstract: true,
	        templateUrl: "states/artifacts/artifacts.html",
	        controller: "ArtifactsController as Artifact",
	        onExit: function (ArtifactoryState, TreeBrowserDao) {
	            // Stop saving last state of tree
	            ArtifactoryState.removeState("lastTreeState");
	            // Invalidate the tree node cache
	            TreeBrowserDao.invalidateRoots();
	        },
	        onEnter: function (ArtifactoryState) {
	            // This should be true only when going from tree to simple before selecting any node in the tree
	            ArtifactoryState.setState("tree_touched", false);
	        }
	    }).state("artifacts.browsers", {
	        url: "/browse/{browser}",
	        templateUrl: "states/artifacts/browsers/browsers.html",
	        controller: "BrowsersController as Browsers",
	        onEnter: function (ArtifactoryStorage, $stateParams) {
	            if ($stateParams.browser !== "stash") ArtifactoryStorage.setItem("BROWSER", $stateParams.browser);
	        }
	    }).state("artifacts.browsers.path", {
	        url: "/{tab}/{artifact:pathParam}",
	        onEnter: function (JFrogEventBus, $stateParams, ArtifactoryState) {
	            // Save state of tree
	            ArtifactoryState.setState("lastTreeState", { name: "artifacts.browsers.path", params: $stateParams });
	            JFrogEventBus.dispatch(JFrogEventBus.getEventsDefinition().TABS_URL_CHANGED, $stateParams);
	        },
	        params: {
	            forceLoad: false // used to force reload of state even if it's the same artifact
	        }
	    });
	}

	module.exports = angular.module("artifacts", ["infoTabs"]).config(artifactsConfig).controller("ArtifactsController", ArtifactsController).controller("BrowsersController", BrowsersController).directive("jfTreeSearch", jfTreeSearch).directive("jfTreeBrowser", jfTreeBrowser).directive("jfSimpleBrowser", jfSimpleBrowser).directive("jfStashBrowser", jfStashBrowser).directive("jfArtifactInfo", jfArtifactInfo).factory("selectTargetPath", selectTargetPathFactory).factory("commonGridColumns", commonGridColumns).factory("selectDeleteVersions", selectDeleteVersionsFactory);

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var TOOLTIPS = _interopRequire(__webpack_require__(96));

	var ICONS = _interopRequire(__webpack_require__(275));

	var ACTIONS = _interopRequire(__webpack_require__(159));

	var ArtifactsController = exports.ArtifactsController = (function () {
	    function ArtifactsController($rootScope, $scope, $state, JFrogEventBus, ArtifactoryState, SetMeUpModal, ArtifactoryDeployModal, User, ArtifactActions, JFrogModal, GoogleAnalytics) {
	        _classCallCheck(this, ArtifactsController);

	        this.JFrogEventBus = JFrogEventBus;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$rootScope = $rootScope;
	        this.node = null;
	        this.deployModal = ArtifactoryDeployModal;
	        this.setMeUpModal = SetMeUpModal;
	        this.artifactoryState = ArtifactoryState;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.tooltips = TOOLTIPS;
	        this.icons = ICONS;
	        this.artifactActions = ArtifactActions;

	        this.user = User.getCurrent();

	        this.initEvents();
	        this.modal = JFrogModal;
	        this.initNoPermissionsModalScope();
	    }

	    _createClass(ArtifactsController, {
	        initNoPermissionsModalScope: {
	            value: function initNoPermissionsModalScope() {
	                this.noPermissionsModalScope = this.$rootScope.$new();
	                this.noPermissionsModalScope.modalTitle = "No Access Privileges";
	                this.noPermissionsModalScope.modalText = "You do not have permissions defined for any repository.<br/>" + "To gain access, make sure you are logged in, or contact your Artifactory administrator.";
	            }
	        },
	        launchNoPermissionsModal: {
	            value: function launchNoPermissionsModal() {
	                var _this = this;

	                this.modalInstance = this.modal.launchModal("no_permissions_modal", this.noPermissionsModalScope);
	                this.modalInstance.result["finally"](function () {
	                    _this.modalInstance.close();
	                    _this.$state.go("home");
	                });
	            }
	        },
	        getNodeIcon: {
	            value: function getNodeIcon() {
	                if (this.node && this.node.data) {
	                    var type = this.icons[this.node.data.iconType];
	                    if (!type) type = this.icons["default"];
	                    return type && type.icon;
	                }
	            }
	        },
	        openSetMeUp: {
	            value: function openSetMeUp() {
	                this.GoogleAnalytics.trackEvent("Artifacts", "Set me up - Open", this.node.data.repoPkgType, null, this.node.data.repoType);
	                this.setMeUpModal.launch(this.node);
	            }
	        },
	        openDeploy: {
	            value: function openDeploy() {
	                if (this.node && this.node.data) this.GoogleAnalytics.trackEvent("Artifacts", "Open deploy", this.node.data.repoPkgType, null, this.node.data.repoType);
	                this.deployModal.launch(this.node);
	            }
	        },
	        initEvents: {
	            value: function initEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_NODE_SELECT, function (node) {
	                    return _this.selectNode(node);
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this.node.data.refreshWatchActions().then(function () {
	                        _this.actionsController.setActions(_this.node.data.actions);
	                    });
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_DATA_IS_SET, function (treeHasData) {
	                    _this.treeDataIsSet = true;
	                    if (!treeHasData) {
	                        _this.launchNoPermissionsModal();
	                    }
	                });
	            }
	        },
	        selectNode: {
	            value: function selectNode(node) {
	                var _this = this;

	                var previousNode = this.node;
	                this.node = node;

	                if (node.data) {
	                    this.artifactoryState.setState("repoKey", this.node.data.repoKey);
	                    var _location = true;
	                    if (this.$state.current.name === "artifacts.browsers.path" && (!previousNode || !this.$state.params.artifact && this.$state.params.tab !== "StashInfo")) {
	                        // If no artifact and selecting artifact - replace the location (fix back button bug)
	                        _location = "replace";
	                    }
	                    this.$state.go(this.$state.current, { artifact: node.data.fullpath }, { location: _location });

	                    this.actionsController.setCurrentEntity(node);
	                    this.node.data.getDownloadPath().then(function () {
	                        var downloadAction = _.findWhere(node.data.actions, { name: "Download" });
	                        if (downloadAction) {
	                            downloadAction.href = node.data.actualDownloadPath;
	                        }
	                        _this.actionsController.setActions(node.data.actions);
	                    });
	                } else {
	                    this.artifactoryState.removeState("repoKey");
	                    this.$state.go(this.$state.current, { artifact: "" });
	                    this.actionsController.setActions([]);
	                }
	            }
	        },
	        exitStashState: {
	            value: function exitStashState() {
	                this.JFrogEventBus.dispatch(EVENTS.ACTION_EXIT_STASH);
	            }
	        },
	        hasData: {
	            value: function hasData() {
	                return this.artifactoryState.getState("hasArtifactsData") !== false;
	            }
	        },
	        initActions: {
	            value: function initActions(actionsController) {
	                this.actionsController = actionsController;
	                actionsController.setActionsHandler(this.artifactActions);
	                actionsController.setActionsDictionary(ACTIONS);
	            }
	        },
	        deployIsDisabled: {
	            value: function deployIsDisabled() {
	                if (!this.user.getCanDeploy()) {
	                    this.disabledTooltip = this.tooltips.artifacts.deploy.noDeployPermission;
	                    return true;
	                }
	                return false;
	            }
	        }
	    });

	    return ArtifactsController;
	})();

	// Close and go home...

/***/ }),
/* 275 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    "default": {
	        icon: "icon icon-general"
	    },
	    virtualRemoteFile: {
	        icon: "icon icon-general"
	    },
	    go_up: {
	        icon: "icon icon-folder go-up"
	    },
	    localRepository: {
	        icon: "icon icon-local-repo"
	    },
	    cachedRepository: {
	        icon: "icon icon-cached-repo"
	    },
	    virtualRepository: {
	        icon: "icon icon-virtual-repo"
	    },
	    distributionRepository: {
	        icon: "icon icon-distribution-repo"
	    },
	    remoteRepository: {
	        icon: "icon icon-remote-repo"
	    },
	    stash: {
	        icon: "icon icon-search"
	    },
	    trashcan: {
	        icon: "icon icon-trash"
	    },
	    folder: {
	        icon: "icon icon-folder"
	    },
	    virtualRemoteFolder: {
	        icon: "icon icon-folder"
	    },
	    compactedFolder: {
	        icon: "icon icon-folder"
	    },
	    "application/x-maven-pom+xml": {
	        icon: "icon icon-pom"
	    },
	    "application/xml": {
	        icon: "icon icon-xml"
	    },
	    "application/pdf": {
	        icon: "icon icon-pdf"
	    },
	    "text/html": {
	        icon: "icon icon-html"
	    },
	    "text/plain": {
	        icon: "icon icon-txt"
	    },
	    "text/css": {
	        icon: "icon icon-css"
	    },
	    "application/json": {
	        icon: "icon icon-json"
	    },
	    "application/x-debian-package": {
	        icon: "icon icon-deb"
	    },
	    "application/javascript": {
	        icon: "icon icon-js"
	    },
	    "application/x-rubygems": {
	        icon: "icon icon-ruby-gems"
	    },
	    "text/x-java-source": {
	        icon: "icon icon-java"
	    },
	    "x-groovy-source": {
	        icon: "icon icon-groovy"
	    },
	    "text/x-c": {
	        icon: "icon icon-c"
	    },
	    "text/x-csharp": {
	        icon: "icon icon-c-2"
	    },
	    "application/zip": {
	        icon: "icon icon-zip"
	    },
	    "application/x-gzip": {
	        icon: "icon icon-gz"
	    },
	    "application/x-gtar": {
	        icon: "icon icon-gz"
	    },
	    "application/x-tar": {
	        icon: "icon icon-tar"
	    },
	    "application/x-nupkg": {
	        icon: "icon icon-nuget"
	    },
	    "application/x-rpm": {
	        icon: "icon icon-rpm"
	    },
	    "text/x-scala-source": {
	        icon: "icon icon-scala"
	    },
	    "application/java-archive": {
	        icon: "icon icon-jar"
	    },
	    "application/octet-stream": {
	        icon: "icon icon-general"
	    },
	    docker: {
	        icon: "icon icon-docker"
	    },
	    bower: {
	        icon: "icon icon-bower"
	    },
	    npm: {
	        icon: "icon icon-npm"
	    },
	    cocoapods: {
	        icon: "icon icon-cocoapods"
	    },
	    gitlfs: {
	        icon: "icon icon-git-lfs"
	    },
	    opkg: {
	        icon: "icon icon-opkg"
	    },
	    composer: {
	        icon: "icon icon-composer"
	    },
	    conan: {
	        icon: "icon icon-conan"
	    },
	    puppet: {
	        icon: "icon icon-puppet"
	    },
	    pypi: {
	        icon: "icon icon-pypi"
	    },
	    gradle: {
	        icon: "icon icon-gradle"
	    },
	    vagrant: {
	        icon: "icon icon-vagrant"
	    }
	};

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var BrowsersController = exports.BrowsersController = (function () {
	    function BrowsersController($timeout, $scope, $stateParams, $state, TreeBrowserDao, JFrogEventBus, hotkeys, ArtifactoryState) {
	        var _this = this;

	        _classCallCheck(this, BrowsersController);

	        this.JFrogEventBus = JFrogEventBus;
	        this.stateParams = $stateParams;
	        this.state = $state;
	        this.treeBrowserDao = TreeBrowserDao;
	        this.artifactoryState = ArtifactoryState;
	        this.compactFolders = TreeBrowserDao.getCompactFolders();
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.hotkeys = hotkeys;
	        this._setupKeyHints();
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_NODE_SELECT, function (node) {
	            return _this.selectedNode = node;
	        });

	        var activeFilter = this.artifactoryState.getState("activeFilter");
	        this.activeFilter = activeFilter ? true : false;
	        this.searchText = activeFilter || "";

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_SEARCH_RUNNING, function (running) {
	            _this.searchInAction = running;
	        });

	        this.sendWindowResizeEvent();
	    }

	    _createClass(BrowsersController, {
	        toggleCompactFolders: {
	            value: function toggleCompactFolders() {
	                this.treeBrowserDao.setCompactFolders(this.compactFolders);
	                this.JFrogEventBus.dispatch(EVENTS.TREE_COMPACT, this.compactFolders);
	            }
	        },
	        showTreeSearch: {
	            value: function showTreeSearch() {
	                this.JFrogEventBus.dispatch(EVENTS.ACTIVATE_TREE_SEARCH);
	            }
	        },
	        switchBrowser: {
	            value: function switchBrowser(browser) {
	                this.artifactoryState.setState("activeFilter", this.activeFilter ? this.searchText : undefined);

	                // Reclicking simple browser when we are already in simple browser - go to root
	                if (browser === "simple" && this.stateParams.browser === "simple") {
	                    var repo = this.selectedNode.data.getRoot();
	                    // Make sure roots are visible:
	                    this.artifactoryState.setState("tree_touched", false);
	                    // Use forceLoad as a Date to ensure state transition even if it's the same as before
	                    this.state.go(this.state.current.name, { browser: browser, artifact: repo.fullpath, forceLoad: new Date() });
	                } else if (browser === "tree" && this.stateParams.browser === "tree") {
	                    this.JFrogEventBus.dispatch(EVENTS.TREE_COLLAPSE_ALL);
	                } else if (browser != this.stateParams.browser) {
	                    this.state.go(this.state.current.name, { browser: browser });
	                    this.treeBrowserDao.invalidateRoots();
	                    // console.log(" from "+this.stateParams.browser+" to "+browser);
	                }
	            }
	        },
	        _setupKeyHints: {
	            value: function _setupKeyHints() {
	                this.hotkeys.bindTo(this.$scope).add({
	                    combo: "Enter",
	                    description: "Select node"
	                }).add({
	                    combo: "Esc",
	                    description: "Cancel search / deselect node"
	                }).add({
	                    combo: "Down",
	                    description: "Navigate down in tree / in search results"
	                }).add({
	                    combo: "Up",
	                    description: "Navigate up in tree / in search results"
	                }).add({
	                    combo: "Right",
	                    description: "Expand folder"
	                }).add({
	                    combo: "Left",
	                    description: "Collapse folder"
	                });
	            }
	        },
	        clearFilter: {
	            value: function clearFilter() {
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	            }
	        },
	        compressEmptyFoldersLabelIsOverflowing: {
	            value: function compressEmptyFoldersLabelIsOverflowing() {
	                var header = $(".tree-browser-header");
	                return header.length > 0 && header.width() < 424;
	            }
	        },
	        sendWindowResizeEvent: {
	            value: function sendWindowResizeEvent() {
	                var _this = this;

	                var resizeEvent = document.createEvent("Event");
	                resizeEvent.initEvent("resize", false, true);
	                var doSafeResize = function () {
	                    try {
	                        window.dispatchEvent(new Event("resize"));
	                    } catch (e) {
	                        window.dispatchEvent(resizeEvent);
	                    }
	                };

	                this.$timeout(function () {
	                    doSafeResize();
	                    _this.$timeout(function () {
	                        doSafeResize();
	                    });
	                });
	            }
	        }
	    });

	    return BrowsersController;
	})();

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfTreeSearch = jfTreeSearch;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var KEYS = _interopRequire(__webpack_require__(278));

	function jfTreeSearch() {
	    return {
	        restrict: "E",
	        controller: TreeSearchController,
	        controllerAs: "TreeSearch",
	        templateUrl: "states/artifacts/jf_tree_search/jf_tree_search.html",
	        bindToController: true
	    };
	}

	var TreeSearchController = (function () {
	    function TreeSearchController(JFrogEventBus, $element, hotkeys, $scope, $timeout) {
	        var _this = this;

	        _classCallCheck(this, TreeSearchController);

	        this.$scope = $scope;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        this.term = "";
	        this.showSearch = false;
	        this.hotkeys = hotkeys;
	        this._setupHotkeys();

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.ACTIVATE_TREE_SEARCH, function () {
	            $timeout(function () {
	                _this._activateSearch();
	            });
	        });
	    }

	    _createClass(TreeSearchController, {
	        onChange: {
	            value: function onChange() {
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CHANGE, this.term);
	            }
	        },
	        onKeydown: {
	            value: function onKeydown($event) {
	                // Send events to tree on key down / up / enter
	                if (_.include([KEYS.ENTER, KEYS.DOWN_ARROW, KEYS.UP_ARROW, KEYS.ESC], $event.keyCode)) {
	                    $event.preventDefault();
	                    // Deactivate on enter press
	                    if (_.include([KEYS.ENTER, KEYS.ESC], $event.keyCode)) {
	                        this._deactivateSearch();
	                    }
	                }
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_KEYDOWN, $event.keyCode);
	            }
	        },
	        _deactivateSearch: {
	            value: function _deactivateSearch() {
	                this.term = "";
	                this.showSearch = false;
	                this.$searchInput().blur();
	                $("body").off("click.outsideTreeSearch");
	            }
	        },
	        _activateSearch: {
	            value: function _activateSearch(key) {
	                var _this = this;

	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	                this.showSearch = true;
	                this.$timeout(function () {
	                    if (!_this.term) {
	                        //fix for firefox not showing the first key
	                        _this.term = key;
	                        _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CHANGE, _this.term);
	                    }
	                });
	                this.$searchInput().focus();
	                $("body").on("click.outsideTreeSearch", function (e) {
	                    if (!$(_this.$element).has(e.target).length) {
	                        _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	                        _this._deactivateSearch();
	                        if (!_this.$scope.$$phase) _this.$scope.$digest();
	                    }
	                });
	            }
	        },
	        $searchInput: {
	            value: function $searchInput() {
	                return this.$element.find("input")[0];
	            }
	        },
	        _setupHotkeys: {
	            value: function _setupHotkeys() {
	                var _this = this;

	                this.hotkeys.bindTo(this.$scope).add({
	                    combo: KEYS.HOTKEYS.ALPHANUMERIC.split(""),
	                    description: "Any alphanumeric key to search the tree",
	                    callback: function (event, hotkey) {
	                        if (_.contains(event.target.classList, "jstree-anchor")) {
	                            //                    var key = hotkey.format()[0];
	                            var key = String.fromCharCode(event.which);
	                            _this._activateSearch(key);
	                        }
	                    }
	                });
	            }
	        }
	    });

	    return TreeSearchController;
	})();

/***/ }),
/* 278 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    ENTER: 13,
	    ESC: 27,
	    SPACE: 32,
	    UP_ARROW: 38,
	    DOWN_ARROW: 40,
	    HOTKEYS: {
	        ALPHANUMERIC: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_"
	    },
	    PROPERTY_TYPE: {
	        MULTI_SELECT: null,
	        SINGLE_SELECT: 1,
	        ANY_VALUE: 0
	    }
	};

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	/**
	 * wrapper around the jstree jquery component
	 * @url http://www.jstree.com/
	 *
	 * @returns {{restrict: string, controller, controllerAs: string, bindToController: boolean}}
	 */
	exports.jfTreeBrowser = jfTreeBrowser;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TreeConfig = _interopRequire(__webpack_require__(280));

	var JFCommonBrowser = _interopRequire(__webpack_require__(282));

	function jfTreeBrowser() {
	    return {
	        scope: {
	            browserController: "="
	        },
	        restrict: "E",
	        controller: JFTreeBrowserController,
	        controllerAs: "jfTreeBrowser",
	        templateUrl: "states/artifacts/jf_tree_browser/jf_tree_browser.html",
	        bindToController: true,
	        link: function link($scope) {
	            $scope.jfTreeBrowser.initJSTree();
	        }
	    };
	}

	var ARCHIVE_MARKER = "!";

	var JFTreeBrowserController = (function (_JFCommonBrowser) {
	    function JFTreeBrowserController($state, $timeout, $compile, JFrogEventBus, $element, $scope, TreeBrowserDao, $stateParams, $q, ArtifactoryState, ArtifactActions, JFrogNotifications, NativeBrowser, User, AdvancedStringMatch, JFrogUIUtils) {
	        var _this = this;

	        _classCallCheck(this, JFTreeBrowserController);

	        _get(Object.getPrototypeOf(JFTreeBrowserController.prototype), "constructor", this).call(this, ArtifactActions, AdvancedStringMatch, ArtifactoryState);
	        this.type = "tree";
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$compile = $compile;
	        this.$stateParams = $stateParams;
	        this.$q = $q;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.treeBrowserDao = TreeBrowserDao;
	        this.artifactoryState = ArtifactoryState;
	        this.user = User.currentUser;
	        this.nativeBrowser = NativeBrowser;

	        this.spinnerTimeout = this.$timeout(function () {
	            _this.JFrogEventBus.dispatch(_this.EVENTS.SHOW_SPINNER);
	        }, 600);

	        if (_.isUndefined($stateParams.artifact)) {
	            // Important to know for switching to simple browser
	            this.whenTreeDataLoaded = $q.when([]);

	            // Handle a case of no artifact and tab properties in state params
	            this.dataLoaded = function () {
	                var theTree = $("#tree-element");
	                var firstNode = theTree.find(".jstree-node").first();

	                $stateParams.tab = "General";
	                $stateParams.artifact = firstNode.text();
	                _this.whenTreeDataLoaded = TreeBrowserDao.findNodeByFullPath($stateParams.artifact);

	                // Change the state URL (without redirecting)
	                _this.$state.transitionTo("artifacts.browsers.path", _this.$stateParams, { location: "replace", inherit: true, notify: false });

	                // Unbind
	                _this.dataLoaded = function () {};
	            };
	        } else {
	            this.whenTreeDataLoaded = TreeBrowserDao.findNodeByFullPath($stateParams.artifact); // Preload data for the current selected artifact
	        }

	        this.$element = $element;

	        var doRefresh = this.artifactoryState.getState("refreshTreeNextTime");
	        if (doRefresh) {
	            $timeout(function () {
	                return _this._refreshTree();
	            });
	            this.artifactoryState.setState("refreshTreeNextTime", false);
	        }
	    }

	    _inherits(JFTreeBrowserController, _JFCommonBrowser);

	    _createClass(JFTreeBrowserController, {
	        dataLoaded: {
	            value: function dataLoaded() {}
	        },
	        initJSTree: {

	            /****************************
	             * Init code
	             ****************************/

	            // This is called from link function

	            value: function initJSTree() {
	                var _this = this;

	                // preload artifact
	                this.whenTreeDataLoaded.then(function () {
	                    _this.treeElement = $(_this.$element).find("#tree-element");
	                    _this._registerEvents();
	                    _this._buildTree();
	                    _this._registerTreeEvents();
	                });
	            }
	        },
	        _openTreeNode: {

	            /**
	             * When JStree is ready load the current browsing path from URL
	             * and restore the nodes open and selected state.
	             * @param e
	             * @private
	             */

	            value: function _openTreeNode(artifact) {
	                var _this = this;

	                var deferred = this.$q.defer();
	                var jstree = this.jstree();
	                var root = jstree.get_node("#");
	                var path = _.trim(artifact ? artifact.replace("//", "/") : "", "/").split("/");

	                this._openNodePath(root, path, jstree.get_node(root.children[0]), function (selectedNode) {
	                    jstree.deselect_all();
	                    // Select the node
	                    jstree.select_node(selectedNode);

	                    // scroll the node into view
	                    var domElement = _this._getDomElement(selectedNode);
	                    _this._scrollIntoView(domElement);
	                    _this._focusOnTree();
	                    deferred.resolve();
	                });
	                return deferred.promise;
	            }
	        },
	        _onReady: {
	            value: function _onReady() {
	                var _this = this;

	                this.$timeout(function () {
	                    _this._initTrashPin();
	                    _this.$timeout.cancel(_this.spinnerTimeout);
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.HIDE_SPINNER);
	                }, 100);

	                this._openTreeNode(this.$stateParams.artifact);
	                this.jstree().show_dots();
	                $("a.jstree-clicked").focus();
	            }
	        },
	        _registerEvents: {

	            /****************************
	             * Event registration
	             ****************************/

	            value: function _registerEvents() {
	                var _this = this;

	                // Must destroy jstree on scope destroy to prevent memory leak:
	                this.$scope.$on("$destroy", function () {
	                    if (_this.jstree()) {
	                        _this.jstree().destroy();
	                    }
	                    $(window).off("resize");
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_IGNORE_ALERT, function (node) {
	                    var options = {
	                        target: {
	                            targetRepoKey: node.data.repoKey,
	                            targetPath: node.data.path
	                        },
	                        node: node };
	                    _this._refreshFolderPath(options); // Refresh target folder where node was copied
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_UNIGNORE_ALERT, function (node) {
	                    var options = {
	                        target: {
	                            targetRepoKey: node.data.repoKey,
	                            targetPath: node.data.path
	                        },
	                        node: node };
	                    _this._refreshFolderPath(options); // Refresh target folder where node was copied
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CHANGE, function (text) {
	                    return _this._searchTree(text);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CANCEL, function (text) {
	                    return _this._clear_search();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_KEYDOWN, function (key) {
	                    return _this._searchTreeKeyDown(key);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DEPLOY, function (eventArgs) {
	                    var repoKey = eventArgs[0];
	                    _this._refreshRepo(repoKey);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_REFRESH, function (node) {
	                    return _this._refreshFolder(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_REFRESH, function (node) {
	                    return node ? _this._refreshFolder(node) : _this._refreshTree();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE, function (node) {
	                    _this._refreshParentFolder(node); // Refresh folder of node's parent
	                    _this.refreshTrashCan();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_MOVE, function (options) {
	                    _this._refreshParentFolder(options.node); // Refresh folder of node's parent
	                    _this._refreshFolderPath(options); // Refresh target folder where node was copied
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_COPY, function (options) {
	                    _this._refreshFolderPath(options);
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_NODE_OPEN, function (path) {
	                    _this._openTreeNode(path);
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COLLAPSE_ALL, function () {
	                    _this._collapseAll();
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COMPACT, function () {
	                    return _this._toggleCompactFolders();
	                });

	                // URL changed (like back button / forward button / someone input a URL)
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TABS_URL_CHANGED, function (stateParams) {
	                    if (stateParams.browser != "tree") return;
	                    // Check if it's already the current selected node (to prevent opening the same tree node twice)
	                    var selectedNode = _this._getSelectedTreeNode();
	                    if (selectedNode && selectedNode.fullpath === stateParams.artifact) return;
	                    _this.treeBrowserDao.findNodeByFullPath(stateParams.artifact).then(function () {
	                        return _this._openTreeNode(stateParams.artifact);
	                    });
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.REFRESH_PAGE_CONTENT, function () {
	                    _this._refreshTree();
	                });

	                $(window).on("resize", function () {
	                    return _this._resizePinnedTrash();
	                });
	                this.$scope.$on("ui-layout.resize", function () {
	                    return _this._resizePinnedTrash();
	                });
	            }
	        },
	        _registerTreeEvents: {

	            /**
	             * register a listener on the tree and delegate to
	             * relevant methods
	             *
	             * @param element
	             * @private
	             */

	            value: function _registerTreeEvents() {
	                var _this = this;

	                //        $(this.treeElement).on("search.jstree", (e, data) => this._onSearch(e, data));
	                $(this.treeElement).on("ready.jstree", function (e) {
	                    return _this._onReady(e);
	                });
	                $(this.treeElement).on("mousedown", function (e) {
	                    return e.preventDefault();
	                });

	                $(this.treeElement).on("select_node.jstree", function (e, args) {
	                    if (args.event) {
	                        // User clicked / pressed enter
	                        _this.artifactoryState.setState("tree_touched", true);
	                    }
	                    // Allow scroll only after an artifact is selected (important for after tree is loaded)
	                    _this.allowAutoScroll = true;
	                    _this._loadNode(args.node);
	                });

	                $(this.treeElement).on("activate_node.jstree", function (e, args) {
	                    if (args.event) {
	                        // User clicked / pressed enter
	                        _this.artifactoryState.setState("tree_touched", true);
	                    }
	                });

	                $(this.treeElement).on("after_open.jstree", function (e, args) {
	                    var nodeIsTrash = args.node && args.node.data && args.node.data.isTrashcan && args.node.data.isTrashcan();
	                    if (nodeIsTrash) _this._initTrashPin();

	                    if (_this.activeFilter) _this._searchTree(_this.searchText, false, false);

	                    _this._setScrolledTreeRegion(args.node);

	                    var elemToFocus = args.node.id;
	                    if (_this.$autoScrollInTrash || _this.$autoScroll) {
	                        _this._focusOnTree(elemToFocus);
	                        if (_this.allowAutoScroll) {
	                            _this._autoScroll(args.node, _this.$autoScrollInTrash);
	                        }
	                    } else {
	                        _this._focusOnTree();
	                    }
	                });

	                $(this.treeElement).on("after_close.jstree", function (e, args) {
	                    var nodeIsTrash = args.node && args.node.data && args.node.data.isTrashcan && args.node.data.isTrashcan();
	                    if (nodeIsTrash) _this._initTrashPin();
	                });
	                $(this.treeElement).on("load_node.jstree", function (e, args) {
	                    var nodeIsTrash = args.node && args.node.data && args.node.data.isTrashcan && args.node.data.isTrashcan();
	                    if (nodeIsTrash || args.node.id === "#") _this._initTrashPin();
	                    if (_this.activeFilter) _this._searchTree(_this.searchText, false, false);
	                });

	                $("#tree-element").on("keydown", function (e) {
	                    if (e.keyCode === 37 && e.ctrlKey) {
	                        //CTRL + LEFT ARROW --> Collapse All !
	                        _this._collapseAll();
	                    } else if (e.keyCode === 13) {
	                        var node = _this.jstree().get_selected(true)[0];
	                        _this.jstree().toggle_node(node);
	                    }
	                });

	                $(this.treeElement).scroll(function () {
	                    return _this._onScroll();
	                });
	            }
	        },
	        _setScrolledTreeRegion: {

	            /**
	             * Determine for the current node whether the scroll should be from
	             * the tree root or from the trashcan element
	             *
	             * @param node
	             * @private
	             * */

	            value: function _setScrolledTreeRegion(node) {
	                var nodeIsTrash = node.data && node.data.isTrashcan && node.data.isTrashcan();
	                var nodeIsInTrash = node.data && node.data.isInTrashcan && node.data.isInTrashcan();

	                this.$autoScroll = true;
	                this.$autoScrollInTrash = false;

	                if ((nodeIsTrash || nodeIsInTrash) && this.isTrashPinned()) {
	                    this.$autoScroll = false;
	                    this.$autoScrollInTrash = true;
	                }
	            }
	        },
	        _autoScroll: {
	            value: function _autoScroll(node, scrollInTrash) {
	                var _this = this;

	                var treeItem = $("#" + node.id).find(".jstree-children")[0];
	                if (!treeItem) {
	                    return;
	                }var theTree = $("#tree-element");
	                theTree = scrollInTrash ? theTree.find(".jstree-li-the-trashcan") : theTree;

	                var numOfChildrens = $(treeItem).find("> div").length,
	                    heightOfElement = theTree.find(".jstree-anchor").first().height(),
	                    treeWrapperHeight = theTree.offset().top + theTree.height();

	                if ($(treeItem).offset().top + heightOfElement * 2 > treeWrapperHeight) {
	                    (function () {
	                        var currentScroll = theTree.scrollTop();
	                        var sctollTo = undefined,
	                            addedScroll = undefined;

	                        if (numOfChildrens > 3) {
	                            addedScroll = heightOfElement * 3 + heightOfElement / 2 + 5;
	                        }
	                        if (numOfChildrens <= 3) {
	                            addedScroll = heightOfElement * numOfChildrens;
	                        }
	                        // Scroll when trash is pinned
	                        if (scrollInTrash && _this.isTrashPinned()) {
	                            addedScroll = $(treeItem).position().top - heightOfElement;
	                        }

	                        sctollTo = currentScroll + addedScroll;

	                        _this.$timeout(function () {
	                            theTree.animate({ scrollTop: sctollTo });
	                        });
	                    })();
	                }
	            }
	        },
	        _resizePinnedTrash: {
	            value: function _resizePinnedTrash() {
	                var e = $(".jstree-li-the-trashcan");
	                if (e.hasClass("pinned")) {
	                    var p = e.parent().parent();
	                    e.css("width", p.outerWidth() + "px");

	                    this.treeElement.css("height", "auto");
	                    var h = parseInt(this.treeElement.css("height"));
	                    this.treeElement.css("height", h - e.height() + "px");
	                } else {
	                    e.css("width", "auto");
	                    this.treeElement.css("height", "auto");
	                }

	                var trashPin = $(".trash-pin");
	                trashPin.css("left", e.parent().parent().width() - 50 + "px");
	            }
	        },
	        _collapseAll: {
	            value: function _collapseAll() {
	                var _this = this;

	                var node = this.jstree().get_selected(true)[0];

	                var parentRepoNode = this.jstree().get_node(node.parent);
	                if (parentRepoNode.id === "#") parentRepoNode = node;else {
	                    while (parentRepoNode.parent !== "#") {
	                        parentRepoNode = this.jstree().get_node(parentRepoNode.parent);
	                    }
	                }

	                $("#tree-element").jstree("close_all");
	                this.jstree().select_node(parentRepoNode);
	                this.$timeout(function () {
	                    _this.jstree().close_node(parentRepoNode);
	                });
	            }
	        },
	        _loadNode: {
	            value: function _loadNode(item) {
	                var _this = this;

	                item.data.load().then(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, item);
	                });
	            }
	        },
	        _toggleCompactFolders: {

	            /****************************
	             * Compact folders
	             ****************************/

	            value: function _toggleCompactFolders() {
	                this._refreshTree();
	            }
	        },
	        _buildTree: {

	            /****************************
	             * Building the tree
	             ****************************/

	            value: function _buildTree() {
	                var _this = this;

	                var asyncStateLoad = function (obj, cb) {
	                    var promise = undefined;
	                    if (obj.id === "#") {
	                        promise = _this.treeBrowserDao.getRoots();
	                    } else {
	                        promise = obj.data.getChildren();
	                    }
	                    promise.then(function (data) {
	                        var hasArtifactsData = data.length > 0 || obj.id !== "#";
	                        _this.artifactoryState.setState("hasArtifactsData", hasArtifactsData);
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_DATA_IS_SET, hasArtifactsData);
	                        cb(_this._transformData(data));
	                    }).then(_this.dataLoaded);
	                };

	                TreeConfig.core.data = asyncStateLoad;
	                TreeConfig.contextmenu.items = this._getContextMenuItems.bind(this);

	                // Search by node text only (otherwise searches the whole HTML)
	                TreeConfig.search.search_callback = this._searchCallback.bind(this);

	                $(this.treeElement).jstree(TreeConfig);
	            }
	        },
	        _transformData: {
	            value: function _transformData(data) {
	                var _this = this;

	                data = data || [];
	                return data.map(function (node) {
	                    var item = {};
	                    item.children = node.hasChild;
	                    item.text = node.isTrashcan() ? "<span class=\"trashcan-node\">Trash Can<i ng-show=\"!jfTreeBrowser.isTrashPinned()\" ng-click=\"jfTreeBrowser.toggleTrashPin($event)\" class=\"icon icon-pin trash-pin\" jf-tooltip=\"Pin Trash Can\"></i><i ng-show=\"jfTreeBrowser.isTrashPinned()\" ng-click=\"jfTreeBrowser.toggleTrashPin($event)\" class=\"icon icon-unpin trash-pin\" jf-tooltip=\"Unpin Trash Can\"></i></span>" : _this.JFrogUIUtils.getSafeHtml(node.text);
	                    item.data = node;
	                    item.type = node.iconType;
	                    if (node.isTrashcan()) item.li_attr = { "class": "-the-trashcan" };

	                    var type = typeof node.fileType != "undefined" ? node.fileType : node.type;
	                    // replace the node icon type to the package type if necessary
	                    if (_this._iconsShouldBeReplacedWithRepoPkgTypeIcon(type, node.repoPkgType, node.fullpath)) {
	                        item.type = node.iconType = node.repoPkgType.toLocaleLowerCase();
	                    }

	                    return item;
	                });
	            }
	        },
	        _refreshRepo: {

	            /****************************
	             * Refreshing the tree
	             ****************************/

	            /**
	             * refresh children of folder
	             *
	             * @param node
	             * @private
	             */

	            value: function _refreshRepo(repoKey) {
	                var jstree = this.jstree();
	                var root = jstree.get_node("#");
	                var repoJsNode = undefined;
	                _.each(root.children, function (child) {
	                    repoJsNode = jstree.get_node(child);
	                    if (repoJsNode && repoJsNode.data && repoJsNode.data.repoKey === repoKey) return false;
	                });
	                //console.log(repoJsNode.data.repoKey);
	                if (repoJsNode) {
	                    repoJsNode.data.invalidateChildren();
	                    jstree.load_node(repoJsNode, function () {
	                        jstree.select_node(repoJsNode);
	                    });
	                }
	            }
	        },
	        _refreshFolder: {
	            value: function _refreshFolder(node) {
	                var defer = this.$q.defer();
	                if (node.data) node.data.invalidateChildren();else this.treeBrowserDao.invalidateRoots();
	                this.jstree().load_node(node, function () {
	                    return defer.resolve();
	                });
	                return defer.promise;
	            }
	        },
	        _refreshParentFolder: {
	            value: function _refreshParentFolder(node) {
	                var _this = this;

	                node.data.invalidateParent();
	                var parentNodeItem = this.jstree().get_node(node.parent);
	                var openedChildrenPaths = this._getOpenedChildrenPaths(parentNodeItem);
	                this.$timeout(function () {
	                    _this._refreshFolder(parentNodeItem).then(function () {
	                        _this._openChildrenByPaths(parentNodeItem, openedChildrenPaths);
	                        _this.$timeout(function () {
	                            _this.jstree().hover_node(parentNodeItem);
	                            _this.jstree().select_node(parentNodeItem);
	                        });
	                    });
	                });
	            }
	        },
	        _getOpenedChildrenPaths: {
	            value: function _getOpenedChildrenPaths(parent) {
	                var _this = this;

	                var children = parent.children;
	                var jst = this.jstree();
	                var opened = [];
	                children.forEach(function (child) {
	                    var n = jst.get_node(child);
	                    if (n.state.opened && n.data && n.data.path) {
	                        opened.push(n.data.path);
	                        opened = opened.concat(_this._getOpenedChildrenPaths(n));
	                    }
	                });
	                return opened;
	            }
	        },
	        _openChildrenByPaths: {
	            value: function _openChildrenByPaths(parent, pathsToOpen) {
	                var _this = this;

	                var children = parent.children;
	                var jst = this.jstree();
	                children.forEach(function (child) {
	                    var n = jst.get_node(child);
	                    if (n.data && _.includes(pathsToOpen, n.data.path)) {
	                        jst.open_node(n, function () {
	                            _this._openChildrenByPaths(n, pathsToOpen);
	                        });
	                    }
	                });
	            }
	        },
	        _refreshFolderPath: {
	            value: function _refreshFolderPath(option) {
	                var _this = this;

	                var targetPath = _.compact(option.target.targetPath.split("/"));
	                var path = [option.target.targetRepoKey].concat(targetPath);

	                var curNode = this.jstree().get_node("#");

	                var childNode = this._getChildByPath(curNode, path);
	                if (childNode && _.isArray(childNode.children)) {
	                    curNode = childNode;
	                }

	                // Data is still not refreshed on server
	                this.$timeout(function () {
	                    if (curNode && curNode.data) {
	                        _this._refreshFolder(curNode);
	                        curNode.data.getChildren().then(function () {
	                            _this._openTreeNode(option.target.targetRepoKey + "/" + option.target.targetPath + "/" + option.node.data.text);
	                        });
	                    } else {
	                        _this._openTreeNode(option.target.targetRepoKey + "/" + option.target.targetPath + "/" + option.node.data.text);
	                    }
	                }, 500);
	            }
	        },
	        _refreshTree: {
	            value: function _refreshTree() {
	                this.treeBrowserDao.invalidateRoots();
	                if (this.jstree() && this.jstree().refresh) this.jstree().refresh();
	            }
	        },
	        _getChildByPath: {

	            /****************************
	             * Traversing the tree
	             ****************************/

	            /**
	            * Find the next child by path. Take into account the node's text by consist of some of the path elements (in compact mode)
	            * @param parentNode:Object node object from where to start
	            * @param path:Array array of path elements
	            * @returns childNode or undefined
	            * @private
	            */

	            value: function _getChildByPath(parentNode, path) {
	                var jstree = this.jstree();
	                var children = this._getChildrenOf(parentNode);
	                // Find the node that conforms to the largest subpath of path
	                for (var i = path.length; i > 0; i--) {
	                    var _ret = (function (i) {
	                        var subpath = path.slice(0, i);
	                        var testPathStr = _.trimRight(subpath.join("/"), ARCHIVE_MARKER);
	                        var result = _.find(children, function (childNode) {
	                            // Sometimes the node's text is not the full text (like for docker images)
	                            var childPath = childNode.data.fullpath;

	                            if (childPath === testPathStr || childPath === testPathStr + "/") {
	                                return childNode;
	                            }
	                        });
	                        if (result) return {
	                                v: result
	                            };
	                    })(i);

	                    if (typeof _ret === "object") {
	                        return _ret.v;
	                    }
	                }
	            }
	        },
	        _getChildrenOf: {
	            value: function _getChildrenOf(parentNode) {
	                var jstree = this.jstree();
	                return _.compact(parentNode.children.map(function (jsTreeNodeId) {
	                    return jstree.get_node(jsTreeNodeId);
	                }));
	            }
	        },
	        _openNodePath: {

	            /**
	             * Open the path starting from the root node, and call the callback with the leaf node
	             * and restore the nodes open and selected state.
	             * @param node:Object node object from where to start
	             * @param path:Array array of path elements
	             * @param selectedNode:Object default node to return if not found
	             * @param callback:Function callback to call with leaf node once the traversing is complete
	             * @private
	             */

	            value: function _openNodePath(node, path, leafNode, callback) {
	                var _this = this;

	                var pathStopIndex = arguments[4] === undefined ? 1 : arguments[4];

	                var jstree = this.jstree();
	                var childNode = undefined;
	                while (pathStopIndex <= path.length) {
	                    var testPath = path.slice(0, pathStopIndex);
	                    childNode = this._getChildByPath(node, testPath);
	                    if (childNode) break;
	                    pathStopIndex++;
	                }

	                if (childNode) {
	                    leafNode = childNode;
	                    if (path.length === 0) {
	                        callback(leafNode);
	                    } else {
	                        if (this._isNodeShouldOpenOnClick(leafNode.data)) {
	                            jstree.open_node(leafNode, function (node) {
	                                _this._openNodePath(leafNode, path, leafNode, callback, pathStopIndex + 1);
	                            }, false);
	                        } else {
	                            callback(leafNode);
	                        }
	                    }
	                } else {
	                    callback(leafNode);
	                }
	            }
	        },
	        _isNodeShouldOpenOnClick: {
	            value: function _isNodeShouldOpenOnClick(nodeData) {
	                return !nodeData.isArchive() && nodeData.icon !== "docker" && nodeData.icon !== "conan";
	            }
	        },
	        refreshTrashCan: {
	            value: function refreshTrashCan() {
	                var trashID = $(".trashcan-node").parent().parent().prop("id");
	                var trashNode = this.jstree().get_node(trashID);
	                this.JFrogEventBus.dispatch(this.EVENTS.TREE_REFRESH, trashNode);
	            }
	        },
	        pinTrash: {
	            value: function pinTrash() {
	                var trashElem = $(".jstree-li-the-trashcan");
	                if (!trashElem.length) {
	                    return;
	                }var trashPin = $(".trash-pin");
	                this.tempScrollTop = trashElem.scrollParent().scrollTop();
	                var wasPinned = trashElem.hasClass("pinned");
	                trashElem.addClass("pinned");
	                localStorage.pinnedTrash = true;

	                this.$scope.$broadcast("ui-layout.resize");
	                trashElem.on("scroll", function () {
	                    trashPin.css("left", trashElem.scrollLeft() + trashElem.parent().parent().width() - 50 + "px");
	                });
	                if (!wasPinned) trashPin.scrollParent().scrollTop(0);
	            }
	        },
	        unpinTrash: {
	            value: function unpinTrash() {
	                var trashElem = $(".jstree-li-the-trashcan");
	                if (!trashElem.length) {
	                    return;
	                }trashElem.removeClass("pinned");
	                localStorage.pinnedTrash = false;
	                trashElem.scrollParent().scrollTop(this.tempScrollTop);

	                if (!this._isScrolledIntoView(trashElem.find(".jstree-anchor")[0], 0)) {
	                    this._scrollIntoView($(trashElem.find(".jstree-anchor")[0]));
	                }

	                this.$scope.$broadcast("ui-layout.resize");
	            }
	        },
	        toggleTrashPin: {
	            value: function toggleTrashPin(e) {
	                e.stopImmediatePropagation();
	                e.preventDefault();

	                var trashElem = $(".jstree-li-the-trashcan");
	                if (trashElem.hasClass("pinned")) {
	                    this.unpinTrash();
	                } else {
	                    this.pinTrash();
	                }
	            }
	        },
	        _initTrashPin: {
	            value: function _initTrashPin() {
	                var e = $(".trash-pin");
	                if (!e.prop("compiled")) {
	                    this.$compile(e)(this.$scope);
	                    e.prop("compiled", true);
	                }

	                if (this.isTrashPinned()) {
	                    this.pinTrash();
	                }
	                this.$scope.$broadcast("ui-layout.resize");
	            }
	        },
	        isTrashPinned: {
	            value: function isTrashPinned() {
	                return localStorage.pinnedTrash !== undefined ? localStorage.pinnedTrash === "true" : true;
	            }
	        }
	    });

	    return JFTreeBrowserController;
	})(JFCommonBrowser);

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var TreeConfig = _interopRequire(__webpack_require__(281));

	module.exports = _.cloneDeep(TreeConfig);

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var types = _interopRequire(__webpack_require__(275));

	module.exports = {

	    core: {
	        animation: false,
	        multiple: false
	    },

	    types: types,
	    search: {
	        depthFirst: true,
	        close_opened_onclear: false
	    },

	    contextmenu: {
	        select_node: false,
	        show_at_node: false
	    },

	    plugins: ["search", "types", "contextmenu", "sort"]
	};

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var EVENTS = _interopRequire(__webpack_require__(48));

	var KEYS = _interopRequire(__webpack_require__(278));

	var ACTIONS = _interopRequire(__webpack_require__(159));

	var JSTREE_ROW_HOVER_CLASS = "jstree-hovered";
	var REGEXP = /(pkg|repo)\:(.*)/g;

	var JFCommonBrowser = (function () {
	    function JFCommonBrowser(ArtifactActions, AdvancedStringMatch, ArtifactoryState, $timeout) {
	        _classCallCheck(this, JFCommonBrowser);

	        this.ArtifactoryState = ArtifactoryState;
	        this.advancedStringMatch = AdvancedStringMatch;
	        this.artifactActions = ArtifactActions;
	        this.$timeout = $timeout;
	        this.activeFilter = false;

	        if (this.browserController) {
	            this.activeFilter = this.browserController.activeFilter || false;
	            this.searchText = this.browserController.searchText || "";
	            if (this.searchText.endsWith("*")) this.searchText = this.searchText.substr(0, this.searchText.length - 1);
	        }

	        this._initJSTreeSorting();

	        this.packageTypesReplacingArchives = ["bower", "npm", "cocoapods", "gitlfs", "opkg", "composer", "pypi", "vagrant"];
	    }

	    _createClass(JFCommonBrowser, {
	        _getContextMenuItems: {

	            /****************************
	             * Context menu items
	             ****************************/

	            value: function _getContextMenuItems(obj, cb) {
	                var _this = this;

	                var actionItems = {};
	                if (obj.data) {
	                    (function () {
	                        var node = obj.data;
	                        node.load().then(function () {
	                            return node.refreshWatchActions();
	                        }).then(function () {
	                            return node.getDownloadPath();
	                        }).then(function () {
	                            if (node.actions) {
	                                node.actions.forEach(function (actionObj) {
	                                    var name = actionObj.name;
	                                    var action = angular.copy(ACTIONS[name]);
	                                    if (!action) {
	                                        console.log("Unrecognized action", name);
	                                        return true;
	                                    }
	                                    action._class = "menu-item-" + action.icon;
	                                    action.icon = "action-icon icon " + action.icon;
	                                    action.label = action.title;

	                                    if (actionObj.name === "Download") {
	                                        action.link = node.actualDownloadPath;
	                                    } else {
	                                        action.action = function () {
	                                            _this.artifactActions.perform(actionObj, obj, true);
	                                        };
	                                    }
	                                    if (actionObj.name === "Distribute" && node.repoType === "distribution") {
	                                        action = angular.copy(ACTIONS.Redistribute);
	                                        ;
	                                    }
	                                    actionItems[name] = action;
	                                });

	                                cb(actionItems);
	                            } else {
	                                cb([]);
	                            }
	                        });
	                    })();
	                } else {
	                    cb([]);
	                }
	            }
	        },
	        jstree: {

	            /****************************
	             * Access methods
	             ****************************/

	            value: function jstree() {
	                return $(this.treeElement).jstree();
	            }
	        },
	        _getSelectedTreeNode: {
	            value: function _getSelectedTreeNode() {
	                var selectedJsNode = this.jstree().get_node(this._getSelectedNode());
	                return selectedJsNode && selectedJsNode.data;
	            }
	        },
	        _getSelectedNode: {
	            value: function _getSelectedNode() {
	                return this.jstree().get_selected()[0];
	            }
	        },
	        _isVisible: {

	            /****************************
	             * access the tree
	             ****************************/

	            value: function _isVisible(jsTreeNode) {
	                // If the node is hidden, the get_node as DOM returns empty result
	                return this.jstree().get_node(jsTreeNode, true).length && $("#" + this._getSafeId(jsTreeNode.id)).css("display") !== "none";
	            }
	        },
	        _isRootRepoVisible: {
	            value: function _isRootRepoVisible(jsTreeNode) {
	                return this.jstree().get_node(this._getRootRepo(jsTreeNode), true).length;
	            }
	        },
	        _getFirstVisibleNode: {
	            value: function _getFirstVisibleNode() {
	                var json = this.jstree().get_json();
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;

	                try {
	                    for (var _iterator = json[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        var node = _step.value;

	                        if (this._isVisible(node)) {
	                            return node;
	                        }
	                    }
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator["return"]) {
	                            _iterator["return"]();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	            }
	        },
	        _getRootRepo: {
	            value: function _getRootRepo(jsTreeNode) {
	                if (!jsTreeNode.parents || jsTreeNode.parents.length === 1) {
	                    return jsTreeNode;
	                }var rootRepoId = jsTreeNode.parents[jsTreeNode.parents.length - 2];
	                return this.jstree().get_node(rootRepoId);
	            }
	        },
	        _unhoverAll: {
	            value: function _unhoverAll() {
	                $("." + JSTREE_ROW_HOVER_CLASS).removeClass(JSTREE_ROW_HOVER_CLASS);
	            }
	        },
	        _hover: {
	            value: function _hover(domElement) {
	                domElement.find(".jstree-anchor").first().addClass(JSTREE_ROW_HOVER_CLASS);
	            }
	        },
	        _focusOnTree: {
	            value: function _focusOnTree(elemToFocus) {
	                if (!elemToFocus) {
	                    var elemToFocus = $(".jstree-hovered").length ? $(".jstree-hovered").closest(".jstree-node").attr("id") : $(".jstree-clicked").closest(".jstree-node").attr("id");
	                }

	                $(".jstree #" + elemToFocus + "_anchor").focus();
	            }
	        },
	        _getSafeId: {
	            value: function _getSafeId(id) {
	                return this._escapeChars(id, ["/", ".", "$", "{", "}", "(", ")", "[", "]"]);
	            }
	        },
	        _escapeChars: {
	            value: function _escapeChars(str, chars) {
	                var newStr = str;
	                chars.forEach(function (char) {
	                    newStr = newStr ? newStr.split(char).join("\\" + char) : newStr;
	                });
	                return newStr;
	            }
	        },
	        _getDomElement: {
	            value: function _getDomElement(node) {
	                return this.jstree().get_node(node, true);
	            }
	        },
	        _scrollIntoView: {
	            value: function _scrollIntoView(domElement) {
	                if (!domElement || !domElement[0]) {
	                    return;
	                } /*
	                          if (domElement[0].scrollIntoViewIfNeeded) {
	                              domElement[0].scrollIntoViewIfNeeded(true);
	                          }
	                          else {
	                  */
	                this._scrollToViewIfNeededReplacement(domElement[0], true);
	                if (domElement[0].scrollIntoViewIfNeeded) {
	                    domElement[0].scrollIntoViewIfNeeded(true);
	                }
	                /*
	                        }
	                */
	            }
	        },
	        _scrollToViewIfNeededReplacement: {
	            value: function _scrollToViewIfNeededReplacement(elem, centerIfNeeded) {
	                var runAgain = arguments[2] === undefined ? true : arguments[2];

	                function withinBounds(value, min, max, extent) {
	                    if (false === centerIfNeeded || max <= value + extent && value <= min + extent) {
	                        return Math.min(max, Math.max(min, value));
	                    } else {
	                        return (min + max) / 2;
	                    }
	                }

	                function makeArea(left, top, width, height) {
	                    return { left: left, top: top, width: width, height: height,
	                        right: left + width, bottom: top + height,
	                        translate: function translate(x, y) {
	                            return makeArea(x + left, y + top, width, height);
	                        },
	                        relativeFromTo: function relativeFromTo(lhs, rhs) {
	                            var newLeft = left,
	                                newTop = top;
	                            lhs = lhs.offsetParent;
	                            rhs = rhs.offsetParent;
	                            if (lhs === rhs) {
	                                return area;
	                            }
	                            for (; lhs; lhs = lhs.offsetParent) {
	                                newLeft += lhs.offsetLeft + lhs.clientLeft;
	                                newTop += lhs.offsetTop + lhs.clientTop;
	                            }
	                            for (; rhs; rhs = rhs.offsetParent) {
	                                newLeft -= rhs.offsetLeft + rhs.clientLeft;
	                                newTop -= rhs.offsetTop + rhs.clientTop;
	                            }
	                            return makeArea(newLeft, newTop, width, height);
	                        }
	                    };
	                }

	                var parent,
	                    area = makeArea(elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight);
	                while ((parent = elem.parentNode) instanceof HTMLElement) {
	                    var clientLeft = parent.offsetLeft + parent.clientLeft;
	                    var clientTop = parent.offsetTop + parent.clientTop;

	                    // Make area relative to parent's client area.
	                    area = area.relativeFromTo(elem, parent).translate(-clientLeft, -clientTop);

	                    parent.scrollLeft = withinBounds(parent.scrollLeft, area.right - parent.clientWidth, area.left, parent.clientWidth);

	                    parent.scrollTop = withinBounds(parent.scrollTop, area.bottom - parent.clientHeight, area.top, parent.clientHeight);

	                    // Determine actual scroll amount by reading back scroll properties.
	                    area = area.translate(clientLeft - parent.scrollLeft, clientTop - parent.scrollTop);
	                    elem = parent;
	                }

	                if (runAgain) this._scrollToViewIfNeededReplacement(elem, centerIfNeeded, false); //hackish fix
	            }
	        },
	        _getScoreObjectFromOrderArray: {
	            value: function _getScoreObjectFromOrderArray(order) {
	                var repoScore = {};
	                var score = 100000;

	                order.forEach(function (repoType) {
	                    repoScore[repoType.toLowerCase()] = score;
	                    if (repoType === "REMOTE") {
	                        repoScore.cached = score;
	                        score = score / 10;
	                    }
	                    score = score / 10;
	                });
	                return repoScore;
	            }
	        },
	        _initJSTreeSorting: {
	            value: function _initJSTreeSorting() {
	                var _this = this;

	                var jstree = undefined;
	                var repoScore = undefined,
	                    repoOrder = undefined;
	                $.jstree.defaults.sort = function (a, b) {
	                    if (!repoOrder) {
	                        repoOrder = _this.ArtifactoryState.getState("repoOrder");
	                        repoScore = _this._getScoreObjectFromOrderArray(repoOrder || ["VIRTUAL", "DISTRIBUTION", "LOCAL", "REMOTE"]);
	                    }

	                    if (!jstree) jstree = _this.jstree();
	                    var aNode = jstree.get_node(a);
	                    var bNode = jstree.get_node(b);

	                    if (!aNode || !bNode) {
	                        jstree = _this.jstree();
	                        aNode = jstree.get_node(a);
	                        bNode = jstree.get_node(b);
	                    }

	                    var aText = aNode.data ? aNode.data.text.toLowerCase() : "*";
	                    var bText = bNode.data ? bNode.data.text.toLowerCase() : "*";

	                    var aType = aNode.data ? aNode.data.type : "*";
	                    var bType = bNode.data ? bNode.data.type : "*";
	                    var aRepoType = aNode.data ? aNode.data.repoType : "*";
	                    var bRepoType = bNode.data ? bNode.data.repoType : "*";

	                    var aScore = 0,
	                        bScore = 0;

	                    if (aNode.data && aNode.data.isTrashcan && aNode.data.isTrashcan() && aNode.text !== "..") return 1;else if (bNode.data && bNode.data.isTrashcan && bNode.data.isTrashcan() && bNode.text !== "..") return -1;else if ((aType === "repository" || aType === "virtualRemoteRepository") && (bType === "repository" || bType === "virtualRemoteRepository")) {
	                        //both repos - top level sort

	                        if (aRepoType === "distribution") aScore += repoScore.distribution;
	                        if (bRepoType === "distribution") bScore += repoScore.distribution;

	                        if (aRepoType === "local") aScore += repoScore.local;
	                        if (bRepoType === "local") bScore += repoScore.local;

	                        if (aRepoType === "cached") aScore += repoScore.cached;
	                        if (bRepoType === "cached") bScore += repoScore.cached;

	                        if (aRepoType === "remote") aScore += repoScore.remote;
	                        if (bRepoType === "remote") bScore += repoScore.remote;

	                        if (aRepoType === "virtual") aScore += repoScore.virtual;
	                        if (bRepoType === "virtual") bScore += repoScore.virtual;

	                        if (aText < bText) aScore++;
	                        if (aText > bText) bScore++;

	                        return aScore < bScore ? 1 : -1;
	                    } else if (aType !== "repository" && aType !== "virtualRemoteRepository" && (bType !== "repository" && bType !== "virtualRemoteRepository")) {
	                        //both files or folders

	                        if (aType === "folder") aScore += 10000;
	                        if (bType === "folder") bScore += 10000;

	                        if (aNode.text === "..") aScore += 100000;
	                        if (bNode.text === "..") aScore += 100000;

	                        var aHasNumVal = !_.isNaN(parseInt(aText));
	                        var bHasNumVal = !_.isNaN(parseInt(bText));

	                        if (aHasNumVal && bHasNumVal) {

	                            var addTo = _this._compareVersions(aText, bText);

	                            if (addTo === "a") aScore += 100;
	                            if (addTo === "b") bScore += 100;
	                        } else {

	                            var aDigitIndex = aText.search(/\d/);
	                            var bDigitIndex = bText.search(/\d/);

	                            if (aDigitIndex === bDigitIndex && aDigitIndex !== -1) {
	                                var aBeforeNum = aText.substr(0, aDigitIndex);
	                                var bBeforeNum = bText.substr(0, bDigitIndex);
	                                if (aBeforeNum === bBeforeNum) {
	                                    var aFromNum = aText.substr(aDigitIndex);
	                                    var bFromNum = bText.substr(bDigitIndex);

	                                    var addTo = _this._compareVersions(aFromNum, bFromNum);

	                                    if (addTo === "a") aScore += 100;
	                                    if (addTo === "b") bScore += 100;
	                                }
	                            }

	                            if (aText < bText) aScore++;
	                            if (aText > bText) bScore++;
	                        }
	                        return aScore < bScore ? 1 : -1;
	                    } else {
	                        if (!aNode.data) return -1; //special node
	                        else if (!bNode.data) return 1; //special node
	                        else if (aType === "repository" || aType === "virtualRemoteRepository") return -1;else if (bType === "repository" || bType === "virtualRemoteRepository") return 1;else return aText > bText ? 1 : -1;
	                    }
	                };
	            }
	        },
	        _compareVersions: {
	            value: function _compareVersions(aText, bText) {
	                var splitters = /\-|\.|_/;
	                var aArr = aText.split(splitters);
	                var bArr = bText.split(splitters);
	                var minLength = Math.min(aArr.length, bArr.length);

	                var addTo = undefined;
	                for (var i = 0; i < minLength; i++) {
	                    var aNum = parseInt(aArr[i]);
	                    var bNum = parseInt(bArr[i]);
	                    var aIsNum = !_.isNaN(aNum);
	                    var bIsNum = !_.isNaN(bNum);
	                    if (aIsNum && bIsNum && aNum < bNum) {
	                        addTo = "a";
	                        break;
	                    } else if (aIsNum && bIsNum && aNum > bNum) {
	                        addTo = "b";
	                        break;
	                    } else if (!aIsNum || !bIsNum) {
	                        if (aArr[i] < bArr[i]) {
	                            addTo = "a";
	                            break;
	                        } else if (aArr[i] > bArr[i]) {
	                            addTo = "b";
	                            break;
	                        }
	                    }
	                }

	                if (!addTo) {
	                    if (aArr.length > bArr.length) addTo = "b";else if (aArr.length < bArr.length) addTo = "a";
	                }

	                return addTo;
	            }
	        },
	        _getFileExtension: {
	            value: function _getFileExtension(path) {
	                return path.indexOf(".") === -1 ? "" : path.split(".").pop();
	            }
	        },
	        _iconsShouldBeReplacedWithRepoPkgTypeIcon: {
	            value: function _iconsShouldBeReplacedWithRepoPkgTypeIcon(nodeType, repoPkgType, fullPath) {
	                var repotype = repoPkgType && repoPkgType.toLocaleLowerCase();

	                return nodeType === "archive" && $.inArray(repotype, this.packageTypesReplacingArchives) !== -1 || repoPkgType === "Gradle" && this._getFileExtension(fullPath) === "gradle";
	            }
	        },
	        _searchCallback: {

	            /************************************************************************************************************************************
	             * New Advanced Quick Find !!
	             ************************************************************************************************************************************/

	            /********************************************
	             * Is the node matching the search criteria
	             ********************************************/

	            value: function _searchCallback(str, jsTreeNode, elem) {

	                if (jsTreeNode.parent === "#" && jsTreeNode.text === ".." && jsTreeNode.type === "go_up") {
	                    return true;
	                }if (!jsTreeNode.data) {
	                    return false;
	                }var treeNode = jsTreeNode.data;

	                // Special filters:
	                var filterRegexp = new RegExp(REGEXP);
	                var matches = filterRegexp.exec(str);
	                if (matches && matches[2].trim()) {
	                    var filterType = matches[1];
	                    var filterText = matches[2];
	                    var rootRepo = this._getRootRepo(jsTreeNode).data;

	                    switch (filterType) {
	                        case "pkg":
	                            return treeNode.isRepo() && treeNode.repoPkgType && treeNode.repoPkgType.toLowerCase().indexOf(filterText.toLowerCase()) != -1 || !treeNode.isRepo() && this.activeFilter && (rootRepo.isRepo() && rootRepo.repoPkgType.toLowerCase().indexOf(filterText.toLowerCase()) != -1) || (treeNode.isTrashcan && treeNode.isTrashcan() || treeNode.isInTrashcan && treeNode.isInTrashcan()) && localStorage.pinnedTrash && this.type === "tree";
	                        case "repo":
	                            return treeNode.isRepo() && treeNode.repoType.toLowerCase().indexOf(filterText.toLowerCase()) != -1 || !treeNode.isRepo() && this.activeFilter && (rootRepo.isRepo() && rootRepo.repoType.toLowerCase().indexOf(filterText.toLowerCase()) != -1) || (treeNode.isTrashcan && treeNode.isTrashcan() || treeNode.isInTrashcan && treeNode.isInTrashcan()) && localStorage.pinnedTrash && this.type === "tree";
	                    }
	                }
	                // Regular text search:
	                else {
	                    if (!this._isVisible(jsTreeNode)) {
	                        return false;
	                    }var matchObj = this.advancedStringMatch.match(this.type === "stash" ? jsTreeNode.text : treeNode.isTrashcan() ? "Trash Can" : treeNode.text, str);
	                    if (elem) {
	                        if (matchObj.matched) $(elem).prop("segments", matchObj.segments);else $(elem).prop("segments", null);
	                    }
	                    return matchObj.matched;
	                }
	            }
	        },
	        _searchTree: {

	            /****************************
	             * Searching the tree
	             ****************************/

	            value: function _searchTree(text) {
	                var gotoFirst = arguments[1] === undefined ? true : arguments[1];
	                var showSpinner = arguments[2] === undefined ? true : arguments[2];

	                this.searchText = text || "";
	                var showOnlyMatches = text ? text.match(new RegExp(REGEXP)) || false : false;
	                this._jsQuickFind(this.searchText, showOnlyMatches, gotoFirst, showSpinner);
	            }
	        },
	        _cancelRunningSearch: {
	            value: function _cancelRunningSearch() {
	                if (this.searchTimeoutPromise) {
	                    this.$timeout.cancel(this.searchTimeoutPromise);
	                    this.searchTimeoutPromise = null;
	                    this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_RUNNING, false);
	                    //            console.log('Quick Find Ended.')
	                }
	            }
	        },
	        _jsQuickFind: {
	            value: function _jsQuickFind(searchText, showOnlyMatches) {
	                var _this = this;

	                var gotoFirst = arguments[2] === undefined ? true : arguments[2];
	                var showSpinner = arguments[3] === undefined ? true : arguments[3];

	                this._cancelRunningSearch();
	                if (!searchText || this._isInActiveFilterMode() === "empty") {
	                    this._clear_search();
	                    return;
	                }
	                var res = [];
	                var nodes = [];
	                var nodesParents = [];
	                var nomatches = [];
	                var nomatchesParents = [];
	                var all = $(".jstree-anchor");

	                var i = 0;
	                var doIteration = function () {
	                    //            console.log('Quick Find Running...')
	                    var startI = i;
	                    while (i < startI + 500 && i < all.length) {
	                        var e = $(all[i]);
	                        if (searchText && e.text()) {
	                            var id = e.prop("id");
	                            id = id.substr(0, id.length - "_anchor".length);
	                            var treeNode = _this.jstree().get_node(id);
	                            if (_this._searchCallback(searchText, treeNode, e[0])) {
	                                var goneToFirst = false;
	                                if (gotoFirst && !nodes.length) {
	                                    //goto first result
	                                    goneToFirst = true;
	                                    _this.searchResults = [id];
	                                    _this._initCurrentSearchResult([e[0]]);
	                                    _this._gotoCurrentSearchResult();
	                                }
	                                res.push(id);
	                                nodes.push(e[0]);
	                                nodesParents.push(e[0].parentElement);

	                                if ((goneToFirst || _this._isScrolledIntoView(e[0], 0)) && !showOnlyMatches) {
	                                    e.addClass("jstree-search");
	                                    var jqe = $(e[0]);
	                                    jqe.unhighlight();
	                                    var segs = jqe.prop("segments");
	                                    if (segs) _this.advancedStringMatch.highlight(jqe, segs);
	                                } else if (showOnlyMatches) {}
	                            } else {
	                                nomatches.push(e[0]);
	                                nomatchesParents.push(e[0].parentElement);
	                                if (_this._isScrolledIntoView(e[0], 0) && !showOnlyMatches) {
	                                    e.removeClass("jstree-search");
	                                    $(e[0]).unhighlight();
	                                } else if (showOnlyMatches) {}
	                            }
	                        } else {
	                            nomatches.push(e[0]);
	                            nomatchesParents.push(e[0].parentElement);
	                            if (_this._isScrolledIntoView(e[0], 0) && !showOnlyMatches) {
	                                e.removeClass("jstree-search");
	                                $(e[0]).unhighlight();
	                            } else if (showOnlyMatches) {}
	                        }
	                        i++;
	                        _this.searchResults = res;
	                        _this.searchNodes = nodes;
	                        _this.searchParentNodes = nodes;
	                        _this.nomatchNodes = nomatches;
	                        _this.nomatchParentNodes = nomatchesParents;
	                    }
	                };

	                var timeOutFunc = function () {
	                    if (i < all.length) {
	                        if (showSpinner && i === 0 && all.length > 250) _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_RUNNING, true);
	                        doIteration();
	                        _this.searchTimeoutPromise = _this.$timeout(function () {
	                            return timeOutFunc();
	                        });
	                    } else {
	                        // finish

	                        _this.searchTimeoutPromise = null;
	                        if (showOnlyMatches && res.length) {
	                            $(".hidden:has(\".jstree-anchor\")").removeClass("hidden");
	                            $(_this.searchParentNodes).removeClass("hidden");
	                            $(_this.nomatchParentNodes).addClass("hidden");
	                        } else {
	                            $(".hidden:has(\".jstree-anchor\")").removeClass("hidden");
	                        }

	                        _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_RUNNING, false);
	                        //                console.log('Quick Find Ended.')
	                    }
	                };
	                // console.log('Starting Quick Find...')
	                this.searchTimeoutPromise = this.$timeout(function () {
	                    return timeOutFunc();
	                });
	            }
	        },
	        _onScroll: {
	            value: function _onScroll() {
	                if (!this.searchNodes || this._isInActiveFilterMode()) {
	                    return;
	                }for (var i = 0; i < this.searchNodes.length; i++) {
	                    if (this._isScrolledIntoView(this.searchNodes[i], 0)) {
	                        var jqe = $(this.searchNodes[i]);
	                        jqe.addClass("jstree-search");
	                        jqe.unhighlight();
	                        var segs = jqe.prop("segments");
	                        if (segs) this.advancedStringMatch.highlight(jqe, segs);
	                    }
	                }
	                for (var i = 0; i < this.nomatchNodes.length; i++) {
	                    if (this._isScrolledIntoView(this.nomatchNodes[i], 0)) {
	                        var jqe = $(this.nomatchNodes[i]);
	                        jqe.removeClass("jstree-search");
	                        jqe.unhighlight();
	                    }
	                }
	            }
	        },
	        _isScrolledIntoView: {
	            value: function _isScrolledIntoView(el) {
	                var marginSize = arguments[1] === undefined ? 0 : arguments[1];

	                var elemTop = el.getBoundingClientRect().top;
	                var elemBottom = el.getBoundingClientRect().bottom;

	                var isVisible = elemTop >= -marginSize && elemBottom <= window.innerHeight + marginSize;
	                return isVisible;
	            }
	        },
	        _initCurrentSearchResult: {
	            value: function _initCurrentSearchResult(nodes) {
	                var _this = this;

	                if (!this.currentResult || !_.include(this.searchResults, this.currentResult)) {
	                    (function () {
	                        // there is no previous result, or previous result is not included in the search results
	                        // select first result that's below the node we started the search from
	                        var startFromDom = _this.jstree().get_node(_this._getSelectedNode(), /* as_dom = */true)[0];
	                        var firstNodeBelow = _.find(nodes, function (node) {
	                            if (!startFromDom) return true;
	                            return node.offsetTop > startFromDom.offsetTop;
	                        });
	                        // if found - select as first result, if not - select first search result
	                        _this.currentResult = firstNodeBelow ? firstNodeBelow.id.substr(0, firstNodeBelow.id.length - "_anchor".length) : _this.searchResults[0];
	                    })();
	                }
	            }
	        },
	        _isInActiveFilterMode: {
	            value: function _isInActiveFilterMode() {
	                var _this = this;

	                var checkIfMatchesFound = arguments[0] === undefined ? false : arguments[0];

	                if (this.searchText.match(new RegExp(REGEXP))) {
	                    var justSearchTerm = this.searchText.substr(this.searchText.indexOf(":") + 1).trim();
	                    if (justSearchTerm) {
	                        if (checkIfMatchesFound) {
	                            var json = this.jstree().get_json();
	                            var matchesFound = false;
	                            var _iteratorNormalCompletion = true;
	                            var _didIteratorError = false;
	                            var _iteratorError = undefined;

	                            try {
	                                for (var _iterator = json[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                    var _ret = (function () {
	                                        var node = _step.value;

	                                        node.data.isRepo = function () {
	                                            return node.data.type === "repository" || node.data.type === "virtualRemoteRepository" || node.data.type === "localRepository" || node.data.type === "remoteRepository" || node.data.type === "cachedRepository" || node.data.type === "virtualRepository";
	                                        };
	                                        if (_this._searchCallback(_this.searchText, node)) {
	                                            matchesFound = true;
	                                            return "break";
	                                        }
	                                    })();

	                                    if (_ret === "break") break;
	                                }
	                            } catch (err) {
	                                _didIteratorError = true;
	                                _iteratorError = err;
	                            } finally {
	                                try {
	                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
	                                        _iterator["return"]();
	                                    }
	                                } finally {
	                                    if (_didIteratorError) {
	                                        throw _iteratorError;
	                                    }
	                                }
	                            }

	                            return matchesFound ? true : "no results";
	                        } else {
	                            return true;
	                        }
	                    } else {
	                        return "empty";
	                    }
	                } else {
	                    return false;
	                }
	            }
	        },
	        _searchTreeKeyDown: {
	            value: function _searchTreeKeyDown(key) {
	                var _this = this;

	                var jstree = this.jstree();
	                if (key == KEYS.DOWN_ARROW) {
	                    this._selectNextSearchResult();
	                } else if (key == KEYS.UP_ARROW) {
	                    this._selectPreviousSearchResult();
	                } else if (key == KEYS.ENTER) {
	                    //manually set the model to the input element's value (because the model is debounced...)
	                    this.searchText = $(".jf-tree-search").val();

	                    var isInActiveFilterMode = this._isInActiveFilterMode(true);

	                    if (isInActiveFilterMode === true) {
	                        this.activeFilter = true;
	                        if (this.browserController) {
	                            this.browserController.activeFilter = true;
	                            this.browserController.searchText = this.searchText + "*";
	                        }
	                        this._searchTree(this.searchText);
	                        this._focusOnTree();
	                        if (!this._isVisible(jstree.get_node(this._getSelectedNode()))) {
	                            jstree.select_node(this._getFirstVisibleNode());
	                        }
	                    } else if (isInActiveFilterMode === "no results") {
	                        if (this.artifactoryNotifications) this.artifactoryNotifications.create({ warn: "No repositories matches the filtered " + (this.searchText.startsWith("pkg:") ? "package" : "repository") + " type" });
	                    } else {
	                        this.activeFilter = false;
	                        if (this.browserController) this.browserController.activeFilter = false;
	                        this._selectCurrentSearchResult();
	                        jstree.open_node(this.currentResult);
	                        this._clear_search();
	                        this._focusOnTree();
	                        this.currentResult = null;
	                    }
	                } else if (key == KEYS.ESC) {
	                    this.activeFilter = false;
	                    if (this.browserController) this.browserController.activeFilter = false;
	                    this._clear_search();
	                    this._focusOnTree();
	                    this.currentResult = null;
	                } else {
	                    this.$timeout(function () {
	                        _this.searchText = $(".jf-tree-search").val();
	                        if (_this.searchText === "") {
	                            $(_this.treeElement).unhighlight();
	                        }
	                    });
	                }
	            }
	        },
	        _clear_search: {
	            value: function _clear_search() {
	                this._cancelRunningSearch();
	                this.activeFilter = false;
	                if (this.browserController) this.browserController.activeFilter = false;
	                this._unhoverAll();
	                this.jstree().clear_search();
	                $(".hidden:has(\".jstree-anchor\")").removeClass("hidden");
	                $(".jstree-anchor.jstree-search").removeClass("jstree-search");
	                $(this.treeElement).unhighlight();
	                this.searchNodes = null;
	                this.searchParentNodes = null;
	                this.nomatchNodes = null;
	                this.nomatchParentNodes = null;
	                this.searchText = "";
	            }
	        },
	        _selectNextSearchResult: {
	            value: function _selectNextSearchResult() {
	                var index = this.searchResults.indexOf(this.currentResult);
	                index++;
	                if (index > this.searchResults.length - 1) {
	                    index = 0;
	                }
	                this.currentResult = this.searchResults[index];
	                this._gotoCurrentSearchResult();
	            }
	        },
	        _selectPreviousSearchResult: {
	            value: function _selectPreviousSearchResult() {
	                var index = this.searchResults.indexOf(this.currentResult);
	                index--;
	                if (index < 0) {
	                    index = this.searchResults.length - 1;
	                }
	                this.currentResult = this.searchResults[index];
	                this._gotoCurrentSearchResult();
	            }
	        },
	        _gotoCurrentSearchResult: {
	            value: function _gotoCurrentSearchResult() {
	                this._unhoverAll();
	                if (this.currentResult) {
	                    var domElement = this._getDomElement(this.currentResult);
	                    this._hover(domElement);
	                    this._scrollIntoView(domElement);
	                }
	            }
	        },
	        _selectCurrentSearchResult: {
	            value: function _selectCurrentSearchResult() {
	                if (this.currentResult) {
	                    this.jstree().deselect_all();
	                    this.jstree().select_node(this.currentResult);
	                }
	            }
	        }
	    });

	    return JFCommonBrowser;
	})();

	module.exports = JFCommonBrowser;

	//                            e.addClass('jstree-search');

	//                            e.removeClass('jstree-search');

	//                        e.removeClass('jstree-search');

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	/**
	 * wrapper around the jstree jquery component
	 * @url http://www.jstree.com/
	 *
	 * @returns {{restrict: string, controller, controllerAs: string, bindToController: boolean}}
	 */
	exports.jfStashBrowser = jfStashBrowser;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TreeConfig = _interopRequire(__webpack_require__(284));

	var JFCommonBrowser = _interopRequire(__webpack_require__(282));

	function jfStashBrowser() {
	    return {
	        scope: {
	            startCompact: "="
	        },
	        restrict: "E",
	        controller: JFStashBrowserController,
	        controllerAs: "jfStashBrowser",
	        templateUrl: "states/artifacts/jf_stash_browser/jf_stash_browser.html",
	        bindToController: true,
	        link: function link($scope) {
	            $scope.jfStashBrowser.initJSTree();
	        }
	    };
	}

	var JFStashBrowserController = (function (_JFCommonBrowser) {
	    function JFStashBrowserController($timeout, $injector, JFrogEventBus, $element, $scope, $state, $stateParams, $location, $q, ArtifactoryState, ArtifactActions, StashResultsDao, User, AdvancedStringMatch, JFrogUIUtils) {
	        _classCallCheck(this, JFStashBrowserController);

	        _get(Object.getPrototypeOf(JFStashBrowserController.prototype), "constructor", this).call(this, ArtifactActions, AdvancedStringMatch, ArtifactoryState);

	        this.rootID = "____root_node____";

	        this.type = "stash";
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$location = $location;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$q = $q;
	        this.user = User;
	        this.TreeNode = $injector.get("TreeNode");
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.stashResultsDao = StashResultsDao;

	        this.whenTreeDataLoaded = $q.when([]);

	        this.$element = $element;

	        this.compactMode = this.startCompact || false;

	        this.filteredActions = ["Copy", "Move", "Watch", "Unwatch", "UploadToBintray", "Distribute", "Refresh", "DeleteVersions", "DownloadFolder", "Zap", "ZapCaches", "IgnoreAlert", "UnignoreAlert"];

	        this.discardedCount = 0;
	    }

	    _inherits(JFStashBrowserController, _JFCommonBrowser);

	    _createClass(JFStashBrowserController, {
	        initJSTree: {

	            /****************************
	             * Init code
	             ****************************/

	            // This is called from link function

	            value: function initJSTree() {
	                var _this = this;

	                this.whenTreeDataLoaded.then(function () {
	                    _this.treeElement = $(_this.$element).find("#tree-element");
	                    _this._registerEvents();
	                    _this._buildStashedTree();
	                });
	            }
	        },
	        _onReady: {
	            value: function _onReady() {
	                var _this = this;

	                var currentPath = this.$stateParams.artifact ? this.$stateParams.artifact.substring(this.$stateParams.artifact.indexOf("/") + 1).split(" ").join("") : null;

	                if (currentPath) {
	                    this.$timeout(function () {
	                        _this.jstree().deselect_all();
	                        _this.jstree().select_node(currentPath);
	                        _this.jstree().open_node(currentPath);

	                        var domElement = _this._getDomElement(currentPath);
	                        _this._scrollIntoView(domElement);
	                        _this._focusOnTree();
	                    });
	                } else {
	                    //            this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_SELECT,this._getSelectedTreeNode());
	                    this.jstree().select_node(this.rootID);
	                    this.jstree().open_node(this.rootID);
	                }
	            }
	        },
	        _registerEvents: {

	            /****************************
	             * Event registration
	             ****************************/

	            value: function _registerEvents() {
	                var _this = this;

	                // Must destroy jstree on scope destroy to prevent memory leak:
	                this.$scope.$on("$destroy", function () {
	                    if (_this.jstree()) {
	                        _this.jstree().destroy();
	                    }
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CHANGE, function (text) {
	                    return _this._searchTree(text);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CANCEL, function (text) {
	                    return _this._clear_search();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_KEYDOWN, function (key) {
	                    return _this._searchTreeKeyDown(key);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE, function (node) {
	                    node.alreadyDeleted = true;
	                    _this.artifactActions.perform({ name: "DiscardFromStash" }, node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_MOVE_STASH, function (options) {
	                    _this.exitStashState(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_COPY_STASH, function (options) {
	                    _this.exitStashState(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DISCARD_STASH, function () {
	                    _this._buildStashedTree();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DISCARD_FROM_STASH, function (node) {
	                    _this._discardFromStash(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_REFRESH_STASH, function () {
	                    _this._buildStashedTree();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_EXIT_STASH, function (node) {
	                    if (node) _this.jstree().select_node(node.id);
	                    _this.$timeout(function () {
	                        return _this.exitStashState();
	                    });
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_NODE_OPEN, function (path) {
	                    _this._openTreeNode(path);
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COMPACT, function (compact) {
	                    return _this._toggleCompactFolders(compact);
	                });

	                // URL changed (like back button / forward button / someone input a URL)
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TABS_URL_CHANGED, function (stateParams) {

	                    if (stateParams.browser !== "stash" || !_this.jstree()) return;

	                    var path = undefined;
	                    path = stateParams.artifact ? stateParams.artifact.substring(stateParams.artifact.indexOf("/") + 1) : _this.rootID;

	                    var selectedNode = _this._getSelectedTreeNode();
	                    if (selectedNode && selectedNode.fullpath === stateParams.artifact) return;

	                    _this.jstree().deselect_all();
	                    _this.jstree().select_node(path);
	                    var domElement = _this._getDomElement(path);
	                    _this._scrollIntoView(domElement);
	                    _this._focusOnTree();
	                });
	            }
	        },
	        _registerTreeEvents: {

	            /**
	             * register a listener on the tree and delegate to
	             * relevant methods
	             *
	             * @param element
	             * @private
	             */

	            value: function _registerTreeEvents() {
	                var _this = this;

	                //        $(this.treeElement).on("search.jstree", (e, data) => this._onSearch(e, data));
	                $(this.treeElement).on("mousedown", function (e) {
	                    return e.preventDefault();
	                });
	                $(this.treeElement).on("ready.jstree", function (e) {
	                    return _this._onReady(e);
	                });
	                $(this.treeElement).on("select_node.jstree", function (e, args) {
	                    if (_this.$stateParams.tab === "StashInfo" && args.node.id !== _this.rootID) {
	                        _this.$stateParams.tab = "General";
	                    }
	                    _this._loadNode(args.node);
	                });
	                $(this.treeElement).on("activate_node.jstree", function (e, args) {
	                    _this.jstree().open_node(args.node);
	                });

	                $("#tree-element").on("keydown", function (e) {
	                    if (e.keyCode === 37 && e.ctrlKey) {
	                        (function () {
	                            //CTRL + LEFT ARROW --> Collapse All !
	                            var node = _this.jstree().get_selected(true)[0];

	                            var parentRepoNode = _this.jstree().get_node(node.parent);
	                            if (parentRepoNode.id === _this.rootID) parentRepoNode = node;else {
	                                while (parentRepoNode.parent !== _this.rootID) {
	                                    parentRepoNode = _this.jstree().get_node(parentRepoNode.parent);
	                                }
	                            }

	                            $("#tree-element").jstree("close_all");
	                            _this.jstree().select_node(parentRepoNode);
	                            _this.$timeout(function () {
	                                _this.jstree().close_node(parentRepoNode);
	                            });
	                        })();
	                    }
	                });

	                $(this.treeElement).scroll(function () {
	                    return _this._onScroll();
	                });
	            }
	        },
	        _loadNode: {
	            value: function _loadNode(item) {
	                var _this = this;

	                if (item.data.load) item.data.load().then(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, item);
	                });
	            }
	        },
	        _toggleCompactFolders: {

	            /****************************
	             * Compact folders
	             ****************************/

	            value: function _toggleCompactFolders(compact) {
	                this.compactMode = compact;
	                this._buildStashedTree();
	            }
	        },
	        _buildStashedTree: {
	            value: function _buildStashedTree() {
	                var _this = this;

	                //TODO: stashResultsDao should also return data of archive for each resource and repoPkgType
	                // and then the use of this. _iconsShouldBeRplacedWithRepoPkgType() could be made
	                this.stashResultsDao.get({ name: "stash" }).$promise.then(function (data) {
	                    TreeConfig.core.data = _this._transformStashDataToTree(data);
	                    TreeConfig.contextmenu.items = _this._getContextMenuItems.bind(_this);
	                    if (_this.built) _this.jstree().destroy();
	                    TreeConfig.search.search_callback = _this._searchCallback.bind(_this);
	                    $(_this.treeElement).jstree(TreeConfig);
	                    _this.built = true;
	                    if (_this.compactMode) {
	                        _this._compactTree();
	                    }
	                    _this._registerTreeEvents();
	                });
	            }
	        },
	        _createRootNode: {
	            value: function _createRootNode(stashData) {
	                var _this = this;

	                var THIS = this;
	                var node = undefined;
	                node = {
	                    id: this.rootID,
	                    parent: "#",
	                    text: "Stashed Search Results",
	                    type: "stash",
	                    data: {
	                        text: "Stashed Search Results",
	                        iconType: "stash",
	                        load: function load() {

	                            THIS.$stateParams.artifact = "";
	                            THIS.$stateParams.tab = "StashInfo";

	                            this.tabs = [{ name: "StashInfo" }];
	                            this.actions = stashData.length ? [{ title: "Copy Stash to Repository", name: "CopyStash", icon: "icon-copy" }, { title: "Move Stash to Repository", name: "MoveStash", icon: "icon-move" }, { title: "Discard Search Results", name: "DiscardStash", icon: "icon-delete-content" }] : [];
	                            if (!THIS.user.currentUser.getCanDeploy()) {
	                                this.actions.shift();
	                                this.actions.shift();
	                            }
	                            this.info = {
	                                artifactCount: stashData.length - THIS.discardedCount
	                            };
	                            return THIS.$q.when(this);
	                        },
	                        getDownloadPath: function () {
	                            return _this.$q.when(_this);
	                        },
	                        refreshWatchActions: function () {
	                            return _this.$q.when(_this);
	                        },
	                        isRepo: function () {
	                            return false;
	                        }
	                    }

	                };
	                return node;
	            }
	        },
	        _transformStashDataToTree: {
	            value: function _transformStashDataToTree(stashData) {
	                var _this = this;

	                var treeData = [];

	                var pushToTree = function (treeItemData) {
	                    if (!_.findWhere(treeData, { id: treeItemData.id })) {
	                        treeData.push(treeItemData);
	                    }
	                };

	                pushToTree(this._createRootNode(stashData));

	                stashData.forEach(function (result, index) {
	                    result.path = result.relativePath;
	                    result.text = result.name;
	                    result.type = "file";

	                    var dirArray = result.relativePath.split("/");
	                    dirArray.pop();

	                    var resultNode = {
	                        id: result.relativePath.split(" ").join(""),
	                        text: _this.JFrogUIUtils.getSafeHtml(result.name),
	                        parent: dirArray.join("/").split(" ").join("") || _this.rootID,
	                        type: result.mimeType,
	                        data: _this._filterActions(new _this.TreeNode(result))
	                    };

	                    // replace the node icon type to the package type if necessary
	                    var type = typeof result.fileType != "undefined" ? result.fileType : result.type;
	                    if (_this._iconsShouldBeReplacedWithRepoPkgTypeIcon(type, result.repoPkgType, result.fullpath)) {
	                        resultNode.type = resultNode.data.iconType = result.repoPkgType.toLocaleLowerCase();
	                    }

	                    pushToTree(resultNode);

	                    for (var i = dirArray.length - 1; i >= 0; i--) {
	                        var up = _.clone(dirArray);
	                        up.pop();

	                        var folderNode = {
	                            id: dirArray.join("/").split(" ").join(""),
	                            text: dirArray[i],
	                            parent: up.join("/").split(" ").join("") || _this.rootID,
	                            type: "folder",
	                            data: _this._filterActions(new _this.TreeNode({
	                                repoKey: result.repoKey,
	                                path: dirArray.join("/"),
	                                text: dirArray[i],
	                                type: "folder"
	                            }))
	                        };

	                        pushToTree(folderNode);
	                        dirArray.pop();
	                    }
	                });

	                return treeData;
	            }
	        },
	        _compactTree: {
	            value: function _compactTree() {
	                var _this = this;

	                var recursiveCompact = undefined;
	                recursiveCompact = function (node) {
	                    if (node.type !== "folder") {
	                        node.data = _this.jstree().get_node(node.id).data;
	                        return;
	                    }

	                    if (node.children.length === 1 && node.children[0].type === "folder") {
	                        node.text += "/" + node.children[0].text;

	                        if (_this.$stateParams.artifact === node.data.repoKey + "/" + node.data.path) {
	                            _this.$stateParams.artifact = _this.jstree().get_node(node.children[0].id).data.repoKey + "/" + _this.jstree().get_node(node.children[0].id).data.path;
	                        }

	                        node.data = _this.jstree().get_node(node.children[0].id).data;
	                        node.id = node.children[0].id;
	                        node.children = node.children[0].children;
	                        recursiveCompact(node);
	                    } else if (node.children.length > 0) {
	                        node.data = _this.jstree().get_node(node.children[0].id).data;
	                        node.children.forEach(function (child) {
	                            child.data = _this.jstree().get_node(child.id).data;
	                            recursiveCompact(child);
	                        });
	                    }
	                };

	                var json = this.jstree().get_json();
	                json[0].children.forEach(function (node) {
	                    return recursiveCompact(node);
	                });

	                TreeConfig.core.data = json;
	                if (this.built) this.jstree().destroy();
	                $(this.treeElement).jstree(TreeConfig);
	            }
	        },
	        _filterActions: {
	            value: function _filterActions(treeNode) {
	                var _this = this;

	                var origLoad = treeNode.load.bind(treeNode);
	                treeNode.load = function () {
	                    return origLoad().then(function () {

	                        treeNode.actions = _.filter(treeNode.actions, function (action) {
	                            return _this.filteredActions.indexOf(action.name) === -1;
	                        });

	                        var deleteAction = _.findWhere(treeNode.actions, { name: "Delete" });
	                        if (deleteAction) treeNode.actions.splice(treeNode.actions.indexOf(deleteAction), 1);

	                        if (!_.findWhere(treeNode.actions, { name: "ShowInTree" })) {
	                            treeNode.actions.push({
	                                title: "Show In Tree",
	                                name: "ShowInTree",
	                                icon: "icon-show-in-tree"
	                            });
	                        }

	                        if (!_.findWhere(treeNode.actions, { name: "DiscardFromStash" })) {
	                            treeNode.actions.push({
	                                title: "Discard from Stash",
	                                name: "DiscardFromStash",
	                                icon: "icon-delete-content"
	                            });
	                        }

	                        if (deleteAction) treeNode.actions.push(deleteAction);
	                    });
	                };

	                return treeNode;
	            }
	        },
	        _discardFromStash: {
	            value: function _discardFromStash(node) {
	                var jstree = this.jstree();

	                var deletePoint = node;
	                var parent = jstree.get_node(node.parent);
	                while (parent.children.length === 1 && parent.id !== this.rootID) {
	                    deletePoint = parent;
	                    parent = jstree.get_node(parent.parent);
	                }

	                jstree.select_node(parent.id);
	                jstree.delete_node([deletePoint.id]);

	                this.discardedCount++;
	            }
	        },
	        exitStashState: {
	            value: function exitStashState(options) {
	                var _this = this;

	                var artifact = options && options.target ? options.target.targetRepoKey || "/" : this.$stateParams.artifact || "";
	                this.$state.go("artifacts.browsers.path", { tab: "General", artifact: artifact, browser: "tree" });
	                this.$timeout(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_REFRESH);
	                    if (options) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.ACTION_COPY, { node: options.node, target: options.target });
	                    }
	                });
	            }
	        }
	    });

	    return JFStashBrowserController;
	})(JFCommonBrowser);

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var TreeConfig = _interopRequire(__webpack_require__(281));

	var conf = _.cloneDeep(TreeConfig);
	_.extend(conf.core, { check_callback: true });
	module.exports = conf;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfSimpleBrowser = jfSimpleBrowser;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TreeConfig = _interopRequire(__webpack_require__(286));

	var JFCommonBrowser = _interopRequire(__webpack_require__(282));

	var JfSimpleBrowserController = (function (_JFCommonBrowser) {
	    function JfSimpleBrowserController($element, $stateParams, $scope, $timeout, $q, TreeBrowserDao, JFrogEventBus, NativeBrowser, ArtifactoryState, ArtifactActions, AdvancedStringMatch, JFrogUIUtils) {
	        _classCallCheck(this, JfSimpleBrowserController);

	        _get(Object.getPrototypeOf(JfSimpleBrowserController.prototype), "constructor", this).call(this, ArtifactActions, AdvancedStringMatch, ArtifactoryState);
	        this.$stateParams = $stateParams;
	        this.JFrogEventBus = JFrogEventBus;
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$element = $element;
	        this.$q = $q;
	        this.currentNode = {};
	        this.treeBrowserDao = TreeBrowserDao;
	        this.nativeBrowser = NativeBrowser;
	        this.artifactoryState = ArtifactoryState;
	        this.treeElement = $(this.$element).find("#tree-element");
	        this._registerEvents();

	        var doRefresh = this.artifactoryState.getState("refreshTreeNextTime");
	        if (doRefresh) {
	            this.treeBrowserDao.invalidateRoots();
	            this.artifactoryState.setState("refreshTreeNextTime", false);
	        }
	    }

	    _inherits(JfSimpleBrowserController, _JFCommonBrowser);

	    _createClass(JfSimpleBrowserController, {
	        initJSTree: {

	            // This is called from link function

	            value: function initJSTree() {
	                if (_.isEmpty(this.$stateParams.artifact)) {
	                    // load empty parent (roots)
	                    this._loadNodeIntoView();
	                } else {
	                    // load artifact by path
	                    this._loadNodeByPath(this.$stateParams.artifact);
	                }
	            }
	        },
	        _loadNodeByPath: {

	            // Preload data for the selected artifact and load it into view

	            value: function _loadNodeByPath(path) {
	                var _this = this;

	                if (path) {
	                    this.treeBrowserDao.findNodeByFullPath(path, /* includeArchives = */false).then(function (node) {
	                        return _this._loadNodeIntoView(node);
	                    });
	                } else {
	                    this._loadNodeIntoView();
	                }
	            }
	        },
	        _loadNodeIntoView: {

	            /***************************************************
	             * Load the node's data and children (if applicable)
	             ***************************************************/

	            value: function _loadNodeIntoView(node) {
	                var _this = this;

	                if (node) {
	                    this.selectedNode = node;
	                }
	                var promise = undefined;
	                // Not drilling down to repo if didn't click on it
	                if (node && (node.parent || this.artifactoryState.getState("tree_touched"))) {
	                    if (!node.isFolder() && !node.isRepo()) // Not drilling down to files / archives
	                        {
	                            this.currentParentNode = node.parent;
	                        } else {
	                        this.currentParentNode = node;
	                    }
	                    promise = this._loadParentIntoView(this.currentParentNode);
	                } else {
	                    this.currentParentNode = null;
	                    promise = this._loadRootsIntoView();
	                }
	                promise.then(function () {
	                    return _this._dispatchEvent();
	                });
	            }
	        },
	        _loadParentIntoView: {
	            value: function _loadParentIntoView(node) {
	                var _this = this;

	                // (Adam) Don't use ng-class, it causes major performance issue on large data sets
	                return this._loadChildren(node.getChildren()).then(function () {
	                    _this.treeElement.addClass("has-parent");
	                });
	            }
	        },
	        _loadRootsIntoView: {
	            value: function _loadRootsIntoView() {
	                var _this = this;

	                if (this.artifactoryState.getState("refreshTreeWhenBackToRoot")) {
	                    this.artifactoryState.setState("refreshTreeWhenBackToRoot", false);
	                    this._refreshTree();
	                }
	                // (Adam) Don't use ng-class, it causes major performance issue on large data sets
	                return this._loadChildren(this.treeBrowserDao.getRoots()).then(function () {
	                    _this.treeElement.removeClass("has-parent");
	                });
	            }
	        },
	        _loadChildren: {
	            value: function _loadChildren(promise) {
	                var _this = this;

	                return promise.then(function (children) {
	                    // select first child if none selected
	                    _this.selectedNode = _this.selectedNode || children[0];
	                    children = _this._transformData(children || []);
	                    if (_this.currentParentNode) {
	                        // Create a tree with parent and children
	                        var goUp = {
	                            type: "go_up",
	                            data: _this.currentParentNode.parent,
	                            text: ".."
	                        };
	                        var parentTreeNode = _this._transformNode(_this.currentParentNode);
	                        parentTreeNode.children = children;
	                        parentTreeNode.state.opened = true;

	                        _this._buildTree([goUp, parentTreeNode]);
	                    } else {
	                        // Create a tree with only children
	                        _this._buildTree(children);
	                    }
	                });
	            }
	        },
	        _transformData: {
	            value: function _transformData(data) {
	                var _this = this;

	                return data.map(function (node) {
	                    return _this._transformNode(node);
	                });
	            }
	        },
	        _transformNode: {
	            value: function _transformNode(node) {
	                var nodeText = undefined;
	                if (node.isTrashcan()) {
	                    nodeText = "<span class=\"no-simple-browsing trashcan-node\">Trash Can</span>";
	                } else {
	                    nodeText = "<span class=\"no-simple-browsing\">" + this.JFrogUIUtils.getSafeHtml(node.text) + "</span>";
	                }

	                var modifiedNode = {
	                    text: nodeText,
	                    data: node,
	                    type: node.iconType,
	                    children: node.hasChild && (node.isFolder() || node.isRepo()),
	                    li_attr: node.isTrashcan() || node.isInTrashcan() && node == this.selectedNode ? { "class": "-the-trashcan" } : {},
	                    state: {
	                        selected: this.selectedNode === node
	                    }
	                };

	                var type = typeof node.fileType != "undefined" ? node.fileType : node.type;
	                // replace the node icon type to the package type if necessary
	                if (this._iconsShouldBeReplacedWithRepoPkgTypeIcon(type, node.repoPkgType, node.fullpath)) {
	                    modifiedNode.type = node.iconType = node.repoPkgType.toLocaleLowerCase();
	                }

	                return modifiedNode;
	            }
	        },
	        _toggleCompactFolders: {
	            value: function _toggleCompactFolders() {
	                this.treeBrowserDao.invalidateRoots();
	                this.initJSTree();
	            }
	        },
	        _openNode: {
	            value: function _openNode(treeNode, loadNodeToViewAllowed) {
	                this.artifactoryState.setState("tree_touched", true);

	                if (loadNodeToViewAllowed) {
	                    this._loadNodeIntoView(treeNode);
	                } else {
	                    // just select (no need to refresh current tree)
	                    this.selectedNode = treeNode;
	                    this._dispatchEvent();
	                }
	            }
	        },
	        _registerTreeEvents: {
	            value: function _registerTreeEvents() {
	                var _this = this;

	                // $(this.treeElement).on("search.jstree", (e, data) => this._onSearch(e, data));

	                $(this.treeElement).on("mousedown", function (e) {
	                    return e.preventDefault();
	                });

	                $(this.treeElement).on("ready.jstree", function (e) {
	                    return _this._onReady(e);
	                });

	                $(this.treeElement).on("close_node.jstree", function (e, args) {
	                    _this.jstree().open_node(args.node);
	                });

	                // Selecting a node (by clicking its name)
	                $(this.treeElement).on("select_node.jstree", function (e, args) {
	                    var treeNode = args.node.data;
	                    var loadNodeToViewAllowed = !treeNode || _this.currentParentNode && _this.currentParentNode.parent === treeNode;

	                    _this._openNode(treeNode, loadNodeToViewAllowed);
	                });

	                // Click on the left triangle l>
	                $(this.treeElement).on("load_node.jstree", function (e, args) {
	                    var treeNode = args.node.data;
	                    var loadNodeToViewAllowed = treeNode !== _this.currentParentNode && (!treeNode || // Going up to roots
	                    treeNode.isFolder() || treeNode.isRepo()); // drilling down to folder or repo

	                    _this._openNode(treeNode, loadNodeToViewAllowed);
	                });

	                $("#tree-element").on("keydown", function (e) {
	                    if (e.keyCode === 13) {
	                        var node = _this.jstree().get_selected(true)[0];
	                        _this.jstree().toggle_node(node);
	                    }
	                });

	                $(this.treeElement).scroll(function () {
	                    return _this._onScroll();
	                });
	            }
	        },
	        _dispatchEvent: {
	            value: function _dispatchEvent() {
	                var _this = this;

	                if (!this.selectedNode) {
	                    return;
	                }
	                // Make sure tree data is loaded
	                this.selectedNode.load().then(function () {
	                    // Then dispatch TREE_NODE_SELECT event
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, { data: _this.selectedNode });
	                });
	            }
	        },
	        _onReady: {
	            value: function _onReady() {
	                if (this.selectedNode && (!this.selectedNode.parent && this.activeFilter)) {
	                    this._searchTree(this.searchText, false, false);
	                }

	                this.jstree().show_dots();
	                this._focusOnTree();
	                $("a.jstree-clicked").focus();
	            }
	        },
	        _registerEvents: {

	            /****************************
	             * Event registration
	             ****************************/

	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CHANGE, function (text) {
	                    return _this._searchTree(text);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CANCEL, function (text) {
	                    return _this._clear_search();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_KEYDOWN, function (key) {
	                    return _this._searchTreeKeyDown(key);
	                });

	                // Must destroy jstree on scope destroy to prevent memory leak:
	                this.$scope.$on("$destroy", function () {
	                    if (_this.jstree()) {
	                        _this.jstree().destroy();
	                    }
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DEPLOY, function (eventArgs) {
	                    _this.artifactoryState.setState("tree_touched", true); // Make sure we go inside the repo and not stay at the root level
	                    var repoKey = eventArgs[0],
	                        targetPath = eventArgs[1].targetPath;
	                    var fullpath = _.compact([repoKey, targetPath]).join("/");
	                    _this.treeBrowserDao.invalidateRoots();
	                    _this._loadNodeByPath(fullpath);
	                    // console.log(repoKey,targetPath,fullpath);

	                    // this.treeBrowserDao.findRepo(repoKey)
	                    // .then((repoNode) => {
	                    //     this._loadNodeByPath(repoNode.fullPath);
	                    // });
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_REFRESH, function (node) {
	                    _this._refreshFolder(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE, function (node) {
	                    _this._refreshOnDelete(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_MOVE, function (options) {
	                    _this._openTargetNode(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_COPY, function (options) {
	                    _this._openTargetNode(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COMPACT, function () {
	                    return _this._toggleCompactFolders();
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TABS_URL_CHANGED, function (stateParams) {
	                    if (stateParams.browser != "simple") {
	                        return;
	                    }
	                    // URL changed (like back button / forward button / someone input a URL)
	                    var currentNodePath = _this.selectedNode && _this.selectedNode.fullpath || "";
	                    if (currentNodePath != stateParams.artifact || stateParams.forceLoad) {
	                        _this._loadNodeByPath(stateParams.artifact);
	                    }
	                });

	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.REFRESH_PAGE_CONTENT, function () {
	                    if (_this.currentParentNode == null) {
	                        _this._refreshTree();
	                    } else {
	                        _this.artifactoryState.setState("refreshTreeWhenBackToRoot", true);
	                    }
	                });
	            }
	        },
	        _openTargetNode: {
	            value: function _openTargetNode(options) {
	                var _this = this;

	                this.$timeout(function () {
	                    var fullpath = _.compact([options.target.targetRepoKey, options.target.targetPath, options.node.data.text]).join("/");
	                    _this.treeBrowserDao.invalidateRoots();
	                    _this._loadNodeByPath(fullpath);
	                }, 500);
	            }
	        },
	        _buildTree: {

	            /****************************
	             * Build the JSTree from the nodes
	             ****************************/

	            value: function _buildTree(data) {

	                var hasArtifactsData = data.length > 0;
	                this.artifactoryState.setState("hasArtifactsData", hasArtifactsData);
	                this.JFrogEventBus.dispatch(this.EVENTS.TREE_DATA_IS_SET, hasArtifactsData);

	                if (hasArtifactsData) {
	                    TreeConfig.core.data = data;

	                    TreeConfig.contextmenu.items = this._getContextMenuItems.bind(this);

	                    // Search by node text only (otherwise searches the whole HTML)
	                    TreeConfig.search.search_callback = this._searchCallback.bind(this);

	                    if (this.built) {
	                        this.jstree().destroy();
	                    }
	                    $(this.treeElement).jstree(TreeConfig);
	                    this.built = true;
	                    this._registerTreeEvents();
	                }
	            }
	        },
	        _refreshTree: {

	            // setCurrentTab(tab) {
	            //     this.currentTab = tab;
	            // }

	            // isCurrentTab(tab) {
	            //     return this.currentTab === tab;
	            // }
	            /****************************
	             * Refreshing the tree
	             ****************************/

	            /**
	             * refresh children of viewed folder
	             *
	             * @param node
	             * @private
	             */

	            value: function _refreshTree() {
	                this.treeBrowserDao.invalidateRoots();
	                if (this.jstree() && this.jstree().refresh) {
	                    this.jstree().refresh();
	                }
	            }
	        },
	        _refreshOnDelete: {
	            value: function _refreshOnDelete(deletedNode) {
	                var _this = this;

	                this.$timeout(function () {
	                    if (deletedNode) {
	                        _this.selectedNode = deletedNode.data;
	                    }

	                    // Simple tree is only 2 levels deep (makes delete easy - root changes every time a node is loaded)
	                    var root = TreeConfig.core.data[1];
	                    var deletedNodeIsLastChild = root.children.length == 1;
	                    var deletedNodeIsRoot = _this._deletedNodeIsTheViewedNode(deletedNode, root);

	                    if (deletedNodeIsLastChild && !deletedNodeIsRoot) {
	                        _this.onLastChildDelete(deletedNode, root);
	                    } else if (deletedNodeIsRoot) {
	                        deletedNode.data.invalidateParent();
	                        _this._loadNodeIntoView(deletedNode.data.parent);
	                    } else {
	                        _this._refreshParentFolder(deletedNode);
	                    }

	                    _this._dispatchEvent();
	                }, 500);
	            }
	        },
	        _deletedNodeIsTheViewedNode: {
	            value: function _deletedNodeIsTheViewedNode(deletedNode, root) {
	                return root.data && deletedNode.data && root.data.fullpath === deletedNode.data.fullpath;
	            }
	        },
	        hasParentFolder: {
	            value: function hasParentFolder(node) {
	                return node && node.parent && typeof this.currentParentNode.parent !== "undefined" && node.data.parent.isFolder();
	            }
	        },
	        onLastChildDelete: {
	            value: function onLastChildDelete(deletedNode, treeRoot) {
	                // If parent exists and is folder - traverse up
	                if (this.hasParentFolder(deletedNode)) {
	                    this.currentParentNode = deletedNode.data.parent;

	                    var rootParent = treeRoot.data.parent;
	                    rootParent.invalidateChildren();
	                    this._loadNodeIntoView(rootParent);
	                }
	                // Traverse to absolute tree root
	                else {
	                    this.treeBrowserDao.invalidateRoots();
	                    this._loadNodeIntoView(this.currentParentNode.parent);
	                }
	            }
	        },
	        _refreshOnDeploy: {
	            value: function _refreshOnDeploy(repoNode) {
	                var _this = this;

	                var repoWasEmptyBeforeDeployment = !repoNode.hasChild;
	                var currentParentNode = this._getSelectedNodeTreeObject();

	                this.$timeout(function () {
	                    // If the destination folder of deployed file is empty => refresh its parent two
	                    if (repoWasEmptyBeforeDeployment) {
	                        // If this is an empty repo at root level - refresh the tree
	                        if (_this._viewedNodeIsRepo()) {
	                            _this._refreshTree();
	                        }
	                        // If this is sn empty folder not at root level - traverse to parent
	                        else {
	                            _this._refreshParentFolder(currentParentNode.parent);
	                        }
	                    }
	                    // Else => refresh the node itself
	                    else {
	                        var folderToRefresh = _this._getViewedNodeTreeObject();
	                        _this._refreshFolder(folderToRefresh);
	                    }
	                }, 800);
	            }
	        },
	        _refreshFolder: {
	            value: function _refreshFolder(node) {
	                // console.log(node.data,this.currentParentNode);
	                if (node.data) {
	                    node.data.invalidateChildren();
	                } else {
	                    this.treeBrowserDao.invalidateRoots();
	                }

	                if (node.data != this.currentParentNode) {
	                    return;
	                }
	                this._loadNodeIntoView(node.data);
	            }
	        },
	        _refreshParentFolder: {
	            value: function _refreshParentFolder(node) {
	                var _this = this;

	                if (node.data) {
	                    node.data.invalidateChildren();
	                    node.data.invalidateParent();
	                }
	                var parentNodeItem = this.jstree().get_node(node.parent);
	                this.$timeout(function () {
	                    _this._refreshFolder(parentNodeItem);
	                    _this.jstree().select_node(parentNodeItem);
	                }, 500);
	            }
	        },
	        _viewedNodeIsRepo: {
	            value: function _viewedNodeIsRepo() {
	                return this.currentParentNode === null || typeof this.currentParentNode.parent === "undefined";
	            }
	        },
	        _getSelectedNodeTreeObject: {
	            value: function _getSelectedNodeTreeObject() {
	                return this.jstree().get_node(this._getSelectedNode());
	            }
	        },
	        _getViewedNodeTreeObject: {
	            value: function _getViewedNodeTreeObject() {
	                var selected = this._getSelectedNodeTreeObject();
	                return selected.data !== null && selected.data.hasChild ? selected : this.jstree().get_node(selected.parent);
	            }
	        }
	    });

	    return JfSimpleBrowserController;
	})(JFCommonBrowser);

	function jfSimpleBrowser() {
	    return {
	        scope: {
	            browserController: "="
	        },
	        restrict: "E",
	        controller: JfSimpleBrowserController,
	        controllerAs: "SimpleBrowser",
	        bindToController: true,
	        link: function ($scope, attrs, $element, SimpleBrowser) {
	            return SimpleBrowser.initJSTree();
	        },
	        templateUrl: "states/artifacts/jf_simple_browser/jf_simple_browser.html"
	    };
	}

	// Going up to roots
	// Not selecting the current parent

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var TreeConfig = _interopRequire(__webpack_require__(281));

	module.exports = _.cloneDeep(TreeConfig);

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	/**
	 * launch a modal that prompts the user to select a target repo & path to do move / copy
	 *
	 * @param action:String - either 'copy' or 'move'
	 * @returns promise - resolved with Object({targetRepoKey: String, targetPath: String}) if the user confirmed, rejected otherwise
	 */
	exports.selectTargetPathFactory = selectTargetPathFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIPS = _interopRequire(__webpack_require__(96));

	"use strict";
	function selectTargetPathFactory(ArtifactActionsDao, $q, $rootScope, JFrogModal, RepoDataDao) {
	    return function selectTargetPath(action, node, useNodePath, customDryRun, defaultValues) {

	        if (useNodePath === undefined) useNodePath = true;

	        var deferred = $q.defer();
	        var modalInstance = undefined;

	        // init modal scope
	        var modalScope = $rootScope.$new();
	        modalScope.action = action;
	        modalScope.node = node;
	        modalScope.target = {
	            repoList: [],
	            repoKey: defaultValues ? defaultValues.targetRepoKey : "",
	            path: useNodePath ? angular.copy(node.data.path) : defaultValues ? defaultValues.targetPath : "/",
	            isCustomPath: false
	        };
	        modalScope.tooltips = TOOLTIPS.selectTargetPathModal;

	        // get local repo list that match the original's repo pkg type
	        var isMavinish = function (pkgType) {
	            return _.contains(["maven", "ivy", "gradle", "sbt"], pkgType.toLowerCase());
	        };
	        RepoDataDao.get({ user: true }).$promise.then(function (result) {
	            if (node.data.getRoot && node.data.getRoot().repoPkgType && action !== "restore") {
	                result.repoTypesList = _.filter(result.repoTypesList, function (repo) {
	                    return repo.repoType === node.data.getRoot().repoPkgType || repo.repoType === "Generic" || isMavinish(repo.repoType) && isMavinish(node.data.getRoot().repoPkgType);
	                });
	            } else {}
	            modalScope.target.repoList = result.repoTypesList.map(function (repo) {
	                return { value: repo.repoKey, text: repo.repoKey };
	            });
	        });

	        if (action === "restore") modalScope.noDryRun = true;

	        // scope functions for modal
	        modalScope.cancel = function () {
	            modalInstance.close();
	            deferred.reject();
	        };
	        modalScope.confirm = function () {
	            deferred.resolve({
	                target: {
	                    targetRepoKey: modalScope.target.repoKey,
	                    targetPath: modalScope.getTargetPath()
	                },
	                onSuccess: function () {
	                    modalInstance.close();
	                    deferred = $q.defer();
	                    deferred.resolve();
	                    return deferred.promise;
	                },
	                onFail: function (msg) {
	                    modalScope.resultError = true;
	                    modalScope.dryRunResults = msg;
	                    deferred = $q.defer();
	                    return deferred.promise;
	                }
	            });
	        };
	        modalScope.getTargetPath = function () {
	            return modalScope.target.isCustomPath && modalScope.target.path || modalScope.target.path;
	        };
	        modalScope.dryRun = customDryRun || function () {
	            var data = {
	                repoKey: node.data.repoKey,
	                path: node.data.path,
	                targetRepoKey: modalScope.target.repoKey,
	                targetPath: modalScope.getTargetPath(),
	                dryRun: true
	            };
	            var params = { action: action };
	            ArtifactActionsDao.dryRun(params, data).$promise.then(function (response) {
	                modalScope.resultError = false;
	                modalScope.dryRunResults = [response.info];
	            })["catch"](function (response) {
	                modalScope.resultError = true;
	                modalScope.dryRunResults = response.data.errors;
	            });
	        };

	        if (customDryRun) customDryRun.scope = modalScope;

	        // Launch modal
	        modalInstance = JFrogModal.launchModal("select_target_path", modalScope, "sm");
	        return deferred.promise;
	    };
	}

/***/ }),
/* 288 */
/***/ (function(module, exports) {

	"use strict";

	exports.commonGridColumns = commonGridColumns;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	function commonGridColumns() {
	    var nextId = 0;
	    return {
	        repoPathColumn: function repoPathColumn(specialClass) {
	            return "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.repoKey}}/{{row.entity.path}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.path}}</div>";
	        },

	        downloadableColumn: function downloadableColumn(specialClass) {
	            return "<div ng-if=\"row.entity.downloadLink\"\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.name}}</div>" + "<div ng-if=\"!row.entity.downloadLink\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.name}}</div>";
	        },

	        booleanColumn: function booleanColumn(model) {
	            return "<div class=\"grid-checkbox\"><input ng-model=\"" + model + "\" type=\"checkbox\" disabled/><span class=\"icon icon-v\"></span></div>";
	        },
	        checkboxColumn: function checkboxColumn(model, click, disabled) {
	            return "<div ng-if=\"!row.entity._emptyRow\" class=\"grid-cell-checkbox\"><jf-checkbox><input ng-model=\"" + model + "\"" + (click && click.length ? " ng-click=\"" + click + "\"" : "") + (disabled && disabled.length ? " ng-disabled=\"" + disabled + "\"" : "") + " type=\"checkbox\"/></jf-checkbox></div>";
	        },
	        listableColumn: function listableColumn(listModel, rowNameModel, displayModel, alwaysShow) {
	            var testIdPrefix = arguments[4] === undefined ? null : arguments[4];

	            testIdPrefix = testIdPrefix ? testIdPrefix + "-" : "";

	            displayModel = displayModel ? "{{" + listModel + ".length}} | {{" + displayModel + "}}" : "{{" + listModel + ".length}} | {{" + listModel + ".join(', ')}}";

	            var id = "" + testIdPrefix + "{{row.uid}}_" + nextId;

	            var alwaysShowClass = alwaysShow ? "always-show" : "";

	            var template = "<div ng-if=\"" + listModel + ".length\" class=\"ui-grid-cell-contents no-tooltip " + alwaysShowClass + "\" id=\"" + id + "\"><span class=\"gridcell-content-text\">" + displayModel + "</span><a class=\"gridcell-showall\" ng-if=\"grid.options.isOverflowing('" + testIdPrefix + "'+row.uid+'_'+" + nextId + ") || " + alwaysShow + "\" href ng-click=\"grid.options.showAll(" + listModel + "," + rowNameModel + ",col)\"> (See All)</a></div>\n                             <div ng-if=\"!" + listModel + ".length\" class=\"ui-grid-cell-contents no-tooltip\" id=\"" + id + "\">-</div>";

	            nextId++;
	            return template;
	        },
	        iconColumn: function iconColumn(cellText, cellIcon, iconClass) {
	            return "<div class=\"ui-grid-cell-contents\" id=\"type\"><i class=\"icon icon-{{" + cellIcon + "}}" + (iconClass ? " " + iconClass : "") + "\"></i>{{" + cellText + "}}</div>";
	        },
	        ajaxColumn: function ajaxColumn() {
	            return "<div class=\"ui-grid-cell-contents status-grid\"><div class=\"icon-hourglass\" ng-if=\"!row.entity.status\"></div>{{row.entity.status}}</div>";
	        }
	    };
	}

/***/ }),
/* 289 */
/***/ (function(module, exports) {

	
	/**
	 * launch a modal that prompts the user to select a target repo & path to do move / copy
	 *
	 * @param action:String - either 'copy' or 'move'
	 * @returns promise - resolved with Object({targetRepoKey: String, targetPath: String}) if the user confirmed, rejected otherwise
	 */
	"use strict";

	exports.selectDeleteVersionsFactory = selectDeleteVersionsFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	"use strict";
	function selectDeleteVersionsFactory($q, ArtifactActionsDao, $rootScope, JFrogModal, JFrogGridFactory) {
	    return function selectDeleteVersions(node) {
	        var modalInstance = undefined;
	        var modalScope = $rootScope.$new();
	        modalScope.noData = false;

	        // Grid
	        modalScope.versionsGridOptions = JFrogGridFactory.getGridInstance(modalScope).setColumns([{
	            name: "Group ID",
	            displayName: "Group ID",
	            field: "groupId"
	        }, {
	            name: "Version",
	            displayName: "Version",
	            field: "version"
	        }, {
	            name: "Directories Count",
	            displayName: "Directories Count",
	            field: "directoriesCount"
	        }]).setRowTemplate("default").setMultiSelect();

	        // Scope functions
	        modalScope.selectedVersions = function () {
	            return modalScope.versions && modalScope.versionsGridOptions.api && modalScope.versionsGridOptions.api.selection.getSelectedRows() || [];
	        };

	        modalScope.close = function (version) {
	            modalInstance.close(version);
	        };

	        var defer = $q.defer();

	        ArtifactActionsDao.getDeleteVersions({ repoKey: node.data.repoKey, path: node.data.path }).$promise.then(function (versions) {
	            modalScope.versions = versions.data.versions;
	            modalScope.versionsGridOptions.setGridData(versions.data.versions);
	            if (versions.data.versions.length == 0) {
	                modalScope.noData = true;
	            }
	        })["finally"](function () {
	            // Launch modal
	            var modalSize = modalScope.noData ? "sm" : "lg";
	            modalInstance = JFrogModal.launchModal("select_delete_versions", modalScope, modalSize);
	            modalInstance.result.then(function (versions) {
	                return defer.resolve(versions);
	            });
	        });

	        return defer.promise;
	    };
	}

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfArtifactInfo = jfArtifactInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfArtifactInfoController = (function () {
	    function jfArtifactInfoController($element, $stateParams, $state, $scope, JFrogEventBus, $timeout, User, ArtifactoryFeatures) {
	        var _this = this;

	        _classCallCheck(this, jfArtifactInfoController);

	        this.$element = $element;
	        this.stateParams = $stateParams;
	        this.state = $state;
	        this.features = ArtifactoryFeatures;
	        this.$timeout = $timeout;
	        this.user = User;
	        this.DICTIONARY = DICTIONARY.tabs;
	        this.isDropdownOpen = false;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        JFrogEventBus.registerOnScope($scope, this.EVENTS.TREE_NODE_SELECT, function (node) {
	            return _this.selectNode(node);
	        });
	        $scope.$on("ui-layout.resize", function () {
	            return _this._refreshTabs();
	        });
	    }

	    _createClass(jfArtifactInfoController, {
	        selectNode: {
	            value: function selectNode(node) {
	                if (node.data) {
	                    // wait for the element to render and calculate how many tabs should display
	                    if (!angular.equals(this.infoTabs, node.data.tabs)) {
	                        this._refreshTabs();
	                    }
	                    this.infoTabs = node.data.tabs;
	                    this._transformInfoTabs();
	                    this.currentNode = node;
	                    // if current tab exists in the new node - dispatch an event:
	                    if (_.findWhere(this.infoTabs, { name: this.stateParams.tab }) && this.stateParams.tab !== "StashInfo") {
	                        this.JFrogEventBus.dispatch(this.EVENTS.TAB_NODE_CHANGED, node);
	                    }
	                } else {
	                    this.currentNode = null;
	                }
	            }
	        },
	        _refreshTabs: {
	            value: function _refreshTabs() {
	                this.JFrogEventBus.dispatch(this.EVENTS.TABS_REFRESH);
	            }
	        },
	        _transformInfoTabs: {
	            value: function _transformInfoTabs() {
	                var features = {
	                    Watch: "watches",
	                    Properties: "properties",
	                    Builds: "builds"
	                };
	                this.infoTabs.forEach(function (tab) {
	                    tab.feature = features[tab.name];
	                });
	            }
	        }
	    });

	    return jfArtifactInfoController;
	})();

	function jfArtifactInfo() {
	    return {
	        restrict: "E",
	        controller: jfArtifactInfoController,
	        controllerAs: "jfArtifactInfo",
	        templateUrl: "states/artifacts/jf_artifact_info/jf_artifact_info.html",
	        bindToController: true
	    };
	}

/***/ }),
/* 291 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    name: "Name",
	    description: "Description",
	    artifactsCount: "Artifact Count / Size",
	    repositoryPath: "Repository Path",
	    originPath: "Source Path",
	    bintrayOrg: "Bintray Organization",
	    bintrayProduct: "Bintray Product",
	    bintrayUrl: "Bintray Link",
	    repositoryLayout: "Repository Layout",
	    repoType: "Package Type",
	    remoteRepoUrl: "Remote Repository URL",
	    created: "Created",
	    deployedBy: "Deployed by",
	    licenses: "Licenses",
	    filtered: "Filtered",
	    downloaded: "Downloads",
	    remoteDownloaded: "Remote Downloads",
	    moduleID: "Module ID",
	    size: "Size",
	    lastModified: "Last Modified",
	    lastDownloaded: "Last Downloaded",
	    lastRemoteDownloaded: "Last Downloaded Remotely",
	    compressed: "Compressed",
	    crc: "CRC",
	    modificationTime: "Modification Time",
	    path: "Path",
	    watchingSince: "Watching Since",
	    lastDownloadedBy: "Last Downloaded By",
	    lastRemoteDownloadedBy: "Last Downloaded Remotely By",
	    lastReplicationStatus: "Last Replication Status",
	    signingKeyLink: "Signing Key",
	    externalUrl: "External URL",
	    tabs: {
	        General: "General",
	        Properties: "Properties",
	        EffectivePermission: "Effective Permissions",
	        Watch: "Watchers",
	        Builds: "Builds",
	        GeneralXml: "Xml View",
	        ViewSource: "View Source",
	        NuPkgInfo: "NuPkg Info",
	        PomView: "Pom View",
	        IVYXml: "Ivy View",
	        RubyGems: "RubyGems",
	        NpmInfo: "Npm Info",
	        DebianInfo: "Debian Info",
	        OpkgInfo: "Opkg Info",
	        ChefInfo: "Chef Info",
	        ComposerInfo: "Composer Info",
	        PyPIInfo: "PyPI Info",
	        PuppetInfo: "Puppet Info",
	        BowerInfo: "Bower Info",
	        DockerInfo: "Docker Info",
	        DockerAncestryInfo: "Docker Ancestry",
	        DockerV2Info: "Docker Info",
	        Rpm: "Rpm Info",
	        Cocoapods: "Cocoapods Info",
	        ConanInfo: "Conan Info",
	        ConanPackageInfo: "Conan Package Info",
	        StashInfo: "Stash Info"
	    },
	    nuget: {
	        authors: "Authors",
	        owners: "Owners",
	        pkgTitle: "Title",
	        tags: "Tags",
	        version: "Version",
	        requireLicenseAcceptance: "Require License Acceptance",
	        id: "ID",
	        title: "Title",
	        languages: "Languages",
	        releaseNotes: "Release Notes",
	        summary: "Summary",
	        projectUrl: "Project URL",
	        copyright: "Copyright",
	        licenseUrl: "License URL"

	    },
	    composer: {
	        name: "Name",
	        version: "Version",
	        authors: "Authors",
	        licenses: "Licenses",
	        type: "Type",
	        keywords: "Keywords"

	    },
	    chef: {
	        name: "Name",
	        version: "Version",
	        maintainer: "Maintainer",
	        sourceUrl: "Source URL",
	        license: "License"
	    },
	    conan: {
	        name: "Name",
	        version: "Version",
	        user: "User",
	        channel: "Channel",
	        reference: "Reference",
	        author: "Author",
	        license: "License",
	        url: "URL",
	        //Conan Package Info
	        os: "OS",
	        arch: "Architecture",
	        buildType: "Build Type",
	        compiler: "Compiler",
	        compilerVersion: "Compiler Version",
	        compilerRuntime: "Compiler Runtime",
	        shared: "Shared"
	    },
	    docker: {
	        //Info:
	        imageId: "Image Id",
	        parent: "Parent Id",
	        created: "Created",
	        container: "Container",
	        dockerVersion: "Docker Version",
	        author: "Author",
	        architecture: "Architecture",
	        os: "OS",

	        //Config:
	        size: "Size",
	        hostname: "Hostname",
	        domainName: "DomainName",
	        user: "User",
	        memory: "Memory",
	        memorySwap: "MemorySwap",
	        cpuShares: "CpuShares",
	        cpuSet: "CpuSet",
	        attachStdin: "AttachStdin",
	        attachStdout: "AttachStdout",
	        attachStderr: "AttachStderr",
	        portSpecs: "portSpecs",
	        exposedPorts: "exposedPorts",
	        tty: "Tty",
	        openStdin: "OpenStdin",
	        stdinOnce: "StdinOnce",
	        env: "Env",
	        cmd: "Cmd",
	        image: "Image",
	        volumes: "Volumes",
	        workingDir: "WorkingDir",
	        entryPoint: "EntryPoint",
	        networkDisabled: "NetworkDisabled",
	        onBuild: "OnBuild"

	    },
	    dockerAncestry: {
	        size: "Virtual Size"
	    },
	    dockerV2: {
	        title: "Title",
	        digest: "Digest",
	        ports: "Ports",
	        totalSize: "Total Size",
	        volumes: "Volumes"
	    },
	    pyPi: {
	        name: "Name",
	        author: "Author",
	        authorEmail: "Author Email",
	        homepage: "Homepage",
	        downloadUrl: "Download URL",
	        platform: "Platform",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        summary: "Summary"
	    },
	    puppet: {
	        name: "Name",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        description: "Description"
	    },
	    bower: {
	        name: "Name",
	        description: "Description",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        repository: "Repository"
	    },
	    rubyGems: {
	        authors: "Authors",
	        owners: "Owners",
	        description: "Description",
	        homepage: "Homepage",
	        name: "Name",
	        platform: "Platform",
	        summary: "Summary",
	        repositoryPath: "Repository Path",
	        version: "Version"

	    },
	    npm: {
	        name: "Name",
	        version: "Version",
	        license: "License",
	        description: "Description",
	        keywords: "Keywords",
	        repository: "Repository"
	    },
	    debian: {
	        packageName: "Name",
	        version: "Version",
	        architecture: "Architecture",
	        description: "Description",
	        section: "Section",
	        priority: "Priority",
	        maintainer: "Maintainer",
	        website: "Website",
	        size: "Size",
	        license: "License"
	    },
	    opkg: {
	        packageName: "Name",
	        version: "Version",
	        architecture: "Architecture",
	        description: "Description",
	        section: "Section",
	        priority: "Priority",
	        maintainer: "Maintainer",
	        website: "Website",
	        size: "Size",
	        license: "License"

	    },
	    rpm: {
	        buildDate: "Build Date",
	        epoch: "Epoch",
	        name: "Name",
	        release: "Release",
	        size: "Size",
	        summary: "Summary",
	        version: "Version",
	        buildHost: "Build Host",
	        packager: "Packager",
	        sourceRpm: "Source Rpm",
	        url: "URL",
	        vendor: "Vendor"

	    },
	    cocoapods: {
	        name: "Name",
	        description: "Description",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords"
	    },
	    trash: {
	        deletedTime: "Deleted Time",
	        deletedBy: "Deleted By",
	        originalRepository: "Original Repository",
	        originalRepositoryType: "Original Repository Type",
	        originalPath: "Original Path"
	    }
	};

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var jfBuilds = __webpack_require__(293).jfBuilds;

	var jfEffectivePermissions = __webpack_require__(294).jfEffectivePermissions;

	var jfWatchers = __webpack_require__(295).jfWatchers;

	var jfGeneral = __webpack_require__(296).jfGeneral;

	var jfProperties = __webpack_require__(297).jfProperties;

	var jfViewSource = __webpack_require__(298).jfViewSource;

	var jfPomView = __webpack_require__(299).jfPomView;

	var jfXmlView = __webpack_require__(300).jfXmlView;

	var jfIvyView = __webpack_require__(301).jfIvyView;

	var jfNuget = __webpack_require__(302).jfNuget;

	var jfComposer = __webpack_require__(303).jfComposer;

	var jfPyPi = __webpack_require__(304).jfPyPi;

	var jfPuppet = __webpack_require__(305).jfPuppet;

	var jfBower = __webpack_require__(306).jfBower;

	var jfDocker = __webpack_require__(307).jfDocker;

	var jfDockerAncestry = __webpack_require__(308).jfDockerAncestry;

	var jfDockerV2 = __webpack_require__(309).jfDockerV2;

	var jfRubyGems = __webpack_require__(310).jfRubyGems;

	var jfNpmInfo = __webpack_require__(311).jfNpmInfo;

	var jfRpm = __webpack_require__(312).jfRpm;

	var jfCocoapods = __webpack_require__(313).jfCocoapods;

	var jfConan = __webpack_require__(314).jfConan;

	var jfConanPackage = __webpack_require__(315).jfConanPackage;

	var jfStashInfo = __webpack_require__(316).jfStashInfo;

	var jfDebianInfo = __webpack_require__(317).jfDebianInfo;

	var jfOpkgInfo = __webpack_require__(318).jfOpkgInfo;

	var jfChefInfo = __webpack_require__(319).jfChefInfo;

	module.exports = angular.module("infoTabs", []).directive({
	    jfBuilds: jfBuilds,
	    jfEffectivePermissions: jfEffectivePermissions,
	    jfWatchers: jfWatchers,
	    jfGeneral: jfGeneral,
	    jfProperties: jfProperties,
	    jfViewSource: jfViewSource,
	    jfPomView: jfPomView,
	    jfXmlView: jfXmlView,
	    jfIvyView: jfIvyView,
	    jfNuget: jfNuget,
	    jfComposer: jfComposer,
	    jfPyPi: jfPyPi,
	    jfPuppet: jfPuppet,
	    jfBower: jfBower,
	    jfConan: jfConan,
	    jfConanPackage: jfConanPackage,
	    jfDocker: jfDocker,
	    jfDockerAncestry: jfDockerAncestry,
	    jfDockerV2: jfDockerV2,
	    jfRubyGems: jfRubyGems,
	    jfNpmInfo: jfNpmInfo,
	    jfRpm: jfRpm,
	    jfCocoapods: jfCocoapods,
	    jfStashInfo: jfStashInfo,
	    jfDebianInfo: jfDebianInfo,
	    jfChefInfo: jfChefInfo,
	    jfOpkgInfo: jfOpkgInfo
	});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfBuilds = jfBuilds;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfBuildsController = (function () {
	    function jfBuildsController($state, JFrogGridFactory, ArtifactBuildsDao, $scope, JFrogEventBus, JFrogModal, uiGridConstants) {
	        _classCallCheck(this, jfBuildsController);

	        this.uiGridConstants = uiGridConstants;
	        this.producedByGridOptions = {};
	        this.usedByGridOptions = {};
	        this.$state = $state;
	        this.buildsDao = ArtifactBuildsDao.getInstance();
	        this.$scope = $scope;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.mode = "ProducedBy";
	        this.builds = {};

	        this._generateViewBySwitch();
	        this._registerEvents();
	        this._createGrids();
	        this._getBuildData();
	    }

	    _createClass(jfBuildsController, {
	        downloadJson: {
	            value: function downloadJson(build) {
	                var _this = this;

	                this.buildsDao.getJson({
	                    buildNumber: build.number,
	                    buildName: build.name,
	                    startTime: build.started
	                }).$promise.then(function (result) {
	                    _this.modal.launchCodeModal("Build #" + build.number, result.json, { name: "javascript", json: true });
	                });
	            }
	        },
	        _getBuildData: {
	            value: function _getBuildData() {
	                var _this = this;

	                // if the node does not have a path the build cannot be loaded
	                // this may occur in navigation to a node that does not have a path (repo node)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.buildsDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (builds) {
	                    _this.builds = builds;
	                    _this.producedByGridOptions.setGridData(builds.producedBy);
	                    _this.usedByGridOptions.setGridData(builds.usedBy);
	                    _this._generateViewBySwitch();
	                });
	            }
	        },
	        _generateViewBySwitch: {
	            value: function _generateViewBySwitch() {
	                this.viewBySwitch = [{
	                    text: "Produced By" + (this.producedByGridOptions.data && this.producedByGridOptions.data.length ? " (" + this.builds.producedBy.length + ")" : ""),
	                    value: "ProducedBy"
	                }, {
	                    text: "Used By" + (this.usedByGridOptions.data && this.usedByGridOptions.data.length ? " (" + this.builds.usedBy.length + ")" : ""),
	                    value: "UsedBy"
	                }];

	                if (this.switchControl) {
	                    this.switchControl.options = this.viewBySwitch;
	                    this.switchControl.updateOptionObjects();
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode !== node) {
	                        _this.currentNode = node;
	                        self._getBuildData();
	                    }
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.producedByGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getProducedByColumns()).setRowTemplate("default").setButtons(this._getActions());
	                this.usedByGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getUsedByColumns()).setRowTemplate("default").setButtons(this._getActions());
	            }
	        },
	        _getProducedByColumns: {
	            value: function _getProducedByColumns() {
	                var columns = this._getCommonColumns();
	                columns.splice(4, 0, {
	                    displayName: "Started At",
	                    name: "Started At",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.startedString }}</a>",
	                    field: "started",
	                    type: "number"
	                });
	                return columns;
	            }
	        },
	        _getCommonColumns: {
	            value: function _getCommonColumns() {
	                return [{
	                    displayName: "Project Name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    name: "Project Name",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"project-name\" >{{row.entity.name}}</div>" }, {
	                    displayName: "Build ID",
	                    name: "Build ID",
	                    grouped: true,
	                    allowGrouping: true,
	                    field: "number",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"builds.info({buildName:row.entity.name,buildNumber:row.entity.number,tab:'general',startTime:row.entity.started})\" id=\"build-id\">{{row.entity.number}}</a></div>"
	                }, {
	                    name: "Module ID",
	                    displayName: "Module ID",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "moduleID",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"builds.info({buildName:row.entity.name,buildNumber:row.entity.number,tab:'published',startTime:row.entity.started,moduleID:row.entity.moduleID})\" id=\"module-id\" >{{row.entity.moduleID}}</a></div>"
	                }, {
	                    displayName: "CI Server",
	                    name: "CI Server",
	                    field: "ciUrl",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-href=\"{{row.entity.ciUrl}}\" target=\"_blank\" id=\"ci-server\">{{row.entity.ciUrl}}</a></div>"
	                }];
	            }
	        },
	        _getUsedByColumns: {
	            value: function _getUsedByColumns() {
	                var columns = this._getCommonColumns();
	                columns.splice(3, 0, {
	                    displayName: "Scope",
	                    name: "Scope",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "scope"
	                });
	                return columns;
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-view",
	                    tooltip: "View Build JSON",
	                    callback: function (row) {
	                        return _this.downloadJson(row);
	                    }
	                }];
	            }
	        }
	    });

	    return jfBuildsController;
	})();

	function jfBuilds() {
	    return {
	        restrict: "EA",
	        controller: jfBuildsController,
	        controllerAs: "jfBuilds",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_builds.html"
	    };
	}

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfEffectivePermissions = jfEffectivePermissions;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfEffectivePermissionsController = (function () {
	    function jfEffectivePermissionsController(JFrogGridFactory, ArtifactPermissionsDao, $state, $scope, $timeout, JFrogEventBus, uiGridConstants, commonGridColumns, User) {
	        _classCallCheck(this, jfEffectivePermissionsController);

	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$timeout = $timeout;
	        this.User = User;
	        this.currentTab = "Users";
	        this.userEffectivePermissionsGridOption = {};
	        this.groupEffectivePermissionsGridOption = {};
	        this.permissionTargetsGridOption = {};
	        this.permissionsDao = ArtifactPermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this._registerEvents();
	        this._createGrids();
	        this._getPermissionsData();
	        this.currentUser = this.User.getCurrent();
	    }

	    _createClass(jfEffectivePermissionsController, {
	        _getPermissionsData: {
	            value: function _getPermissionsData() {
	                var _this = this;

	                return this.permissionsDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "principal"
	                }).$promise.then(function (data) {
	                    _this.userEffectivePermissionsGridOption.setGridData(data.userEffectivePermissions);
	                    _this.groupEffectivePermissionsGridOption.setGridData(data.groupEffectivePermissions);
	                    _this.permissionTargetsGridOption.setGridData(data.permissionTargets);
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.userEffectivePermissionsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getUserGroupGridColumns("users")).setRowTemplate("default");
	                this.groupEffectivePermissionsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getUserGroupGridColumns("groups")).setRowTemplate("default");
	                this.permissionTargetsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getPermissionTargetGridColumns()).setRowTemplate("default");
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.userEffectivePermissionsGridOption.resetPagination();
	                    _this.userEffectivePermissionsGridOption.getPage();
	                    _this.groupEffectivePermissionsGridOption.resetPagination();
	                    _this.groupEffectivePermissionsGridOption.getPage();
	                    _this.permissionTargetsGridOption.resetPagination();
	                    _this.permissionTargetsGridOption.getPage();
	                    _this.$timeout(function () {
	                        _this._getPermissionsData();
	                    });
	                });
	            }
	        },
	        goToEditPrincipal: {
	            value: function goToEditPrincipal(tableType, row) {
	                var _this = this;

	                // Make sure the session has not timed out yet
	                this.User.loadUser(true).then(function () {
	                    // If session is expired  => go to login state
	                    if (!_this.User.getCurrent().isAdmin()) {
	                        _this.$state.go("login");
	                    }

	                    // If admin - go to edit page of selected principal
	                    var principal = {};
	                    var state = "admin.security." + tableType + ".edit";
	                    var principalName = tableType === "users" ? "username" : "groupname";
	                    principal[principalName] = row.principal;
	                    _this.$state.go(state, principal);
	                });
	            }
	        },
	        isCurrentUserAdmin: {
	            value: function isCurrentUserAdmin() {
	                return this.currentUser.isAdmin();
	            }
	        },
	        getUserGroupGridColumns: {
	            value: function getUserGroupGridColumns(tableType) {
	                return [{
	                    name: "Principal",
	                    displayName: "Principal",
	                    field: "principal",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    <i jf-tooltip=\"Admin Privileges\"\n                                       class=\"icon pull-left\"\n                                       ng-class=\"row.entity.admin ? 'icon-admin-new' : 'icon-blank'\"></i>\n                                    <a href \n                                       ng-if=\"grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\"\n                                       ng-click=\"grid.appScope.jfEffectivePermissions.goToEditPrincipal('" + tableType + "',row.entity)\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </a>\n                                    <span ng-if=\"!grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </span>\n                                </div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "25%"
	                }, {
	                    name: "Permission Targets",
	                    displayName: "Permission Targets",
	                    field: "permissionTargets",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents permission-target-cell\" \n                      ng-class=\"{'show-cap-warning': row.entity.permissionTargetsCap && grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()}\">\n                      <span class=\"gridcell-content-text\">\n                          <span ng-bind-html=\"grid.appScope.jfEffectivePermissions.toPremissionTargetsList(row.entity.permissionTargets,row.entity.permissionTargetsCap)\"></span>\n                          <i class=\"icon icon-notification-warning pull-right\"\n                             jf-tooltip=\"To view all the Permission Targets the principal is associated with, click on the principal name.\"></i>\n                    </span>\n                </div>",
	                    width: "33%"
	                }, {
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    field: "permission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "14%"
	                }, {
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    field: "permission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "12%"
	                }, {
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    field: "permission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "9%"
	                }, {
	                    name: "Read",
	                    displayName: "Read",
	                    field: "permission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "7%"
	                }];
	            }
	        },
	        toPremissionTargetsList: {
	            value: function toPremissionTargetsList(permissionTargersArray, isCapped) {
	                var listLengthString = isCapped ? "" : permissionTargersArray.length + " | ";
	                return !permissionTargersArray.length ? "-" : listLengthString + permissionTargersArray.join(", ");
	            }
	        },
	        triggerTimoutBeforeSwitch: {
	            value: function triggerTimoutBeforeSwitch() {
	                this.$timeout(function () {
	                    try {
	                        window.dispatchEvent(new Event("resize"));
	                    } catch (e) {
	                        var resizeEvent = document.createEvent("Event");
	                        window.dispatchEvent(resizeEvent);
	                    }
	                });
	            }
	        },
	        goToEditPermission: {
	            value: function goToEditPermission(row) {
	                this.$state.go("admin.security.permissions.edit", { permission: row.permissionName });
	            }
	        },
	        getPermissionTargetGridColumns: {
	            value: function getPermissionTargetGridColumns() {
	                return [{
	                    name: "Permission Target Name",
	                    displayName: "Permission Target Name",
	                    field: "permissionName",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    <a href \n                                       ng-if=\"grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\"\n                                       ng-click=\"grid.appScope.jfEffectivePermissions.goToEditPermission(row.entity)\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </a>\n                                    <span ng-if=\"!grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </span>\n                             </div>",
	                    width: "25%"
	                }, {
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.repoKeys", "row.entity.permissionName"),
	                    field: "repoKeysView",
	                    width: "25%"
	                }, {
	                    name: "Groups",
	                    displayName: "Groups",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.groups", "row.entity.permissionName"),
	                    field: "groupsList",
	                    width: "25%"

	                }, {
	                    name: "Users",
	                    displayName: "Users",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.users", "row.entity.permissionName"),
	                    field: "usersList",
	                    width: "25%"
	                }];
	            }
	        }
	    });

	    return jfEffectivePermissionsController;
	})();

	function jfEffectivePermissions() {
	    return {
	        restrict: "EA",
	        controller: jfEffectivePermissionsController,
	        controllerAs: "jfEffectivePermissions",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_effective_permissions.html"
	    };
	}

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfWatchers = jfWatchers;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfWatchersController = (function () {
	    function jfWatchersController($scope, $state, ArtifactWatchesDao, JFrogGridFactory, JFrogEventBus, $q, ArtifactoryStorage) {
	        _classCallCheck(this, jfWatchersController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.watchersGridOption = {};
	        this.artifactWatchesDao = ArtifactWatchesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.$q = $q;
	        this._createGrid();
	        this._getWatchesData();
	        this._registerEvents();
	    }

	    _createClass(jfWatchersController, {
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getWatchesData();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this._getWatchesData();
	                });
	            }
	        },
	        _deleteWatches: {
	            value: function _deleteWatches(watches) {
	                var _this = this;

	                var data = watches.map(function (watch) {
	                    var selectedWachers = {
	                        name: watch.watcherName,
	                        repoKey: watch.watchConfigureOn.split(":")[0],
	                        path: watch.watchConfigureOn.split(":")[1]
	                    };
	                    return selectedWachers;
	                });
	                var json = { watches: data };

	                return this.artifactWatchesDao["delete"](json).$promise.then(function () {
	                    _this.JFrogEventBus.dispatch(EVENTS.ACTION_UNWATCH, _this.currentNode);
	                    _this._getWatchesData();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;

	                var batchActions = [{
	                    callback: function (watches) {
	                        return _this._deleteWatches(watches);
	                    },
	                    visibleWhen: function () {
	                        return _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    },
	                    name: "Delete",
	                    icon: "clear"
	                }];

	                this.watchersGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(batchActions).setButtons(this._getActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Watcher Name",
	                    displayName: "Watcher Name",
	                    field: "watcherName",
	                    width: "20%"
	                }, {
	                    name: "Watching Since",
	                    displayName: "Watching Since",
	                    field: "watchingSince",
	                    width: "30%"
	                }, {
	                    name: "Watch Configured On",
	                    displayName: "Watch Configured On",
	                    field: "watchConfigureOn",
	                    width: "50%"
	                }];
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                var repoKey = row.watchConfigureOn.split(":")[0];
	                var path = row.watchConfigureOn.split(":")[1];
	                var artifactPath = repoKey + "/" + path;
	                var archivePath = "";
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    browser: browser,
	                    artifact: artifactPath
	                });
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-show-in-tree",
	                    tooltip: "Show In Tree",
	                    callback: function (row) {
	                        return _this.showInTree(row);
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (watch) {
	                        return _this._deleteWatches([watch]);
	                    },
	                    visibleWhen: function () {
	                        return _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    } }];
	            }
	        },
	        _getWatchesData: {
	            value: function _getWatchesData() {
	                var _this = this;

	                var self = this;
	                this.artifactWatchesDao.query({
	                    path: self.currentNode.data.path,
	                    repoKey: self.currentNode.data.repoKey
	                }).$promise.then(function (watchers) {
	                    _this.watchers = watchers;
	                    _this.watchersGridOption.setGridData(watchers);
	                });
	            }
	        }
	    });

	    return jfWatchersController;
	})();

	function jfWatchers() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfWatchersController,
	        controllerAs: "jfWatchers",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_watchers.html"
	    };
	}

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfGeneral = jfGeneral;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var MESSAGES = _interopRequire(__webpack_require__(160));

	var jfGeneralController = (function () {
	    function jfGeneralController($state, $scope, ArtifactGeneralDao, JFrogNotifications, ArtifactLicensesDao, ChecksumsDao, ArtifactActionsDao, ArtifactoryFeatures, FilteredResourceDao, JFrogEventBus, JFrogModal, DependencyDeclarationDao, $compile, User, FooterDao, ArtifactoryStorage) {
	        _classCallCheck(this, jfGeneralController);

	        this.generalData = {
	            dependencyDeclaration: []
	        };
	        this.$state = $state;
	        this.$scope = $scope;
	        this.artifactLicensesDao = ArtifactLicensesDao;
	        this.DICTIONARY = DICTIONARY;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.TOOLTIP = TOOLTIP.artifacts.browse;
	        this.MESSAGES = MESSAGES.jf_general;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.artifactGeneralDao = ArtifactGeneralDao;
	        this.filteredResourceDao = FilteredResourceDao;
	        this.dependencyDeclarationDao = DependencyDeclarationDao;
	        this.modal = JFrogModal;
	        this.footerDao = FooterDao;
	        this.currentDeclaration = "Maven";
	        this.JFrogEventBus = JFrogEventBus;
	        this.features = ArtifactoryFeatures;
	        this.$compile = $compile;
	        this.userService = User;
	        this.SearchForArchiveLicense = "Search Archive License File";
	        this.ChecksumsDao = ChecksumsDao;
	        this.editorOptions = {
	            lineNumbers: true,
	            readOnly: "nocursor",
	            lineWrapping: true,
	            height: "auto",
	            mode: "links",
	            mimeType: "text/xml"
	        };
	        this.artifactoryStorage = ArtifactoryStorage;

	        this._getGeneralData();
	        this._registerEvents();
	        this._initModalScope();
	        this.isInVirtual();
	    }

	    _createClass(jfGeneralController, {
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.showArtifactsCount = false;
	                        _this.calculatingArtifactsCount = false;
	                        _this.finishedArtifactCount = false;
	                        _this.currentNode = node;
	                        _this._getGeneralData();
	                    }
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        _initModalScope: {
	            value: function _initModalScope() {
	                var _this = this;

	                this.generalScope = this.$scope.$new();
	                this.generalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	                this.generalScope.saveLicenses = function (licenses) {
	                    return _this.saveLicenses(licenses);
	                };
	                this.generalScope.modalTitle = "Add Artifactory License Property";
	            }
	        },
	        getGeneralTab: {
	            value: function getGeneralTab() {
	                return _.findWhere(this.currentNode.data.tabs, { name: "General" });
	            }
	        },
	        _getGeneralData: {
	            value: function _getGeneralData() {
	                var _this = this;

	                this.sha256Calculated = false;

	                var repoData = this.currentNode.data;
	                var generalTab = this.getGeneralTab();
	                if (generalTab && generalTab.info) {
	                    // If general data already exists on the node (for archive children)
	                    this.generalData = generalTab;
	                } else if (repoData.className === "TreeNode") {
	                    this.getGeneralTabPromise().then(function (response) {

	                        if (response.type && response.type === "virtualRemoteFile" && repoData && repoData.getRoot().repoType === "virtual") {
	                            response.info = _this.sortedInsertionToOject(response.info, response.originPath, "originPath", "repositoryPath");
	                        }

	                        if (response.info.repoType === "YUM") {
	                            response.info.repoType = "RPM";
	                        }
	                        _this.showArtifactsCount = _this.artifactsCountEnabled();
	                        if (response.info.externalUrl) {
	                            response.info = _this._moveObjectElement(response.info, "externalUrl", "repositoryPath");
	                        }
	                        _this.generalData = response;
	                        if (_this.generalData.dependencyDeclaration) {
	                            _this.selectDeclaration(_this.currentDeclaration);
	                        }
	                        if (_this.generalData.bintrayInfoEnabled) {
	                            _this.loadPackageDescription();
	                        }

	                        _this.trimVirtualAssociations();

	                        _this.userService.canAnnotate(_this.currentNode.data.repoKey, _this.currentNode.data.path).then(function (response) {
	                            _this.canAnnotate = response.data;
	                        });
	                    });
	                }
	            }
	        },
	        sortedInsertionToOject: {
	            value: function sortedInsertionToOject(unsortedObject, newFieldValue, newFieldName, fieldBefore) {
	                if (!newFieldValue) {
	                    return unsortedObject;
	                }
	                var sortedObject = {};
	                for (var field in unsortedObject) {
	                    sortedObject[field] = unsortedObject[field];
	                    if (field === fieldBefore) {
	                        sortedObject[newFieldName] = newFieldValue;
	                    }
	                }
	                return sortedObject;
	            }
	        },
	        shouldDisplayInfoEntry: {
	            value: function shouldDisplayInfoEntry(key) {
	                return key != "xrayIndexStatus" && key != "xrayIndexStatusLastUpdatedTimestamp" && key != "xrayAlertIgnored" && key != "xrayAlertLastUpdatedTimestamp" && key != "xrayAlertTopSeverity" && key != "licenses" && key != "filtered" && key != "smartRepo" && key != "showFilteredResourceCheckBox" && key != "artifactsCount" && key != "artifactsCount" && key != "xrayBlocked" && key != "xrayUnscanned" && key != "xrayEnabledForRepo" && key != "repoBlocksXrayUnscanned" && key != "currentlyDownloadable" && key != "originPath";
	            }
	        },
	        goToOriginPath: {
	            value: function goToOriginPath(value) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = value;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        getGeneralTabPromise: {
	            value: function getGeneralTabPromise() {
	                var newPath = this.currentNode.data.type === "folder" && this.currentNode.data.path.substr(-1) != "/" ? this.currentNode.data.path + "/" : this.currentNode.data.path;;
	                return this.artifactGeneralDao.fetch({
	                    type: this.currentNode.data.type,
	                    repoKey: this.currentNode.data.repoKey,
	                    path: newPath
	                }).$promise;
	            }
	        },
	        trimVirtualAssociations: {
	            value: function trimVirtualAssociations() {
	                var _this = this;

	                var LIMIT = 5;
	                var fields = ["virtualRepositories", "includedRepositories"];
	                fields.forEach(function (f) {
	                    if (_this.generalData[f] && _this.generalData[f].length > LIMIT) {
	                        (function () {
	                            var more = _this.generalData[f].length - (LIMIT - 1);
	                            _this.generalData["all" + _.capitalize(f)] = _.cloneDeep(_this.generalData[f]);
	                            _this.generalData[f] = _this.generalData["all" + _.capitalize(f)].slice(0, LIMIT - 1);
	                            var THIS = _this;
	                            _this.generalData[f].push({
	                                showAll: true,
	                                text: "(Show " + more + " more)",
	                                action: "show",
	                                toggle: function toggle() {
	                                    if (this.action === "show") {
	                                        this.action = "hide";
	                                        this.text = "(Show Less)";
	                                        THIS.generalData[f] = _.cloneDeep(THIS.generalData["all" + _.capitalize(f)]);
	                                        THIS.generalData[f].push(this);
	                                    } else {
	                                        this.action = "show";
	                                        this.text = "(Show " + more + " more)";
	                                        THIS.generalData[f] = THIS.generalData["all" + _.capitalize(f)].slice(0, LIMIT - 1);
	                                        THIS.generalData[f].push(this);
	                                    }
	                                }
	                            });
	                        })();
	                    }
	                });
	            }
	        },
	        calculateArtifactsCount: {
	            value: function calculateArtifactsCount() {
	                var _this = this;

	                this.calculatingArtifactsCount = true;
	                var _generalData$info = this.generalData.info;
	                var name = _generalData$info.name;
	                var repositoryPath = _generalData$info.repositoryPath;

	                this.artifactGeneralDao.artifactsCount({ name: name, repositoryPath: repositoryPath }).$promise.then(function (response) {
	                    _this.generalData.info.artifactsCount = response.artifactsCount;
	                })["finally"](function () {
	                    _this.calculatingArtifactsCount = false;
	                    _this.finishedArtifactCount = true;
	                });
	            }
	        },
	        calculateArtifactsCountAndSize: {
	            value: function calculateArtifactsCountAndSize() {
	                var _this = this;

	                this.calculatingArtifactsCount = true;
	                var _generalData$info = this.generalData.info;
	                var name = _generalData$info.name;
	                var repositoryPath = _generalData$info.repositoryPath;

	                this.artifactGeneralDao.artifactsCount({ name: name, repositoryPath: repositoryPath }).$promise.then(function (response) {
	                    _this.generalData.info.artifactsCount = "" + response.artifactsCount + " / " + response.artifactSize;
	                })["finally"](function () {
	                    _this.calculatingArtifactsCount = false;
	                    _this.finishedArtifactCount = true;
	                });
	            }
	        },
	        artifactsCountEnabled: {
	            value: function artifactsCountEnabled() {
	                return _.contains(["local", "cached"], this.currentNode.data.repoType);
	            }
	        },
	        onFilteredResourceCB: {
	            value: function onFilteredResourceCB() {
	                var payload = { repoKey: this.currentNode.data.repoKey, path: this.currentNode.data.path };
	                this.filteredResourceDao.setFiltered({ setFiltered: this.generalData.info.filtered }, payload).$promise.then(function (res) {});
	            }
	        },
	        fixChecksum: {
	            value: function fixChecksum() {
	                var _this = this;

	                this.ChecksumsDao.fix({}, { repoKey: this.currentNode.data.repoKey, path: this.currentNode.data.path }).$promise.then(function (data) {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        isDeclarationSelected: {
	            value: function isDeclarationSelected(item) {
	                return this.currentDeclaration == item;
	            }
	        },
	        selectDeclaration: {
	            value: function selectDeclaration(item) {
	                var self = this;
	                this.currentDeclaration = item;
	                this.dependencyDeclarationDao.get({
	                    buildtool: item.toLowerCase(),
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path

	                }).$promise.then(function (data) {
	                    if (data.dependencyData) {
	                        self.generalData.dependencyDeclaration.dependencyData = data.dependencyData;
	                    }
	                });
	            }
	        },
	        loadPackageDescription: {
	            value: function loadPackageDescription() {
	                var _this = this;

	                this.bintrayData = {};
	                this.artifactGeneralDao.bintray({ sha1: this.generalData.checksums.sha1Value }).$promise.then(function (data) {
	                    if (!data.name && !data.errorMessage) _this.generalData.bintrayInfoEnabled = false;else _this.bintrayData = data;
	                });
	            }
	        },
	        openAddLicenseModal: {

	            /**Licenses actions and display
	             * saving all default licenses on the generalScope for modal display
	             * **/

	            value: function openAddLicenseModal() {
	                this.modalInstance = this.modal.launchModal("add_license_modal", this.generalScope);
	            }
	        },
	        editLicenses: {
	            value: function editLicenses(scan) {
	                var _this = this;

	                this.artifactLicensesDao.getLicenses().$promise.then(function (licenses) {
	                    _this.generalScope.licenses = _.map(licenses, function (rec) {
	                        return rec.name;
	                    });
	                    if (!scan) {
	                        _this.generalScope.selectedLicenses = _.filter(_this.generalData.info.licenses, function (lic) {
	                            return lic.name !== "Not Found";
	                        });
	                    }
	                    _this.openAddLicenseModal();
	                });
	            }
	        },
	        saveLicenses: {
	            value: function saveLicenses(selectedLicenses) {
	                var _this = this;

	                this.artifactLicensesDao.setLicenses({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }, selectedLicenses).$promise.then(function (result) {
	                    _this._getGeneralData();
	                    _this.modalInstance.close();
	                });
	            }
	        },
	        deleteLicenses: {
	            value: function deleteLicenses() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to delete the license information attached to " + this.generalData.info.name + "?").then(function () {
	                    _this.saveLicenses([]);
	                });
	            }
	        },
	        scanForLicenses: {
	            value: function scanForLicenses() {
	                var _this = this;

	                this.artifactLicensesDao.scanArtifact({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    if (result.data.length > 0) {
	                        _this.generalScope.selectedLicenses = _.map(result.data, function (rec) {
	                            return rec.name;
	                        });
	                        _this.editLicenses(true);
	                    } else {
	                        _this.artifactoryNotifications.create({ info: "No licenses found in scan" });
	                    }
	                });
	            }
	        },
	        searchForArchiveFile: {
	            value: function searchForArchiveFile() {
	                var _this = this;

	                this.artifactLicensesDao.getArchiveLicenseFile({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.modal.launchCodeModal("License File", data.data);
	                }, function () {
	                    _this.SearchForArchiveLicense = "(No archive license file found)";
	                });
	            }
	        },
	        queryCodeCenter: {
	            value: function queryCodeCenter() {
	                var _this = this;

	                this.artifactLicensesDao.queryCodeCenter({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        getFullFilePath: {
	            value: function getFullFilePath() {
	                /*
	                 if (!window.location.origin) { // IE compatibility
	                 window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
	                 }
	                 return window.location.origin+this.currentNode.data.actualDownloadPath;
	                 */
	                return this.currentNode.data.actualDownloadPath;
	            }
	        },
	        getSha256: {
	            value: function getSha256() {
	                var _this = this;

	                if (this.features.isOss() || !this.canCalculateSha256()) {
	                    return;
	                }this.sha256Calculated = true;

	                this.artifactActionsDao.getSha256({ $spinner_domain: "sha256" }, {
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    // Instead of calling this._getGeneralData() and refreshing the entire tab , just replace the SHA-256
	                    _this.getGeneralTabPromise().then(function (response) {
	                        var generalTab = response;
	                        _this.generalData.checksums.sha2 = generalTab.checksums.sha2;
	                    });
	                });
	            }
	        },
	        canCalculateSha256: {
	            value: function canCalculateSha256() {
	                return this.canAnnotate && this.userService.currentUser.getCanDeploy() && !this.isInVirtual();
	            }
	        },
	        isInVirtual: {
	            value: function isInVirtual() {
	                return this.currentNode && this.currentNode.data && this.currentNode.data.getRoot().repoType === "virtual";
	            }
	        },
	        getChecksumKey: {
	            value: function getChecksumKey(keyval) {
	                return keyval.split(":")[0];
	            }
	        },
	        getChecksumVal: {
	            value: function getChecksumVal(keyval) {
	                var splitted = keyval.split(":");
	                splitted.shift();
	                return splitted.join(":");
	            }
	        },
	        isTrashcanEnabled: {
	            value: function isTrashcanEnabled() {
	                return !this.footerDao.getInfo().trashDisabled;
	            }
	        },
	        isTrashcan: {
	            value: function isTrashcan() {
	                return this.currentNode.data && this.currentNode.data.isTrashcan && this.currentNode.data.isTrashcan();
	            }
	        },
	        isInTrashcan: {
	            value: function isInTrashcan() {
	                return this.currentNode.data && this.currentNode.data.isInTrashcan && this.currentNode.data.isInTrashcan();
	            }
	        },
	        isDistRepo: {
	            value: function isDistRepo() {
	                return this.currentNode.data && this.currentNode.data.repoType === "distribution";
	            }
	        },
	        xrayAlertMessage: {
	            value: function xrayAlertMessage() {
	                var message = undefined;
	                if (this.generalData.type === "file") {
	                    //a file is currently downloadable if xray alert is not ignored or repo doesn't Blocks Xray unscanned
	                    if (this.generalData.info.currentlyDownloadable) {
	                        if (this.generalData.info.xrayBlocked) {
	                            message = this.MESSAGES.xray.xrayDetectedIssuesOnDownloadableArtifact;
	                        }
	                    } else {
	                        if (this.generalData.info.xrayUnscanned) {
	                            message = this.MESSAGES.xray.xrayDidntScanFileYet;
	                        }
	                        if (this.generalData.info.xrayBlocked) {
	                            message = this.MESSAGES.xray.xrayDetectedIssuesOnNonDownloadableArtifact;
	                        }
	                    }
	                }
	                return message;
	            }
	        },
	        _moveObjectElement: {
	            value: function _moveObjectElement(obj, currentKey, afterKey) {
	                var result = {};
	                var val = obj[currentKey];
	                delete obj[currentKey];
	                var next = -1;
	                var i = 0;
	                if (typeof afterKey == "undefined" || afterKey == null) afterKey = "";
	                $.each(obj, function (k, v) {
	                    if (afterKey == "" && i == 0 || next == 1) {
	                        result[currentKey] = val;
	                        next = 0;
	                    }
	                    if (k == afterKey) {
	                        next = 1;
	                    }
	                    result[k] = v;
	                    ++i;
	                });
	                if (next == 1) {
	                    result[currentKey] = val;
	                }
	                if (next !== -1) {
	                    return result;
	                } else {
	                    return obj;
	                }
	            }
	        },
	        isCurrentNodeAFolderInArchive: {
	            value: function isCurrentNodeAFolderInArchive() {
	                var isFolder = this.currentNode.data.folder;
	                var isInArchive = !!this.currentNode.data.archivePath;
	                return isFolder && isInArchive;
	            }
	        }
	    });

	    return jfGeneralController;
	})();

	function jfGeneral() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfGeneralController,
	        controllerAs: "jfGeneral",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_general.html"
	    };
	}

	//console.log(res);

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfProperties = jfProperties;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var KEYS = _interopRequire(__webpack_require__(278));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var jfPropertiesController = (function () {
	    function jfPropertiesController($q, $scope, JFrogGridFactory, ArtifactPropertyDao, JFrogEventBus, JFrogModal, PredefineDao, RepoPropertySetDao, JFrogNotifications, $timeout, User, GoogleAnalytics) {
	        var _this = this;

	        _classCallCheck(this, jfPropertiesController);

	        this.propertyGridOption = {};
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.user = User;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.artifactPropertyDao = ArtifactPropertyDao.getInstance();
	        this.predefineDao = PredefineDao.getInstance();
	        this.repoPropertySetDao = RepoPropertySetDao.getInstance();
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.propertyTypeKeys = KEYS.PROPERTY_TYPE;
	        this.propertyType = "Property";
	        this.propertiesOptions = [];
	        this.repoPropertyRecursive = { recursive: false };
	        this.TOOLTIP = TOOLTIP.artifacts.browse;
	        this._createGrid();
	        this._getPropertiesData();
	        this._createModalScope();

	        JFrogEventBus.registerOnScope($scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	            _this.currentNode = node;
	            _this.clearFields();
	            _this._getPropertiesData();
	        });

	        /**
	         *  config selectize inputs
	         *  **/
	        this.propertySetMultiValuesConfig = {
	            sortField: "text",
	            maxItems: null,
	            plugins: ["remove_button"]
	        };
	        this.propertySetSingleValueConfig = {
	            sortField: "text",
	            maxItems: 1
	        };
	        this.propertySetAnyValueConfig = {
	            sortField: "text",
	            maxItems: 1,
	            create: true,
	            createOnBlur: true,
	            persist: true
	        };
	    }

	    _createClass(jfPropertiesController, {
	        deleteSelectedProperties: {

	            /**
	             * delete Selected properties by batch
	             * **/

	            value: function deleteSelectedProperties(recursive) {
	                var _this = this;

	                var self = this;
	                var rowSelection = this.propertyGridOption.api.selection;
	                var selectedProperties = rowSelection.getSelectedRows();
	                var confirmMessage = "Are you sure you wish to delete " + selectedProperties.length;
	                confirmMessage += selectedProperties.length > 1 ? " properties?" : " property?";

	                this.modal.confirm(confirmMessage).then(function () {
	                    rowSelection.clearSelectedRows();
	                    var propertiesToDelete = selectedProperties.map(function (property) {
	                        return {
	                            name: property.name,
	                            path: self.currentNode.data.path,
	                            repoKey: self.currentNode.data.repoKey,
	                            recursive: recursive
	                        };
	                    });
	                    _this.artifactPropertyDao.deleteBatch({ properties: propertiesToDelete }).$promise.then(function () {
	                        _this._getPropertiesData();
	                    });
	                });
	            }
	        },
	        deleteSingleProperty: {

	            /**
	             * delete single proerty
	             * ***/

	            value: function deleteSingleProperty(row, recursive) {
	                var _this = this;

	                var json = { properties: [{
	                        name: row.name,
	                        path: this.currentNode.data.path,
	                        repoKey: this.currentNode.data.repoKey,
	                        recursive: recursive
	                    }]
	                };

	                this.modal.confirm("Are you sure you wish to delete this property?").then(function () {
	                    _this.artifactPropertyDao.deleteBatch(json).$promise.then(function () {
	                        _this._getPropertiesData();
	                    });
	                });
	            }
	        },
	        clearFields: {
	            value: function clearFields() {
	                if (this.repoPropertySetSelected) {
	                    if (this.repoPropertySetSelected.parent) {
	                        delete this.repoPropertySetSelected.parent;
	                    }
	                    if (this.repoPropertySetSelected.property) {
	                        delete this.repoPropertySetSelected.property;
	                    }
	                    if (this.repoPropertySetSelected.value) {
	                        delete this.repoPropertySetSelected.value;
	                    }
	                }
	            }
	        },
	        isSelected: {
	            value: function isSelected(propertyType) {
	                return this.propertyType == propertyType;
	            }
	        },
	        setProperty: {
	            value: function setProperty(propertyType) {
	                this.propertyType = propertyType;
	            }
	        },
	        addPropertySet: {

	            /**
	             * add Property Set to list
	             * **/

	            value: function addPropertySet() {
	                this._trackAddPropertyEvent("Add property set");
	                if (this.repoPropertySetSelected) {
	                    this._savePropertySetValues(this.repoPropertySetSelected);
	                }
	                this.repoPropertySetSelected = "";
	                this.propertyValuesOptions = [];
	            }
	        },
	        addProperty: {

	            /**
	             * add single property to list
	             * **/

	            value: function addProperty() {
	                this._trackAddPropertyEvent("Add property");
	                var objProperty = this._createNewRepoObject(this.repoPropertySelected.name);
	                delete objProperty.text;
	                delete objProperty.value;
	                this._savePropertyValues(objProperty);

	                this.repoPropertySelected.name = "";
	                this.repoPropertySelected.value = "";
	            }
	        },
	        _trackAddPropertyEvent: {
	            value: function _trackAddPropertyEvent(type) {
	                this.GoogleAnalytics.trackEvent("Artifacts", "Tab - Property", type, null, this.currentNode.data.repoPkgType, this.currentNode.data.repoType);
	            }
	        },
	        getPropertySetValues: {

	            /**
	             * pouplited values to input propertyValuesOptions
	             *
	             * **/

	            value: function getPropertySetValues() {
	                var _this = this;

	                if (this.repoPropertySetSelected) {
	                    this.predefineDao.get({
	                        name: this.repoPropertySetSelected.parent.name + "." + this.repoPropertySetSelected.property.name,
	                        path: this.currentNode.data.path,
	                        repoKey: this.currentNode.data.repoKey,
	                        recursive: this.recursive
	                    }).$promise.then(function (predefineValues) {

	                        _this._getPropertySetPreDefinedValues(predefineValues);
	                    });
	                }
	            }
	        },
	        isCurrentPropertyType: {
	            value: function isCurrentPropertyType(type) {
	                if (!this.repoPropertySetSelected && type === "ANY_VALUE") {
	                    return true;
	                } else if (this.repoPropertySetSelected) {
	                    if (!this.repoPropertySetSelected.propertyType && type === "ANY_VALUE") {
	                        return true;
	                    }
	                    return this.propertyTypeKeys[this.repoPropertySetSelected.propertyType] === this.propertyTypeKeys[type];
	                }
	            }
	        },
	        setModalData: {
	            value: function setModalData(selectedProperty, predefineValues) {
	                var _this = this;

	                this.modalScope.property = selectedProperty;
	                this.modalScope.property.predefineValues = predefineValues ? predefineValues.predefinedValues : null;
	                this.modalScope.property.selectedValues = [];
	                this.modalScope.property.modalTitle = "Add New '" + selectedProperty.property.name + "' Property";
	                this.modalScope.save = function (property) {
	                    return _this._savePropertySetValues(property);
	                };
	                this._propertyFormModal();
	            }
	        },
	        editSelectedProperty: {
	            value: function editSelectedProperty(row) {
	                var _this = this;

	                var selectedProperty = row;

	                this.artifactPropertyDao.get({
	                    name: selectedProperty.name,
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey

	                }).$promise.then(function (currentProperty) {
	                    //console.log('currentProperty=',currentProperty);
	                    _this.modalScope.property = currentProperty;
	                    _this.modalScope.property.selectedValues = _this.modalScope.property.propertyType !== "MULTI_SELECT" && _.isArray(_this.modalScope.property.selectedValues) ? _this.modalScope.property.selectedValues.join(";") : _this.modalScope.property.selectedValues;
	                    _this.modalScope.selectizeConfig = {
	                        create: currentProperty.propertyType === "ANY_VALUE",
	                        maxItems: 1
	                    };
	                    //                this.modalScope.property.multiValue = currentProperty.propertyType && currentProperty.propertyType === 'MULTI_SELECT';
	                    _this.modalScope.property.modalTitle = "Edit '" + selectedProperty.name + "' Property";
	                    _this.modalScope.property.name = selectedProperty.name;
	                    _this.modalScope.save = function (property) {
	                        return _this._updatePropertySetValues(property);
	                    };
	                    _this._propertyFormModal();
	                });
	            }
	        },
	        _createNewRepoObject: {

	            /**
	             * build defulat template proerty
	             * **/

	            value: function _createNewRepoObject(repoName) {
	                return {
	                    multiValue: false,
	                    property: { name: repoName },
	                    text: repoName,
	                    value: repoName
	                };
	            }
	        },
	        _getPropertiesData: {

	            /**
	             * popluted grid data and property Set list name
	             * **/

	            value: function _getPropertiesData() {
	                var _this = this;

	                this.user.canAnnotate(this.currentNode.data.repoKey, this.currentNode.data.path).then(function (response) {
	                    _this.canAnnotate = response.data;
	                });
	                this.artifactPropertyDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (properties) {

	                    _this.properties = properties.artifactProperties ? properties.artifactProperties.map(_this._formatToArray) : [];
	                    _this._createDisplayValues();
	                    _this.propertyGridOption.setGridData(_this.properties);

	                    _this._getPropertySetData();
	                });
	            }
	        },
	        _getPropertySetData: {
	            value: function _getPropertySetData() {
	                var _this = this;

	                this.repoPropertySetDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (_propertyOptionList) {
	                    var propertyOptionList = [];
	                    _propertyOptionList.forEach(function (propertyOption) {
	                        propertyOption.value = propertyOption.property.name;
	                        propertyOption.text = propertyOption.property.name;
	                        propertyOptionList.push(propertyOption);
	                    });
	                    _this.propertiesOptions = propertyOptionList;
	                });
	            }
	        },
	        _createModalScope: {
	            value: function _createModalScope() {
	                var _this = this;

	                this.modalScope = this.$scope.$new();
	                this.modalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.propertyGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteSingleProperty(row, false);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository");
	                    }
	                }, {
	                    icon: "icon icon-delete-versions",
	                    tooltip: "Delete Recursively",
	                    callback: function (row) {
	                        return _this.deleteSingleProperty(row, true);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository");
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProperties(false);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    }
	                }, {
	                    icon: "delete-recursive",
	                    name: "Delete Recursively",
	                    callback: function () {
	                        return _this.deleteSelectedProperties(true);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository") && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    }
	                }];
	            }
	        },
	        _propertyFormModal: {
	            value: function _propertyFormModal() {
	                this.modalInstance = this.modal.launchModal("property_modal", this.modalScope, this.modalScope.property.propertyType != "MULTI_SELECT" ? "sm" : "lg");
	            }
	        },
	        _savePropertyValues: {
	            value: function _savePropertyValues(property) {
	                var _this = this;

	                if (this.repoPropertySelected.value.indexOf(";") >= 0) {
	                    property.selectedValues = _.filter(this.repoPropertySelected.value.split(";"), function (val) {
	                        return !!val;
	                    });
	                } else {
	                    property.selectedValues = [];
	                    property.selectedValues.push(this.repoPropertySelected.value);
	                }
	                this.artifactPropertyDao.save({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                });
	            }
	        },
	        _savePropertySetValues: {
	            value: function _savePropertySetValues(property) {
	                var _this = this;

	                if (property.propertyType === "MULTI_SELECT") {
	                    this._addValuesToMulti(property, this.repoPropertySetSelected.value);
	                } else {
	                    property.selectedValues = this.repoPropertySetSelected.value;
	                }

	                if (!property.multiValue && !_.isArray(property.selectedValues)) {
	                    var selectedValuesToArray = angular.copy(property.selectedValues);
	                    property.selectedValues = [];
	                    property.selectedValues.push(selectedValuesToArray);
	                }

	                this.artifactPropertyDao.save({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                });
	            }
	        },
	        _addValuesToMulti: {
	            value: function _addValuesToMulti(property, addedValues) {
	                //console.log(property);
	                var theProperty = _.findWhere(this.properties, { name: property.parent.name + "." + property.property.name });
	                if (theProperty) {
	                    property.selectedValues = theProperty.value.concat(addedValues);
	                } else {
	                    property.selectedValues = addedValues;
	                }
	            }
	        },
	        _updatePropertySetValues: {
	            value: function _updatePropertySetValues(property) {
	                var _this = this;

	                if (property.selectedValues.indexOf(";") >= 0) property.selectedValues = _.filter(property.selectedValues.split(";"), function (val) {
	                    return !!val;
	                });
	                if (!property.multiValue && !_.isArray(property.selectedValues)) {
	                    var selectedValuesToArray = angular.copy(property.selectedValues);
	                    property.selectedValues = [];
	                    property.selectedValues.push(selectedValuesToArray);
	                }
	                //console.log(property);
	                this.artifactPropertyDao.update({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                    _this.modalInstance.close();
	                });
	            }
	        },
	        _getPropertySetPreDefinedValues: {
	            value: function _getPropertySetPreDefinedValues(predefineValues) {
	                var _this = this;

	                this.propertyValuesOptions = [];
	                predefineValues.predefinedValues.forEach(function (preValue) {
	                    _this.propertyValuesOptions.push(_this._createNewRepoObject(preValue));
	                    _this.repoPropertySetSelected.value = [];
	                });
	                this.repoPropertySetSelected.value = predefineValues.selectedValues;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {

	                var cellTemplate = "<div class=\"grid-items-container gridcell-content-text\"\n                                 id=\"{{row.uid}}\">\n                                <div class=\"item\" \n                                     ng-if=\"row.entity.value.length>1\" \n                                     ng-repeat=\"col in row.entity.value track by $index\">{{col}}\n                                </div>\n                                <a class=\"gridcell-showall\" \n                                   ng-if=\"row.entity.value.length>1 && grid.options.htmlIsOverflowing(row.uid) && !grid.options.lastHtmlElementOverflowing(row.uid)\" \n                                   href \n                                   ng-click=\"grid.options.showAll(row.entity.value,row.entity.name,col)\"> (See All)</a>\n                                <a class=\"gridcell-showall\" \n                                   ng-if=\"row.entity.value.length>1 && grid.options.lastHtmlElementOverflowing(row.uid)\" \n                                   href \n                                   ng-click=\"grid.options.showAll(row.entity.value,row.entity.name,col)\"> (See List)</a>\n                                <div class=\"ui-grid-cell-contents\" ng-if=\"row.entity.value.length==1\">\n                                    <span ng-if=\"!row.entity.displayValues[0]\">{{row.entity.value[0]}}</span>\n                                    <span ng-if=\"row.entity.displayValues[0]\" ng-bind-html=\"row.entity.displayValues[0]\"></span>\n                                </div>\n                            </div>";

	                var keyCellTemplate = "<div ng-if=\"!grid.appScope.jfProperties.canAnnotate\" class=\"ui-grid-cell-contents\">{{row.entity.name}}</div>" + "<div ng-if=\"grid.appScope.jfProperties.canAnnotate\" class=\"ui-grid-cell-contents\"><a href=\"\" ng-click=\"grid.appScope.jfProperties.editSelectedProperty(row.entity)\">{{row.entity.name}}</a></div>";

	                return [{
	                    name: "Property",
	                    displayName: "Property",
	                    field: "name",
	                    cellTemplate: keyCellTemplate
	                }, {
	                    name: "Value(s)",
	                    displayName: "Value(s)",
	                    field: "value",
	                    cellTemplate: cellTemplate
	                }];
	            }
	        },
	        _formatToArray: {
	            value: function _formatToArray(list) {
	                return { name: list.name, value: _.trimRight(list.value.toString(), ";").split(";") };
	            }
	        },
	        _createDisplayValues: {
	            value: function _createDisplayValues() {
	                var urlRegex = /^https?:\/\/[a-zA-Z]+(\.)?(:[0-9]+)?.+?(?=\s|$|"|'|>|<)/;
	                _.map(this.properties, function (prop) {
	                    var displayValues = [];
	                    for (var i = 0; i < prop.value.length; i++) {
	                        var val = prop.value[i];
	                        if (val.match(urlRegex)) {
	                            displayValues[i] = "<a href=\"" + val + "\" target=\"_blank\">" + val + "</a>";
	                        } else displayValues[i] = undefined;
	                    }
	                    prop.displayValues = displayValues;
	                });
	            }
	        },
	        isInVirtual: {
	            value: function isInVirtual() {
	                return this.currentNode && this.currentNode.data && this.currentNode.data.getRoot().repoType === "virtual";
	            }
	        }
	    });

	    return jfPropertiesController;
	})();

	function jfProperties() {
	    return {
	        restrict: "EA",
	        controller: jfPropertiesController,
	        scope: {
	            currentNode: "="
	        },
	        controllerAs: "jfProperties",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_properties.html"
	    };
	}

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfViewSource = jfViewSource;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfViewSourceController = (function () {
	    function jfViewSourceController($scope, ArtifactViewSourceDao, JFrogEventBus) {
	        _classCallCheck(this, jfViewSourceController);

	        this.sourceData = "";
	        this.artifactViewSourceDao = ArtifactViewSourceDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this.editorOptions = {
	            lineNumbers: true,
	            readOnly: "nocursor",
	            lineWrapping: true,
	            viewportMargin: Infinity
	        };
	        this.loadSourceData();
	        this._registerEvents();
	    }

	    _createClass(jfViewSourceController, {
	        loadSourceData: {
	            value: function loadSourceData() {
	                var _this = this;

	                if (this.currentNode.data.mimeType) {
	                    this.editorOptions.mode = this.currentNode.data.mimeType;
	                }
	                // get source path from general info
	                var sourcePath = _.findWhere(this.currentNode.data.tabs, { name: "General" }).info.path;
	                // fetch source from server
	                this.artifactViewSourceDao.fetch({
	                    archivePath: this.currentNode.data.archivePath,
	                    repoKey: this.currentNode.data.repoKey,
	                    sourcePath: sourcePath
	                }).$promise.then(function (result) {
	                    _this.sourceData = result.source;
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this.loadSourceData();
	                    }
	                });
	            }
	        }
	    });

	    return jfViewSourceController;
	})();

	function jfViewSource() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfViewSourceController,
	        controllerAs: "jfViewSource",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_view_source.html"
	    };
	}

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfPomView = jfPomView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfPomViewController = (function () {
	    function jfPomViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfPomViewController);

	        this.artifactPomViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this._initPomView();
	    }

	    _createClass(jfPomViewController, {
	        _initPomView: {
	            value: function _initPomView() {
	                this._registerEvents();
	                this._getPomViewData();
	            }
	        },
	        _getPomViewData: {
	            value: function _getPomViewData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactPomViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.pomViewData = data;
	                    _this.pomViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getPomViewData();
	                    }
	                });
	            }
	        }
	    });

	    return jfPomViewController;
	})();

	function jfPomView() {
	    return {
	        restrict: "EA",
	        controller: jfPomViewController,
	        controllerAs: "jfPomView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_pom_view.html"
	    };
	}

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfXmlView = jfXmlView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfXmlViewController = (function () {
	    function jfXmlViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfXmlViewController);

	        this.artifactXmlViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this._initXmlView();
	    }

	    _createClass(jfXmlViewController, {
	        _initXmlView: {
	            value: function _initXmlView() {
	                this._registerEvents();
	                this._getXmlViewData();
	            }
	        },
	        _getXmlViewData: {
	            value: function _getXmlViewData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactXmlViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.xmlViewData = data;
	                    _this.xmlViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getXmlViewData();
	                    }
	                });
	            }
	        }
	    });

	    return jfXmlViewController;
	})();

	function jfXmlView() {
	    return {
	        restrict: "EA",
	        controller: jfXmlViewController,
	        controllerAs: "jfXmlView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_xml_view.html"
	    };
	}

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfIvyView = jfIvyView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfIvyViewController = (function () {
	    function jfIvyViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfIvyViewController);

	        this.artifactIvyViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this._initIvyView();
	    }

	    _createClass(jfIvyViewController, {
	        _initIvyView: {
	            value: function _initIvyView() {
	                this._registerEvents();
	                this._getIvyViewData();
	            }
	        },
	        _getIvyViewData: {
	            value: function _getIvyViewData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactIvyViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _this.ivyViewData = data;
	                    _this.ivyViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this._getIvyViewData();
	                    }
	                });
	            }
	        }
	    });

	    return jfIvyViewController;
	})();

	function jfIvyView() {
	    return {
	        restrict: "EA",
	        controller: jfIvyViewController,
	        controllerAs: "jfIvyView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_ivy_view.html"
	    };
	}

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfNuget = jfNuget;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfNugetController = (function () {
	    function jfNugetController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfNugetController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.nuget;
	        this.gridDependenciesOptions = {};
	        this.gridFrameworkAssembliesOptions = {};
	        this.nugetData = {};
	        this.$scope = $scope;
	        this._initNuget();
	    }

	    _createClass(jfNugetController, {
	        _initNuget: {
	            value: function _initNuget() {
	                this._registerEvents();
	                this.getNugetData();
	            }
	        },
	        getNugetData: {
	            value: function getNugetData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "nuget",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.nugetData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.nugetData.dependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.nugetData.dependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.nugetData.dependencies);
	                    }
	                }
	                if (this.nugetData.frameworkAssemblies) {
	                    if (!Object.keys(this.gridFrameworkAssembliesOptions).length) {
	                        this.gridFrameworkAssembliesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns("frameworkAssemblies")).setRowTemplate("default").setGridData(this.nugetData.frameworkAssemblies);
	                    } else {
	                        this.gridFrameworkAssembliesOptions.setGridData(this.nugetData.frameworkAssemblies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Id",
	                        displayName: "Id",
	                        field: "id"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }, {
	                        name: "Target Framework",
	                        displayName: "Target Framework",
	                        field: "targetFramework"
	                    }];
	                }
	                if (gridType === "frameworkAssemblies") {
	                    return [{
	                        name: "Assembly Name",
	                        displayName: "Assembly Name",
	                        field: "assemblyName"
	                    }, {
	                        name: "Target Framework",
	                        displayName: "Target Framework",
	                        field: "targetFramework"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getNugetData();
	                    }
	                });
	            }
	        }
	    });

	    return jfNugetController;
	})();

	function jfNuget() {
	    return {
	        restrict: "EA",
	        controller: jfNugetController,
	        controllerAs: "jfNuget",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_nuget.html"
	    };
	}

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfComposer = jfComposer;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfComposerController = (function () {
	    function jfComposerController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfComposerController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.composer;
	        this.gridDependenciesOptions = {};
	        this.composerData = {};
	        this.$scope = $scope;
	        this._initComposer();
	    }

	    _createClass(jfComposerController, {
	        _initComposer: {
	            value: function _initComposer() {
	                this._registerEvents();
	                this.getComposerData();
	            }
	        },
	        getComposerData: {
	            value: function getComposerData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "composer",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.composerData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.composerData.composerDependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.composerData.composerDependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.composerData.composerDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getComposerData();
	                    }
	                });
	            }
	        }
	    });

	    return jfComposerController;
	})();

	function jfComposer() {
	    return {
	        restrict: "EA",
	        controller: jfComposerController,
	        controllerAs: "jfComposer",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_composer.html"
	    };
	}

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfPyPi = jfPyPi;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfPyPiController = (function () {
	    function jfPyPiController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfPyPiController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.pyPi;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.pyPiData = {};
	        this.$scope = $scope;
	        this.categoriesGridOptions = {};
	        this._initPyPi();

	        this._createGrid();
	    }

	    _createClass(jfPyPiController, {
	        _initPyPi: {
	            value: function _initPyPi() {
	                this._registerEvents();
	                this.getPyPiData();
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.categoriesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getCategoriesColumns()).setRowTemplate("default");
	            }
	        },
	        _getCategoriesColumns: {
	            value: function _getCategoriesColumns() {
	                return [{
	                    name: "Category",
	                    displayName: "Category",
	                    field: "category"
	                    //                cellTemplate: '<div class="ui-grid-cell-contents">{{row.entity}}</div>'
	                }];
	            }
	        },
	        isValidUrl: {
	            value: function isValidUrl(str) {
	                var regex = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/i;
	                return regex.test(str);
	            }
	        },
	        getPyPiData: {
	            value: function getPyPiData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "pypi",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.pyPiData = data;
	                    _this.categoriesGridOptions.setGridData(data.categories.map(function (cat) {
	                        return { category: cat };
	                    }));
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (self.currentNode != node) {
	                        self.currentNode = node;
	                        self.getPyPiData();
	                    }
	                });
	            }
	        }
	    });

	    return jfPyPiController;
	})();

	function jfPyPi() {
	    return {
	        restrict: "EA",
	        controller: jfPyPiController,
	        controllerAs: "jfPyPi",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_pypi.html"
	    };
	}

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfPuppet = jfPuppet;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfPuppetController = (function () {
	    function jfPuppetController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfPuppetController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.puppet;
	        this.puppetData = {};
	        this.puppetKeywordsGridOptions = {};
	        this.puppetDependenciesGridOptions = {};
	        this.$scope = $scope;

	        this._initPuppetInfo();
	    }

	    _createClass(jfPuppetController, {
	        _initPuppetInfo: {
	            value: function _initPuppetInfo() {
	                this._getPuppetInfoData();
	                this._registerEvents();
	            }
	        },
	        _getPuppetInfoData: {
	            value: function _getPuppetInfoData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "puppet",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.puppetData = data;
	                    _this._createGrids();
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                if (this.puppetData.puppetKeywords) {
	                    if (!Object.keys(this.puppetKeywordsGridOptions).length) {
	                        this.puppetKeywordsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getKeywordsColumns()).setGridData(this.puppetData.puppetKeywords);
	                    } else {
	                        this.puppetKeywordsGridOptions.setGridData(this.puppetData.puppetKeywords);
	                    }
	                }
	                if (this.puppetData.puppetDependencies) {
	                    if (!Object.keys(this.puppetDependenciesGridOptions).length) {
	                        this.puppetDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getDependenciesColumns()).setGridData(this.puppetData.puppetDependencies);
	                    } else {
	                        this.puppetDependenciesGridOptions.setGridData(this.puppetData.puppetDependencies);
	                    }
	                }
	            }
	        },
	        _getKeywordsColumns: {
	            value: function _getKeywordsColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }];
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getPuppetInfoData();
	                    }
	                });
	            }
	        }
	    });

	    return jfPuppetController;
	})();

	function jfPuppet() {
	    return {
	        restrict: "EA",
	        controller: jfPuppetController,
	        controllerAs: "jfPuppet",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_puppet.html"
	    };
	}

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfBower = jfBower;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfBowerController = (function () {
	    function jfBowerController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfBowerController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.bower;
	        this.gridDependenciesOptions = {};
	        this.bowerData = {};
	        this.$scope = $scope;
	        this._initBower();
	    }

	    _createClass(jfBowerController, {
	        _initBower: {
	            value: function _initBower() {
	                this._registerEvents();
	                this.getBowerData();
	            }
	        },
	        getBowerData: {
	            value: function getBowerData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "bower",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.bowerData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.bowerData.bowerDependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.bowerData.bowerDependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.bowerData.bowerDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getBowerData();
	                    }
	                });
	            }
	        }
	    });

	    return jfBowerController;
	})();

	function jfBower() {
	    return {
	        restrict: "EA",
	        controller: jfBowerController,
	        controllerAs: "jfBower",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_bower.html"
	    };
	}

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfDocker = jfDocker;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfDockerController = (function () {
	    function jfDockerController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfDockerController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.docker;
	        this.dockerData = {};
	        this.$scope = $scope;
	        this._initDocker();
	    }

	    _createClass(jfDockerController, {
	        _initDocker: {
	            value: function _initDocker() {
	                this._registerEvents();
	                this.getDockerData();
	            }
	        },
	        gotoPath: {
	            value: function gotoPath(key) {
	                var repoKey = this.currentNode.data.repoKey;
	                var pathField = key === "imageId" ? "imageIdPath" : key === "parent" ? "parentIdPath" : undefined;
	                if (pathField) {
	                    this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, repoKey + "/" + this.dockerData.dockerInfo[pathField]);
	                }
	            }
	        },
	        getDockerData: {
	            value: function getDockerData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "docker",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path + "/json.json"
	                }).$promise.then(function (data) {
	                    _this.dockerData = data;
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getDockerData();
	                    }
	                });
	            }
	        }
	    });

	    return jfDockerController;
	})();

	function jfDocker() {
	    return {
	        restrict: "EA",
	        controller: jfDockerController,
	        controllerAs: "jfDocker",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker.html"
	    };
	}

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfDockerAncestry = jfDockerAncestry;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfDockerAncestryController = (function () {
	    function jfDockerAncestryController($scope, ArtifactViewsDao, JFrogEventBus, $q) {
	        _classCallCheck(this, jfDockerAncestryController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.dockerAncestry;
	        this.dockerAncestryData = {};
	        this.$scope = $scope;
	        this.$q = $q;
	        this._initDockerAncestry();
	    }

	    _createClass(jfDockerAncestryController, {
	        _initDockerAncestry: {
	            value: function _initDockerAncestry() {
	                this._registerEvents();
	                this.getDockerAncestryData();
	            }
	        },
	        getDockerAncestryData: {
	            value: function getDockerAncestryData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this._findAncestryJsonNode().then(function (node) {
	                    return _this.artifactViewsDao.fetch({
	                        view: "dockerancestry",
	                        repoKey: node.repoKey,
	                        path: node.path
	                    }).$promise;
	                }).then(function (data) {
	                    _this.dockerAncestryData = _this._linkedListToArray(data.dockerLinkedImage);
	                });
	            }
	        },
	        _findAncestryJsonNode: {
	            value: function _findAncestryJsonNode() {
	                var _this = this;

	                return this.currentNode.data.getChildren().then(function (data) {
	                    for (var i = 0; i < data.length; i++) {
	                        if (data[i].text === "ancestry.json") {
	                            return data[i];
	                        }
	                    }
	                    return _this.$q.reject();
	                });
	            }
	        },
	        gotoPath: {
	            value: function gotoPath(index) {
	                var repoKey = this.currentNode.data.repoKey;
	                var fullpath = repoKey + "/" + this.dockerAncestryData[index].path;

	                this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, fullpath);
	            }
	        },
	        _linkedListToArray: {
	            value: function _linkedListToArray(linkedData) {
	                var arr = [];
	                var curr = linkedData;
	                var indent = 1;
	                while (curr) {
	                    var rec = { id: curr.id,
	                        size: curr.size,
	                        path: curr.path,
	                        indent: "|" + "__".repeat(indent) };
	                    arr.push(rec);
	                    curr = curr.child;
	                    indent++;
	                }
	                return arr;
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getDockerAncestryData();
	                    }
	                });
	            }
	        }
	    });

	    return jfDockerAncestryController;
	})();

	function jfDockerAncestry() {
	    return {
	        restrict: "EA",
	        controller: jfDockerAncestryController,
	        controllerAs: "jfDockerAncestry",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker_ancestry.html"
	    };
	}

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfDockerV2 = jfDockerV2;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfDockerV2Controller = (function () {
	    function jfDockerV2Controller($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfDockerV2Controller);

	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.dockerV2;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.dockerV2Data = {};
	        this.labelGridOptions = {};

	        this._getDockerV2Data();
	        this._registerEvents();
	    }

	    _createClass(jfDockerV2Controller, {
	        _getDockerV2Data: {
	            value: function _getDockerV2Data() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "dockerv2",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.dockerV2Data = data;
	                    _this._createGrid();
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.dockerV2Data.tagInfo.labels) {
	                    if (!Object.keys(this.labelGridOptions).length) {
	                        this.labelGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.dockerV2Data.tagInfo.labels);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "key",
	                    displayName: "Key",
	                    field: "key"
	                }, {
	                    name: "value",
	                    displayName: "Value",
	                    field: "value"
	                }];
	            }
	        },
	        isNotEmptyValue: {
	            value: function isNotEmptyValue(value) {
	                return value && (!_.isArray(value) || value.length > 0);
	            }
	        },
	        formatValue: {
	            value: function formatValue(value) {
	                if (_.isArray(value)) {
	                    return value.join(", ");
	                } else {
	                    return value;
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getDockerV2Data();
	                });
	            }
	        },
	        scrollToLabels: {
	            value: function scrollToLabels() {
	                document.getElementById("labels").scrollIntoView();
	            }
	        }
	    });

	    return jfDockerV2Controller;
	})();

	function jfDockerV2() {
	    return {
	        restrict: "EA",
	        controller: jfDockerV2Controller,
	        controllerAs: "jfDockerV2",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker_v2.html"
	    };
	}

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfRubyGems = jfRubyGems;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfRubyGemsController = (function () {
	    function jfRubyGemsController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfRubyGemsController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.rubyGems;
	        this.gemsRubyGridOptions = {};
	        this.$scope = $scope;
	        this._initRubyGems();
	    }

	    _createClass(jfRubyGemsController, {
	        getRepoPath: {
	            value: function getRepoPath() {
	                return this.currentNode.data.repoKey + "/" + this.currentNode.data.path;
	            }
	        },
	        _initRubyGems: {
	            value: function _initRubyGems() {
	                this._createGrid();
	                this._registerEvents();
	                this._getRubyGemsData();
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type"
	                }];
	            }
	        },
	        _getRubyGemsData: {
	            value: function _getRubyGemsData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "gems",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _this.gemsRubyData = data;
	                    _this.gemsRubyGridOptions.setGridData(_this.gemsRubyData.gemsDependencies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (!this.gridFrameworkAssembliesOptions || !Object.keys(this.gridFrameworkAssembliesOptions).length) {
	                    this.gemsRubyGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default");
	                } else {
	                    this._getRubyGemsData();
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getRubyGemsData();
	                    }
	                });
	            }
	        }
	    });

	    return jfRubyGemsController;
	})();

	function jfRubyGems() {
	    return {
	        restrict: "EA",
	        controller: jfRubyGemsController,
	        controllerAs: "jfRubyGems",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_ruby_gems.html"
	    };
	}

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfNpmInfo = jfNpmInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfNpmInfoController = (function () {
	    function jfNpmInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfNpmInfoController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.npm;
	        this.npmData = {};
	        this.npmDependenciesGridOptions = {};
	        this.$scope = $scope;

	        this._initNpmInfo();
	    }

	    _createClass(jfNpmInfoController, {
	        _initNpmInfo: {
	            value: function _initNpmInfo() {
	                this._getNpmInfoData();
	                this._registerEvents();
	            }
	        },
	        _getNpmInfoData: {
	            value: function _getNpmInfoData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "npm",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.npmData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.npmData.npmDependencies) {
	                    if (!Object.keys(this.npmDependenciesGridOptions).length) {
	                        this.npmDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.npmData.npmDependencies);
	                    } else {
	                        this.npmDependenciesGridOptions.setGridData(this.npmData.npmDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getNpmInfoData();
	                    }
	                });
	            }
	        }
	    });

	    return jfNpmInfoController;
	})();

	function jfNpmInfo() {
	    return {
	        restrict: "EA",
	        controller: jfNpmInfoController,
	        controllerAs: "jfNpmInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_npm_info.html"
	    };
	}

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfRpm = jfRpm;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfRpmController = (function () {
	    function jfRpmController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfRpmController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.rpm;
	        this.gridProvideOptions = {};
	        this.gridRequireOptions = {};
	        this.gridObsoleteOptions = {};
	        this.gridConflictOptions = {};
	        this.rpmData = {};
	        this.$scope = $scope;
	        this._initRpm();
	    }

	    _createClass(jfRpmController, {
	        _initRpm: {
	            value: function _initRpm() {
	                this._registerEvents();
	                this.getRpmData();
	            }
	        },
	        getRpmData: {
	            value: function getRpmData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "rpm",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.rpmData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.rpmData.provide) {
	                    if (!Object.keys(this.gridProvideOptions).length) {
	                        this.gridProvideOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("provide")).setGridData(this.rpmData.provide);
	                    } else {
	                        this.gridProvideOptions.setGridData(this.rpmData.provide);
	                    }
	                }
	                if (this.rpmData.require) {
	                    if (!Object.keys(this.gridRequireOptions).length) {
	                        this.gridRequireOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.require);
	                    } else {
	                        this.gridRequireOptions.setGridData(this.rpmData.require);
	                    }
	                }
	                if (this.rpmData.obsolete) {
	                    if (!Object.keys(this.gridObsoleteOptions).length) {
	                        this.gridObsoleteOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.obsolete);
	                    } else {
	                        this.gridObsoleteOptions.setGridData(this.rpmData.obsolete);
	                    }
	                }

	                if (this.rpmData.conflict) {
	                    if (!Object.keys(this.gridConflictOptions).length) {
	                        this.gridConflictOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.conflict);
	                    } else {
	                        this.gridConflictOptions.setGridData(this.rpmData.conflict);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    width: "25%"
	                }, {
	                    name: "Flags",
	                    displayName: "Flags",
	                    field: "flags",
	                    width: "15%"
	                }, {
	                    name: "Epoch",
	                    displayName: "Epoch",
	                    field: "epoch",
	                    width: "15%"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version",
	                    width: "15%"
	                }, {
	                    name: "Release",
	                    displayName: "Release",
	                    field: "release",
	                    width: "15%"
	                }, {
	                    name: "Pre",
	                    displayName: "Pre",
	                    field: "pre",
	                    width: "15%"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getRpmData();
	                    }
	                });
	            }
	        }
	    });

	    return jfRpmController;
	})();

	function jfRpm() {
	    return {
	        restrict: "EA",
	        controller: jfRpmController,
	        controllerAs: "jfRpm",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_rpm_info.html"
	    };
	}

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfCocoapods = jfCocoapods;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfCocoapodsController = (function () {
	    function jfCocoapodsController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfCocoapodsController);

	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.cocoapods;
	        this.gridDependenciesOptions = {};
	        this.cocoapodsData = {};
	        this.$scope = $scope;
	        this._initCocoapods();
	    }

	    _createClass(jfCocoapodsController, {
	        _initCocoapods: {
	            value: function _initCocoapods() {
	                this._registerEvents();
	                this.getCocoapodsData();
	            }
	        },
	        getCocoapodsData: {
	            value: function getCocoapodsData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "cocoapods",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.cocoapodsData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.cocoapodsData.dependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cocoapodsData.dependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.cocoapodsData.dependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this.getCocoapodsData();
	                    }
	                });
	            }
	        }
	    });

	    return jfCocoapodsController;
	})();

	function jfCocoapods() {
	    return {
	        restrict: "EA",
	        controller: jfCocoapodsController,
	        controllerAs: "jfCocoapods",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_cocoapods.html"
	    };
	}

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfConan = jfConan;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfConanController = (function () {
	    function jfConanController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfConanController);

	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.conan;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.conanData = {};
	        this.labelGridOptions = {};

	        this._getConanData();
	        this._registerEvents();
	    }

	    _createClass(jfConanController, {
	        _getConanData: {
	            value: function _getConanData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "conan",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.conanData = data;
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getConanData();
	                });
	            }
	        }
	    });

	    return jfConanController;
	})();

	function jfConan() {
	    return {
	        restrict: "EA",
	        controller: jfConanController,
	        controllerAs: "jfConan",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_conan.html"
	    };
	}

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfConanPackage = jfConanPackage;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfConanPackageController = (function () {
	    function jfConanPackageController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfConanPackageController);

	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.conan;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.conanPackageData = {};
	        this.labelGridOptions = {};

	        this._getConanPackageData();
	        this._registerEvents();
	    }

	    _createClass(jfConanPackageController, {
	        _getConanPackageData: {
	            value: function _getConanPackageData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "conan_package",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.conanPackageData = data;
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getConanPackageData();
	                });
	            }
	        },
	        isNonEmptyObject: {
	            value: function isNonEmptyObject(val) {
	                return val && Object.keys(val).length > 0;
	            }
	        },
	        hasSettings: {
	            value: function hasSettings() {
	                if (this.isNonEmptyObject(this.conanPackageData.settings)) {
	                    return true;
	                }
	                var knownSettings = this.knownSettings();
	                for (var i in knownSettings) {
	                    if (this.conanPackageData[knownSettings[i]]) {
	                        return true;
	                    }
	                }
	                return false;
	            }
	        },
	        knownSettings: {
	            value: function knownSettings() {
	                return ["os", "arch", "buildType", "compiler", "compilerVersion", "compilerRuntime"];
	            }
	        }
	    });

	    return jfConanPackageController;
	})();

	function jfConanPackage() {
	    return {
	        restrict: "EA",
	        controller: jfConanPackageController,
	        controllerAs: "jfConanPackage",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_conan_package.html"
	    };
	}

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfStashInfo = jfStashInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var jfStashInfoController = (function () {
	    function jfStashInfoController($state, BrowseFilesDao, StashResultsDao, JFrogEventBus) {
	        _classCallCheck(this, jfStashInfoController);

	        this.$state = $state;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.stashResultsDao = StashResultsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.TOOLTIP = TOOLTIP.admin.import_export.stash;

	        this.exportOptions = {};

	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	    }

	    _createClass(jfStashInfoController, {
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        "export": {
	            value: function _export() {
	                var payload = {
	                    path: this.exportOptions.path,
	                    excludeMetadata: this.exportOptions.excludeMetadata || false,
	                    m2: this.exportOptions.createM2CompatibleExport || false,
	                    createArchive: this.exportOptions.createArchive || false,
	                    verbose: this.exportOptions.verbose || false
	                };

	                this.stashResultsDao["export"]({ name: "stash" }, payload).$promise.then(function (response) {});
	            }
	        },
	        gotoSearch: {
	            value: function gotoSearch() {
	                this.JFrogEventBus.dispatch(this.EVENTS.SEARCH_URL_CHANGED, { searchType: "quick" });
	            }
	        }
	    });

	    return jfStashInfoController;
	})();

	function jfStashInfo() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "=",
	            allowExport: "="
	        },
	        controller: jfStashInfoController,
	        controllerAs: "jfStashInfo",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_stash_info.html"
	    };
	}

	//            console.log(response);

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfDebianInfo = jfDebianInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfDebianInfoController = (function () {
	    function jfDebianInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfDebianInfoController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.debian;
	        this.debianData = {};
	        this.debianDependenciesGridOptions = {};
	        this.$scope = $scope;

	        this.initDebianInfo();
	    }

	    _createClass(jfDebianInfoController, {
	        initDebianInfo: {
	            value: function initDebianInfo() {
	                this._registerEvents();
	                this._getDebianInfoData();
	            }
	        },
	        _getDebianInfoData: {
	            value: function _getDebianInfoData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "debian",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.debianData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;

	                this.formattedDependencies = [];
	                _.forEach(this.debianData.debianDependencies, function (item) {
	                    _this.formattedDependencies.push({
	                        name: item
	                    });
	                });

	                if (this.debianData.debianDependencies) {
	                    this.debianDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.formattedDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getDebianInfoData();
	                    }
	                });
	            }
	        }
	    });

	    return jfDebianInfoController;
	})();

	function jfDebianInfo() {
	    return {
	        restrict: "EA",
	        controller: jfDebianInfoController,
	        controllerAs: "jfDebianInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_debian_info.html"
	    };
	}

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfOpkgInfo = jfOpkgInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfOpkgInfoController = (function () {
	    function jfOpkgInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfOpkgInfoController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.opkg;
	        this.opkgData = {};
	        this.opkgDependenciesGridOptions = {};
	        this.$scope = $scope;

	        this.initOpkgInfo();
	    }

	    _createClass(jfOpkgInfoController, {
	        initOpkgInfo: {
	            value: function initOpkgInfo() {
	                this._registerEvents();
	                this._getOpkgInfoData();
	            }
	        },
	        _getOpkgInfoData: {
	            value: function _getOpkgInfoData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "opkg",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.opkgData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;

	                this.formattedDependencies = [];
	                _.forEach(this.opkgData.debianDependencies, function (item) {
	                    _this.formattedDependencies.push({
	                        name: item
	                    });
	                });

	                if (this.opkgData.debianDependencies) {
	                    this.opkgDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.formattedDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getOpkgInfoData();
	                    }
	                });
	            }
	        }
	    });

	    return jfOpkgInfoController;
	})();

	function jfOpkgInfo() {
	    return {
	        restrict: "EA",
	        controller: jfOpkgInfoController,
	        controllerAs: "jfOpkgInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_opkg_info.html"
	    };
	}

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfChefInfo = jfChefInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(291));

	var jfChefInfoController = (function () {
	    function jfChefInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfChefInfoController);

	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.opkg;
	        this.chefData = {};
	        this.chefDependenciesGridOptions = {};
	        this.chefPlatformsGridOptions = {};
	        this.$scope = $scope;

	        this._createGrids();
	        this.initChefInfo();
	    }

	    _createClass(jfChefInfoController, {
	        initChefInfo: {
	            value: function initChefInfo() {
	                this._registerEvents();
	                this._getChefInfoData();
	            }
	        },
	        _getChefInfoData: {
	            value: function _getChefInfoData() {
	                var _this = this;

	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }

	                this.artifactViewsDao.fetch({
	                    view: "chef",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.chefData = data.chefCookbookInfo;
	                    _this._setGridsData();
	                });
	            }
	        },
	        _setGridsData: {
	            value: function _setGridsData() {
	                var _this = this;

	                this.formattedDependencies = [];
	                _.forEach(this.chefData.dependencies, function (value, key) {
	                    _this.formattedDependencies.push({
	                        name: key,
	                        version: value
	                    });
	                });

	                this.formattedPlatforms = [];
	                _.forEach(this.chefData.platforms, function (value, key) {
	                    _this.formattedPlatforms.push({
	                        name: key,
	                        version: value
	                    });
	                });
	                this.chefDependenciesGridOptions.setGridData(this.formattedDependencies);
	                this.chefPlatformsGridOptions.setGridData(this.formattedPlatforms);
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.chefDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies"));

	                this.chefPlatformsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("platforms"));
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	                if (gridType === "platforms") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;

	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getChefInfoData();
	                    }
	                });
	            }
	        }
	    });

	    return jfChefInfoController;
	})();

	function jfChefInfo() {
	    return {
	        restrict: "EA",
	        controller: jfChefInfoController,
	        controllerAs: "jfChefInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_chef_info.html"
	    };
	}

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var AllBuildsController = __webpack_require__(321).AllBuildsController;

	var BuildsInfoController = __webpack_require__(322).BuildsInfoController;

	var BuildsHistoryController = __webpack_require__(324).BuildsHistoryController;

	var BuildsLocateController = __webpack_require__(325).BuildsLocateController;

	var buildTabs = _interopRequire(__webpack_require__(326));

	function buildsConfig($stateProvider) {
	    $stateProvider.state("builds", {
	        url: "/builds",
	        parent: "app-layout",
	        abstract: true,
	        templateUrl: "states/builds/builds.html"
	    }).state("builds.all", {
	        url: "/",
	        templateUrl: "states/builds/all_builds.html",
	        controller: "AllBuildsController as AllBuilds"
	    }).state("builds.history", {
	        url: "/{buildName}",
	        templateUrl: "states/builds/builds_history/builds_history.html",
	        controller: "BuildsHistoryController as BuildsHistory"
	    }).state("builds.locate", {
	        url: "/{buildName}/{buildNumber}",
	        templateUrl: "states/builds/builds_locate/builds_locate.html",
	        controller: "BuildsLocateController as BuildsLocate"
	    }).state("builds.info", {
	        url: "/{buildName}/{buildNumber}/{startTime}/{tab}/{moduleID}",
	        templateUrl: "states/builds/builds_info/builds_info.html",
	        controller: "BuildsInfoController as BuildsInfo"
	    });
	}

	module.exports = angular.module("builds", ["buildTabs"]).config(buildsConfig).controller("AllBuildsController", AllBuildsController).controller("BuildsInfoController", BuildsInfoController).controller("BuildsHistoryController", BuildsHistoryController).controller("BuildsLocateController", BuildsLocateController);

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(181));

	var AllBuildsController = exports.AllBuildsController = (function () {
	    function AllBuildsController($scope, $q, $timeout, JFrogGridFactory, BuildsDao, JFrogEventBus, JFrogModal, JFrogNotifications, uiGridConstants, User, GoogleAnalytics) {
	        _classCallCheck(this, AllBuildsController);

	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.user = User.getCurrent();
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.allBuildsGridOptions = {};
	        this.buildsDao = BuildsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this._createGrid();
	        this._getBuildsData();
	        this.firstFetch = true;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.builds;
	        this.noBuildsDataMessage = this.CONFIG_MESSAGES.noBuildsDataMessage;
	        this.updateBreadcrumbs();
	    }

	    _createClass(AllBuildsController, {
	        updateBreadcrumbs: {
	            value: function updateBreadcrumbs() {
	                this.JFrogEventBus.dispatch(EVENTS.BUILDS_BREADCRUMBS, name);
	            }
	        },
	        deleteBuild: {
	            value: function deleteBuild(row) {
	                var _this = this;

	                var json = {
	                    buildsCoordinates: [{
	                        buildName: row.buildName
	                    }]
	                };
	                this.modal.confirm("Are you sure you wish to delete all the builds '" + row.buildName + "'?").then(function () {
	                    _this.buildsDao.deleteAll(json).$promise.then(function () {
	                        _this._getBuildsData();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                var selectedRows = this.allBuildsGridOptions.api.selection.getSelectedRows();
	                var confirmMessage = "Are you sure you wish to delete " + selectedRows.length;
	                confirmMessage += selectedRows.length > 1 ? " build projects?" : " build project?";

	                this.modal.confirm(confirmMessage).then(function () {
	                    var buildsToDelete = selectedRows.map(function (build) {
	                        return {
	                            buildName: build.buildName
	                        };
	                    });
	                    //console.log(buildsToDelete);
	                    var json = {
	                        buildsCoordinates: buildsToDelete
	                    };
	                    _this.buildsDao.deleteAll(json).$promise.then(function () {
	                        _this._getBuildsData();
	                    });
	                    //this.artifactoryNotifications.create({info: 'Builds deleted'})
	                });
	            }
	        },
	        _getBuildsData: {
	            value: function _getBuildsData(pagination) {
	                var _this = this;

	                var defaultPagination = {
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "lastBuildTime"
	                };
	                this.buildsDao.get(defaultPagination).$promise.then(function (data) {

	                    var numOfBuilds = data && data.pagingData ? data.pagingData.length : 0;
	                    _this.GoogleAnalytics.trackEvent("Builds", "Number of builds", numOfBuilds, numOfBuilds);
	                    _this.buildsData = data.pagingData || [];
	                    _this.allBuildsGridOptions.setGridData(_this.buildsData);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {

	                this.allBuildsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {

	                var nameCellTemplate = "<div ng-click=\"grid.appScope.AllBuilds.updateBreadcrumbs()\" " + "class=\"ui-grid-cell-contents\"><a href=\"\" id=\"project-name\" ui-sref=\"builds.history({buildName:row.entity.buildName})\" >{{row.entity.buildName}}</a></div>";
	                var numberCellTemplate = "<div ng-click=\"grid.appScope.AllBuilds.updateBreadcrumbs()\" " + "class=\"ui-grid-cell-contents\"><a href=\"\" id=\"last-build-id\" ui-sref=\"builds.info({buildName:row.entity.buildName,buildNumber:row.entity.buildNumber,startTime:row.entity.time})\" >{{row.entity.buildNumber}}</a></div>";
	                var timeCellTemplate = "<div class=\"ui-grid-cell-contents\" id=\"last-build-time\">  {{row.entity.lastBuildTime }}</a>";

	                return [{
	                    name: "Project Name",
	                    displayName: "Project Name",
	                    field: "buildName",
	                    cellTemplate: nameCellTemplate,
	                    width: "60%"
	                }, {
	                    name: "Last Build ID",
	                    displayName: "Last Build ID",
	                    field: "buildNumber",
	                    cellTemplate: numberCellTemplate,
	                    width: "20%"
	                }, {
	                    name: "Last Build Time",
	                    displayName: "Last Build Time",
	                    cellTemplate: timeCellTemplate,
	                    field: "time",
	                    sort: {
	                        direction: this.uiGridConstants.DESC
	                    },
	                    type: "number",
	                    width: "20%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteBuild(row);
	                    },
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    },
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    }
	                }];
	            }
	        }
	    });

	    return AllBuildsController;
	})();

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var DICTIONARY = _interopRequire(__webpack_require__(323));

	var tabWidth = 165;

	var BuildsInfoController = exports.BuildsInfoController = (function () {
	    function BuildsInfoController($stateParams, $timeout, User, JFrogEventBus, ArtifactoryFeatures) {
	        var _this = this;

	        _classCallCheck(this, BuildsInfoController);

	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.user = User.getCurrent();
	        this.JFrogEventBus = JFrogEventBus;
	        this.features = ArtifactoryFeatures;
	        this.DICTIONARY = DICTIONARY.tabs;
	        this.buildTitle = "Build #" + this.$stateParams.buildNumber;
	        this.tabs = [{ name: "general" }, { name: "published" }, { name: "environment" }, { name: "issues" }, { name: "licenses", feature: "licenses" }, { name: "diff", feature: "diff" }, { name: "history" }, { name: "json" }];
	        this.tabs.forEach(function (tab) {
	            tab.isDisabled = _this._isTabDisabled(tab);
	        });

	        this.JFrogEventBus.dispatch(EVENTS.BUILDS_BREADCRUMBS);
	    }

	    _createClass(BuildsInfoController, {
	        _isTabDisabled: {
	            value: function _isTabDisabled(tab) {
	                return !this.user.canViewBuildState("builds.info", { tab: tab.name }) || this.features.isDisabled(tab.feature);
	            }
	        }
	    });

	    return BuildsInfoController;
	})();

/***/ }),
/* 323 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    tabs: {
	        general: "General Build Info",
	        published: "Published Modules",
	        environment: "Environment",
	        issues: "Issues",
	        licenses: "Licenses",
	        diff: "Diff",
	        history: "Release History",
	        json: "Build Info JSON"
	    },
	    generalInfo: {
	        buildName: "Name",
	        buildNumber: "Number",
	        agent: "Agent",
	        buildAgent: "Build Agent",
	        lastBuildTime: "Started",
	        duration: "Duration",
	        principal: "Principal",
	        artifactoryPrincipal: "Artifactory Principal",
	        url: "URL"
	    },
	    releaseHistory: {
	        repository: "Repository",
	        comment: "Comment",
	        ciUser: "CI User",
	        user: "Artifactory User"
	    }
	};

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var BuildsHistoryController = exports.BuildsHistoryController = (function () {
	    function BuildsHistoryController($scope, $q, $timeout, $stateParams, JFrogGridFactory, BuildsDao, JFrogEventBus, JFrogModal, JFrogNotifications, uiGridConstants, User) {
	        _classCallCheck(this, BuildsHistoryController);

	        this.$stateParams = $stateParams;
	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.user = User.getCurrent();
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.buildsHistoryGridOption = {};
	        this.buildTitle = "History for Build  '" + this.$stateParams.buildName + "'";
	        this.totalBuilds = "";
	        this.buildsDao = BuildsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.firstFetch = true;

	        this.JFrogEventBus.dispatch(EVENTS.BUILDS_BREADCRUMBS);

	        this._createGrid();
	        this._getBuildsData();
	    }

	    _createClass(BuildsHistoryController, {
	        deleteBuild: {
	            value: function deleteBuild(row) {
	                var _this = this;

	                var json = {
	                    buildsCoordinates: [{
	                        buildName: this.$stateParams.buildName,
	                        buildNumber: row.buildNumber,
	                        date: row.time
	                    }]
	                };
	                this.modal.confirm("Are you sure you wish to delete the build '" + this.$stateParams.buildName + "' #" + row.buildNumber + "?").then(function () {
	                    _this.buildsDao["delete"](json).$promise.then(function () {
	                        _this._getBuildsData();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;

	                var selectedRows = this.buildsHistoryGridOption.api.selection.getSelectedRows();
	                var confirmMessage = "Are you sure you wish to delete " + selectedRows.length;
	                confirmMessage += selectedRows.length > 1 ? " builds?" : " build?";

	                this.modal.confirm(confirmMessage).then(function () {
	                    var buildsToDelete = selectedRows.map(function (build) {
	                        return {
	                            buildName: _this.$stateParams.buildName,
	                            buildNumber: build.buildNumber,
	                            date: build.time
	                        };
	                    });
	                    //console.log(buildsToDelete);
	                    var json = {
	                        buildsCoordinates: buildsToDelete
	                    };
	                    _this.buildsDao["delete"](json).$promise.then(function () {
	                        _this._getBuildsData();
	                    });
	                });
	            }
	        },
	        _getBuildsData: {
	            value: function _getBuildsData(pagination) {
	                var _this = this;

	                if (pagination) {
	                    if (this.firstFetch) {
	                        this.firstFetch = false;
	                        pagination.orderBy = "buildNumber";
	                        pagination.direction = "asc";
	                    }
	                    return this.buildsDao.getData(pagination, {
	                        action: "history",
	                        name: this.$stateParams.buildName
	                    }).$promise;
	                } else {
	                    var defaultPagination = {
	                        pageNum: 1,
	                        numOfRows: 25,
	                        direction: "asc",
	                        orderBy: "buildNumber"
	                    };

	                    this.buildsDao.getData(defaultPagination, {
	                        action: "history",
	                        name: this.$stateParams.buildName
	                    }).$promise.then(function (data) {
	                        _this.buildsHistoryGridOption.setGridData(data.pagingData);
	                    });
	                }
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.buildsHistoryGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default")
	                //            .setExternalPagination((pagination) => this._getBuildsData(pagination))
	                .setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {

	                return [{
	                    name: "Build ID",
	                    displayName: "Build ID",
	                    field: "buildNumber",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a href=\"\" ng-click=\"grid.appScope.BuildsHistory.onClick(row.entity.build_number)\" ui-sref=\"builds.info({buildName:grid.appScope.BuildsHistory.$stateParams.buildName,buildNumber:row.entity.buildNumber,startTime:row.entity.time,tab:'general'})\" id=\"build-id\">{{row.entity.buildNumber}}</a></div>",
	                    width: "40%"
	                }, {
	                    name: "CI Server",
	                    displayName: "CI Server",
	                    field: "ciUrl",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a href=\"{{row.entity.ciUrl}}\" target=\"_blank\" id=\"ci-server\">{{row.entity.ciUrl}}</a></div>",
	                    width: "30%"
	                }, {
	                    name: "Status",
	                    displayName: "Status",
	                    field: "releaseStatus",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"status\">{{row.entity.releaseStatus}}</div>",
	                    allowGrouping: true,
	                    width: "10%"
	                }, {
	                    name: "Build Time",
	                    displayName: "Build Time",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"build-time\">{{row.entity.lastBuildTime}}</div>",
	                    field: "time",
	                    sort: {
	                        direction: this.uiGridConstants.DESC
	                    },
	                    type: "number",
	                    width: "20%"
	                }];
	            }
	        },
	        onClick: {
	            value: function onClick(name) {
	                this.JFrogEventBus.dispatch(EVENTS.BUILDS_BREADCRUMBS, name);
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;

	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteBuild(row);
	                    },
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    },
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    }
	                }];
	            }
	        }
	    });

	    return BuildsHistoryController;
	})();

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var BuildsLocateController = exports.BuildsLocateController = (function () {
	    function BuildsLocateController($scope, $timeout, $location, $stateParams, BuildsDao) {
	        _classCallCheck(this, BuildsLocateController);

	        this.$scope = $scope;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$location = $location;
	        this.buildsDao = BuildsDao;
	        this._getBuildsData();
	    }

	    _createClass(BuildsLocateController, {
	        _getBuildsData: {
	            value: function _getBuildsData() {
	                var _this = this;

	                return this.buildsDao.lastBuild({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber
	                }).$promise.then(function (data) {
	                    //
	                    _this.$location.path("/builds/" + _this.$stateParams.buildName + "/" + _this.$stateParams.buildNumber + "/" + data.time + "/general/");
	                });
	            }
	        }
	    });

	    return BuildsLocateController;
	})();

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var jfGeneralInfo = __webpack_require__(327).jfGeneralInfo;

	var jfPublishedModules = __webpack_require__(328).jfPublishedModules;

	var jfBuildInfoJson = __webpack_require__(329).jfBuildInfoJson;

	var jfEnvironment = __webpack_require__(330).jfEnvironment;

	var jfIssues = __webpack_require__(331).jfIssues;

	var jfDiff = __webpack_require__(332).jfDiff;

	var jfReleaseHistory = __webpack_require__(333).jfReleaseHistory;

	var jfLicenses = __webpack_require__(334).jfLicenses;

	module.exports = angular.module("buildTabs", []).directive({
	        jfGeneralInfo: jfGeneralInfo,
	        jfPublishedModules: jfPublishedModules,
	        jfBuildInfoJson: jfBuildInfoJson,
	        jfEnvironment: jfEnvironment,
	        jfIssues: jfIssues,
	        jfDiff: jfDiff,
	        jfReleaseHistory: jfReleaseHistory,
	        jfLicenses: jfLicenses
	});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfGeneralInfo = jfGeneralInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var DICTIONARY = _interopRequire(__webpack_require__(323));

	var jfGeneralInfoController = (function () {
	    function jfGeneralInfoController($scope, $state, $stateParams, BuildsDao, PushToBintrayModal, User, DistributionDao, JFrogModal) {
	        _classCallCheck(this, jfGeneralInfoController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.buildsDao = BuildsDao;
	        this.pushToBintrayModal = PushToBintrayModal;
	        this.generalData = {};
	        this.distributionDao = DistributionDao;
	        this.DICTIONARY = DICTIONARY.generalInfo;
	        this.User = User;
	        this.modal = JFrogModal;

	        //TODO [by dan]: Decide if we're bringing back push to bintray for builds -> remove this if not
	        // this.userCanPushToBintray = false;
	        this.userCanDistribute = false;

	        this._getGeneralInfo();
	    }

	    _createClass(jfGeneralInfoController, {
	        pushToBintray: {
	            value: function pushToBintray() {
	                this.modalInstance = this.pushToBintrayModal.launchModal("build");
	            }
	        },
	        distribute: {
	            value: function distribute() {
	                var _this = this;

	                this.distributionDao.getAvailableDistributionRepos({}).$promise.then(function (data) {
	                    var modalInstance = undefined;
	                    _this.distributeModalScope = _this.$scope.$new();

	                    _this.distributeModalScope.title = "Distribute " + _this.$stateParams.buildName + " #" + _this.$stateParams.buildNumber;
	                    _this.distributeModalScope.distributionRepositoriesOptions = _.map(data, "repoKey");

	                    _this.distributeModalScope.data = {};
	                    _this.distributeModalScope.data.async = true;
	                    _this.distributeModalScope.data.publish = true;
	                    _this.distributeModalScope.data.publish = true;
	                    _this.distributeModalScope.data.overrideExistingFiles = false;
	                    _this.distributeModalScope.data.selectedRepo = null;
	                    _this.distributeModalScope.distType = "build";
	                    _this.distributeModalScope.distribute = function () {
	                        _this._resetChanges();
	                        _this.distributionDao.distributeBuild({
	                            targetRepo: _this.distributeModalScope.data.selectedRepo,
	                            async: _this.distributeModalScope.data.async,
	                            overrideExistingFiles: _this.distributeModalScope.data.overrideExistingFiles,
	                            date: _this.$stateParams.startTime
	                        }, {
	                            buildName: _this.$stateParams.buildName,
	                            buildNumber: _this.$stateParams.buildNumber,
	                            date: _this.$stateParams.startTime
	                        }).$promise.then(function (res) {
	                            // Success
	                            if (_this.distributeModalScope.data.async) {
	                                modalInstance.close();
	                            } else {
	                                _this._runRulesTest(res);
	                            }
	                        });
	                    };

	                    // DRY RUN
	                    _this.distributeModalScope.dryRun = function () {
	                        _this._resetChanges();
	                        _this.distributionDao.distributeBuild({
	                            targetRepo: _this.distributeModalScope.data.selectedRepo,
	                            async: _this.distributeModalScope.data.async,
	                            publish: _this.distributeModalScope.data.publish,
	                            overrideExistingFiles: _this.distributeModalScope.data.overrideExistingFiles,
	                            dryRun: true
	                        }, {
	                            buildName: _this.$stateParams.buildName,
	                            buildNumber: _this.$stateParams.buildNumber,
	                            date: _this.$stateParams.startTime
	                        }).$promise.then(function (res) {
	                            _this._runRulesTest(res);
	                        });
	                    };

	                    modalInstance = _this.modal.launchModal("distribute_modal", _this.distributeModalScope, 650);
	                });
	            }
	        },
	        _runRulesTest: {
	            value: function _runRulesTest(res) {
	                var _this = this;

	                var ind = 0;
	                var result = res.data;
	                _.forEach(result, function (value, key) {
	                    if (key == "distributed") {
	                        (function () {
	                            var distributed = result[key];

	                            _.forEach(distributed, function (value, key) {
	                                distributed[key].customId = "dis" + ind;
	                                ind++;

	                                var packages = distributed[key].packages;

	                                _.forEach(packages, function (value, key) {
	                                    packages[key].customId = "pac" + ind;
	                                    ind++;

	                                    var versions = packages[key].versions;
	                                    _.forEach(versions, function (value, key) {
	                                        versions[key].customId = "ver" + ind;
	                                        ind++;
	                                    });
	                                });
	                            });
	                        })();
	                    }
	                });
	                this.distributeModalScope.data.dryRunResults = result;

	                _.forEach(result.messagesByPath, function (value) {
	                    if (value.warnings) {
	                        _this.distributeModalScope.data.warningExist = value.warnings.length ? true : false;
	                    }
	                    if (value.errors) {
	                        _this.distributeModalScope.data.errorsExist = value.errors.length ? true : false;
	                    }
	                });
	            }
	        },
	        _resetChanges: {
	            value: function _resetChanges() {
	                // RESET
	                this.distributeModalScope.data.dryRunResults = null;
	                this.distributeModalScope.data.toggleSuccessTitle = null;
	                this.distributeModalScope.data.toggleWarnTitle = null;
	                this.distributeModalScope.data.toggleErrorTitle = null;
	                this.distributeModalScope.data.warningExist = null;
	                this.distributeModalScope.data.errorsExist = null;
	            }
	        },
	        _getGeneralInfo: {
	            value: function _getGeneralInfo() {
	                var _this = this;

	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildInfo"
	                }).$promise.then(function (data) {
	                    //TODO [by dan]: Decide if we're bringing back push to bintray for builds -> remove this if not
	                    // this.userCanPushToBintray = data.allowPushToBintray && this.User.getCurrent().canPushToBintray();
	                    _this.userCanDistribute = data.userCanDistribute;
	                    _this.$stateParams.startTime = data.time;
	                    _this.$state.transitionTo(".", _this.$stateParams, { location: "replace", inherit: true, relative: _this.$state.$current, notify: false });
	                    _this.generalData = data;
	                });
	            }
	        }
	    });

	    return jfGeneralInfoController;
	})();

	function jfGeneralInfo() {
	    return {
	        restrict: "EA",
	        controller: jfGeneralInfoController,
	        controllerAs: "jfGeneralInfo",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_general_info.html"
	    };
	}

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfPublishedModules = jfPublishedModules;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var DICTIONARY = _interopRequire(__webpack_require__(323));

	var defaultPagination = {
	    pageNum: 1,
	    numOfRows: 25,
	    direction: "asc",
	    orderBy: "name"
	};

	var jfPublishedModulesController = (function () {
	    function jfPublishedModulesController($scope, $state, $stateParams, $q, BuildsDao, ArtifactBuildsDao, ArtifactActionsDao, JFrogGridFactory, JFrogDownload, JFrogModal, ArtifactoryFeatures, JFrogEventBus, $timeout, uiGridConstants, commonGridColumns, User, ArtifactoryStorage) {
	        var _this = this;

	        _classCallCheck(this, jfPublishedModulesController);

	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.$stateParams = $stateParams;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.initialModuleId = $stateParams.moduleID;
	        this.buildsDao = BuildsDao;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.artifactBuildsDao = ArtifactBuildsDao.getInstance();
	        this.download = JFrogDownload;
	        this.modal = JFrogModal;
	        this.modulesGridOptions = {};
	        this.artifactsGridOptions = {};
	        this.dependenciesGridOptions = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.user = User;
	        this.modulesCount = 0;
	        this.artifactsCount = 0;
	        this.dependenciesCount = 0;
	        this.DICTIONARY = DICTIONARY.generalInfo;
	        this.selectedModule = null;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.comparableNumbers = [""];
	        this.selectedBuildNumber = "";
	        this.artifactoryFeatures = ArtifactoryFeatures;

	        if (this.$stateParams.startTime) {
	            this.init();
	        } else {
	            this.getBuildTime().then(function () {
	                _this.init();
	            });
	        }
	    }

	    _createClass(jfPublishedModulesController, {
	        getBuildTime: {
	            value: function getBuildTime() {
	                var _this = this;

	                var defer = this.$q.defer();
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    action: "buildInfo"
	                }).$promise.then(function (data) {
	                    _this.$stateParams.startTime = data.time;
	                    _this.$state.transitionTo(".", _this.$stateParams, { location: "replace", inherit: true, relative: _this.$state.$current, notify: false });
	                    defer.resolve();
	                });
	                return defer.promise;
	            }
	        },
	        init: {
	            value: function init() {
	                this._getComparableBuildNumbers();
	                this._createGrids();

	                if (this.$stateParams.moduleID) {
	                    this.selectedModule = this.$stateParams.moduleID;
	                    this.getSubData();
	                } else {
	                    this.selectedModule = null;
	                }
	            }
	        },
	        showArtifactInTree: {
	            value: function showArtifactInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = row.repoKey + "/" + row.path;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                this.download(row.downloadLink);
	            }
	        },
	        viewCodeArtifact: {
	            value: function viewCodeArtifact(row) {
	                var _this = this;

	                this.artifactActionsDao.perform({ action: "view" }, {
	                    repoKey: row.repoKey,
	                    path: row.path
	                }).$promise.then(function (result) {
	                    _this.modal.launchCodeModal(row.name, result.data.fileContent, { name: row.type, json: true });
	                });
	            }
	        },
	        selectModule: {
	            value: function selectModule(entity) {
	                if (!this.artifactoryFeatures.isDisabled("publishedmodule")) {
	                    this.$state.go("builds.info", {
	                        buildName: this.$stateParams.buildName,
	                        buildNumber: this.$stateParams.buildNumber,
	                        startTime: this.$stateParams.startTime,
	                        tab: this.$stateParams.tab,
	                        moduleID: entity.moduleId
	                    });
	                }
	            }
	        },
	        getSubData: {
	            value: function getSubData() {
	                if (this.compare && this.selectedBuildNumber && this.selectedBuildNumber.buildNumber) {
	                    this._getArtifactsDiff();
	                    this._getDependenciesDiff();
	                } else {
	                    this._getArtifacts();
	                    this._getDependencies();
	                }
	            }
	        },
	        onCompareChanged: {
	            value: function onCompareChanged() {
	                if (!(this.selectedBuildNumber && this.selectedBuildNumber.buildNumber)) {
	                    // Don't get data if haven't selected build number yet
	                    return;
	                }
	                this.getSubData();
	            }
	        },
	        _getModulesData: {
	            value: function _getModulesData() {
	                var _this = this;

	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "publishedModules"
	                }).$promise.then(function (data) {
	                    _this.modulesCount = data.pagingData.length;
	                    _this.modulesGridOptions.setGridData(data.pagingData);
	                    if (_this.initialModuleId) {
	                        _this.initialModuleId = null;
	                        var _module2 = _.findWhere(data.pagingData, { moduleId: _this.$stateParams.moduleID })
	                        //                        this.modulesGridOptions.selectItem(module);
	                        ;
	                    }
	                });
	            }
	        },
	        _getArtifacts: {
	            value: function _getArtifacts() {
	                var _this = this;

	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "modulesArtifact",
	                    moduleId: this.selectedModule
	                }).$promise.then(function (data) {
	                    _this.artifactsCount = data.pagingData.length;
	                    _this.artifactsGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getDependencies: {
	            value: function _getDependencies() {
	                var _this = this;

	                var defaultPagination = {
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "id"
	                };
	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "modulesDependency",
	                    moduleId: this.selectedModule
	                }).$promise.then(function (data) {
	                    _this.dependenciesCount = data.pagingData.length;
	                    _this.dependenciesGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getArtifactsDiff: {
	            value: function _getArtifactsDiff() {
	                var _this = this;

	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "artifactDiff",
	                    moduleId: this.selectedModule,

	                    otherNumber: this.selectedBuildNumber.buildNumber,
	                    otherDate: this.selectedBuildNumber.time,

	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "name" }).$promise.then(function (data) {
	                    _this.artifactsCount = data.pagingData.length;
	                    _this.artifactsGridOptions.setGridData(data.pagingData);
	                });
	                ;
	            }
	        },
	        _getDependenciesDiff: {
	            value: function _getDependenciesDiff() {
	                var _this = this;

	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "dependencyDiff",
	                    moduleId: this.selectedModule,
	                    otherNumber: this.selectedBuildNumber.buildNumber,
	                    otherDate: this.selectedBuildNumber.time,

	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "id"
	                }).$promise.then(function (data) {
	                    _this.dependenciesCount = data.pagingData.length; //data.totalItems ? data.totalItems : 0;
	                    _this.dependenciesGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getComparableBuildNumbers: {
	            value: function _getComparableBuildNumbers() {
	                var _this = this;

	                this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "prevBuild"
	                }).$promise.then(function (data) {
	                    _this.comparableBuildNumbers = data;
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                var _this = this;

	                this.modulesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getModulesColumns()).setRowTemplate("default");

	                this.modulesGridOptions.onSelectionChange = function (data) {
	                    _this.selectModule(data.entity);
	                };

	                this.artifactsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getArtifactsColumns()).setRowTemplate("default");

	                this.dependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getDependenciesColumns()).setRowTemplate("default");

	                this._getModulesData();

	                var featureLink = this.artifactoryFeatures.getFeatureLink("publishedmodule");
	                var featureName = this.artifactoryFeatures.getFeatureName("publishedmodule");

	                if (this.artifactoryFeatures.isDisabled("publishedmodule")) {
	                    this.$timeout(function () {
	                        //$('.grid-counter').css('color', 'red');
	                        $(".grid-counter").append("<span class=\"license-required\"></span>");
	                        $(".grid-counter").find(".license-required").tooltipster({
	                            animation: "fade",
	                            contentAsHTML: "true",
	                            trigger: "hover",
	                            onlyOne: "true",
	                            interactive: "true",
	                            interactiveTolerance: 150,
	                            position: "top",
	                            theme: "tooltipster-default top",
	                            content: "Learn more about the <a href=\"" + featureLink + "\" target=\"_blank\">" + featureName + "</a> feature"
	                        });
	                    });
	                }
	            }
	        },
	        _getModulesColumns: {
	            value: function _getModulesColumns() {
	                var cellTemplate = "<div ng-click=\"grid.appScope.jfPublishedModules.selectModule(row.entity)\" class=\"ui-grid-cell-contents\"><a href=\"\">{{row.entity.moduleId}}</a></div>";

	                return [{
	                    name: "Module ID",
	                    displayName: "Module ID",
	                    field: "moduleId",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: cellTemplate,
	                    width: "60%"
	                }, {
	                    name: "Number Of Artifacts",
	                    displayName: "Number Of Artifacts",
	                    field: "numOfArtifacts",
	                    width: "20%"
	                }, {
	                    name: "Number Of Dependencies",
	                    displayName: "Number Of Dependencies",
	                    field: "numOfDependencies",
	                    width: "20%"
	                }];
	            }
	        },
	        _getArtifactsColumns: {
	            value: function _getArtifactsColumns() {
	                var _this = this;

	                var typeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.type}}</div>";

	                return [{
	                    name: "Artifact Name",
	                    displayName: "Artifact Name",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "40%",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-view",
	                        tooltip: "View",
	                        callback: function (row) {
	                            return _this.viewCodeArtifact(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.findWhere(row.actions, { name: "View" });
	                        }
	                    }],
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.findWhere(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type",
	                    cellTemplate: typeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    field: "repoPath",
	                    width: "50%",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showArtifactInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.findWhere(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }];
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                var _this = this;

	                var typeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.type}}</div>";
	                var scopeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.scope}}</div>";

	                return [{
	                    name: "Dependency ID",
	                    displayName: "Dependency ID",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "30%",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.findWhere(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scope",
	                    displayName: "Scope",
	                    field: "scope",
	                    cellTemplate: scopeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type",
	                    cellTemplate: typeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    field: "repoPath",
	                    width: "50%",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showArtifactInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.findWhere(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }];
	            }
	        },
	        _installWatchers: {
	            value: function _installWatchers() {
	                var _this = this;

	                this.$scope.$watch("jfPublishedModules.selectedBuildNumber", function (val) {
	                    if (val.length) {
	                        _this.getSubData();
	                    }
	                });
	                this.$scope.$watch("jfPublishedModules.compare", function (val) {
	                    if (val !== undefined) {
	                        _this.getSubData();
	                    }
	                });
	            }
	        },
	        backToModules: {
	            value: function backToModules() {
	                this.$state.go("builds.info", {
	                    buildName: this.$stateParams.buildName,
	                    buildNumber: this.$stateParams.buildNumber,
	                    startTime: this.$stateParams.startTime,
	                    tab: this.$stateParams.tab,
	                    moduleID: ""
	                });
	            }
	        }
	    });

	    return jfPublishedModulesController;
	})();

	function jfPublishedModules() {
	    return {
	        restrict: "EA",
	        controller: jfPublishedModulesController,
	        controllerAs: "jfPublishedModules",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_published_modules.html"
	    };
	}

/***/ }),
/* 329 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfBuildInfoJson = jfBuildInfoJson;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var jfBuildInfoJsonController = (function () {
	    function jfBuildInfoJsonController($stateParams, BuildsDao) {
	        _classCallCheck(this, jfBuildInfoJsonController);

	        this.$stateParams = $stateParams;
	        this.json = "";
	        this.buildsDao = BuildsDao;

	        this._getJson();
	    }

	    _createClass(jfBuildInfoJsonController, {
	        _getJson: {
	            value: function _getJson() {
	                var _this = this;

	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildJson"
	                }).$promise.then(function (data) {
	                    _this.json = data.fileContent;
	                });
	            }
	        }
	    });

	    return jfBuildInfoJsonController;
	})();

	function jfBuildInfoJson() {
	    return {
	        restrict: "EA",
	        controller: jfBuildInfoJsonController,
	        controllerAs: "jfBuildInfoJson",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_build_info_json.html"
	    };
	}

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfEnvironment = jfEnvironment;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var DICTIONARY = _interopRequire(__webpack_require__(323));

	var jfEnvironmentController = (function () {
	    function jfEnvironmentController($scope, BuildsDao, JFrogGridFactory, $stateParams, uiGridConstants) {
	        _classCallCheck(this, jfEnvironmentController);

	        this.$scope = $scope;
	        this.$stateParams = $stateParams;
	        this.buildsDao = BuildsDao;
	        this.uiGridConstants = uiGridConstants;
	        this.environmentGridOptions = {};
	        this.systemGridOptions = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.DICTIONARY = DICTIONARY.generalInfo;
	        this._getEnvironmentData();
	        this._createGrids();
	    }

	    _createClass(jfEnvironmentController, {
	        _getEnvironmentData: {
	            value: function _getEnvironmentData() {
	                this._getEnvVars();
	                this._getSysVars();
	            }
	        },
	        _getEnvVars: {
	            value: function _getEnvVars() {
	                var _this = this;

	                return this.buildsDao.getData({
	                    //            name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildProps",
	                    subAction: "env",
	                    orderBy: "key",
	                    numOfRows: 25,
	                    pageNum: 1,
	                    direction: "asc"
	                }).$promise.then(function (data) {
	                    if (data.pagingData) _this.environmentGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getSysVars: {
	            value: function _getSysVars() {
	                var _this = this;

	                return this.buildsDao.getData({
	                    //            name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildProps",
	                    subAction: "system",
	                    orderBy: "key",
	                    numOfRows: 25,
	                    pageNum: 1,
	                    direction: "asc"
	                }).$promise.then(function (data) {
	                    if (data.pagingData) _this.systemGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {

	                this.environmentGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);

	                this.systemGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Key",
	                    displayName: "Key",
	                    field: "key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    }
	                }, {
	                    name: "Value",
	                    displayName: "Value",
	                    field: "value"
	                }];
	            }
	        }
	    });

	    return jfEnvironmentController;
	})();

	function jfEnvironment() {
	    return {
	        restrict: "EA",
	        controller: jfEnvironmentController,
	        controllerAs: "jfEnvironment",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_environment.html"
	    };
	}

/***/ }),
/* 331 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfIssues = jfIssues;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var jfIssuesController = (function () {
	    function jfIssuesController($scope, $stateParams, BuildsDao, JFrogGridFactory, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, jfIssuesController);

	        this.$stateParams = $stateParams;
	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.buildsDao = BuildsDao;
	        this.gridOptions = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;

	        this.noData = false;

	        this._createGrid();
	        this._getIssuesData();
	    }

	    _createClass(jfIssuesController, {
	        _getIssuesData: {
	            value: function _getIssuesData() {
	                var _this = this;

	                this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildIssues"
	                }).$promise.then(function (data) {
	                    if (data.length) {
	                        _this.gridOptions.setGridData(data);
	                    } else {
	                        _this.noData = true;
	                    }
	                })["catch"](function () {
	                    _this.noData = true;
	                    _this.gridOptions.setGridData([]);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {

	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setButtons(this._getActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var cellTemplate = "<div class=\"ui-grid-cell-contents\"><a target=\"_blank\" ng-href=\"{{row.entity.url}}\">{{row.entity.key}}</a></div>";

	                return [{
	                    name: "Key",
	                    displayName: "Key",
	                    field: "key",
	                    cellTemplate: cellTemplate }, {
	                    name: "Summary",
	                    displayName: "Summary",
	                    field: "summary"
	                }, {
	                    name: "Previous Build",
	                    displayName: "Previous Build",
	                    field: "aggregated",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.aggregated"),
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    }
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                return [];
	            }
	        }
	    });

	    return jfIssuesController;
	})();

	function jfIssues() {
	    return {
	        restrict: "EA",
	        controller: jfIssuesController,
	        controllerAs: "jfIssues",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_issues.html"
	    };
	}

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfDiff = jfDiff;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var jfDiffController = (function () {
	    function jfDiffController($scope, $stateParams, $state, $window, BuildsDao, JFrogGridFactory, uiGridConstants, commonGridColumns, JFrogEventBus, JFrogDownload, ArtifactActionsDao, ArtifactoryStorage) {
	        _classCallCheck(this, jfDiffController);

	        this.$stateParams = $stateParams;
	        this.$scope = $scope;
	        this.$window = $window;
	        this.$state = $state;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.buildsDao = BuildsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactsGridOptions = {};
	        this.dependenciesGridOptions = {};
	        this.envVarsGridOptions = {};
	        this.download = JFrogDownload;
	        this.artifactoryGridFactory = JFrogGridFactory;

	        this.headerCellDefaultTemplate = JFrogGridFactory.getDefaultCellTemplate();

	        this.comparableBuildNumbers = [];

	        this.selectedBuildNumber = "";
	        this.excludeInternalDeps = false;

	        this._createGrids();

	        this._getComparableBuildNumbers();
	    }

	    _createClass(jfDiffController, {
	        _getCellTemplate: {
	            value: function _getCellTemplate(field) {
	                return "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity." + field + "}}</div>";
	            }
	        },
	        _addCellTemplates: {
	            value: function _addCellTemplates(colDef) {
	                for (var i = 0; i < colDef.length; i++) {
	                    var col = colDef[i];
	                    if (!col.cellTemplate) {
	                        col.cellTemplate = this._getCellTemplate(col.field);
	                    }
	                }
	                return colDef;
	            }
	        },
	        _getComparableBuildNumbers: {
	            value: function _getComparableBuildNumbers() {
	                var _this = this;

	                this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "prevBuild"
	                }).$promise.then(function (data) {
	                    data = _.sortBy(data, function (r) {
	                        return -r.buildNumber;
	                    });
	                    _this.comparableBuildNumbers = data;
	                    //            this.comparableBuildNumbers.unshift({buildNumber:''});
	                });
	            }
	        },
	        getDiffData: {
	            value: function getDiffData() {
	                var _this = this;

	                if (this.selectedBuildNumber.buildNumber) {
	                    this.buildsDao.getData({
	                        name: this.$stateParams.buildName,
	                        number: this.$stateParams.buildNumber,
	                        time: this.$stateParams.startTime,
	                        action: "buildDiff",
	                        otherNumber: this.selectedBuildNumber.buildNumber,
	                        otherDate: this.selectedBuildNumber.time,
	                        exDep: this.excludeInternalDeps
	                    }).$promise.then(function (data) {
	                        if (data) {
	                            _this.variablesLength = data.props.length ? data.props.length : 0;
	                            _this.dependenciesLength = data.dependencies.length ? data.dependencies.length : 0;
	                            _this.artifactsLength = data.artifacts.length ? data.artifacts.length : 0;

	                            if (data.artifacts) {
	                                _this.artifactsGridOptions.setGridData(data.artifacts || []);
	                            }
	                            if (data.dependencies) {
	                                _this.dependenciesGridOptions.setGridData(data.dependencies || []);
	                            }
	                            if (data.props) {
	                                _this.envVarsGridOptions.setGridData(data.props || []);
	                            }
	                        }
	                    });
	                }
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var artifactPath = row.repoKey + "/" + row.path;
	                var archivePath = "";
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    browser: browser,
	                    artifact: artifactPath
	                });
	                this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, artifactPath);
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                this.download(row.downloadLink);
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {

	                this.artifactsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getArtifactsColumns()).setRowTemplate("default");
	                this.dependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getDependenciesColumns()).setRowTemplate("default");
	                this.envVarsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getEnvVarsColumns()).setRowTemplate("default");
	            }
	        },
	        _getArtifactsColumns: {
	            value: function _getArtifactsColumns() {
	                var _this = this;

	                return this._addCellTemplates([{
	                    name: "Name (Current Build)",
	                    field: "name",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "20%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.findWhere(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Name",
	                    field: "prevName",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Name (Build #{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}})"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    allowGrouping: true,
	                    sort: { direction: this.uiGridConstants.DESC },
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Module",
	                    field: "moduleName",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }, {
	                    name: "Repo path",
	                    field: "downloadLink",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "30%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.findWhere(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }]);
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                var _this = this;

	                return this._addCellTemplates([{
	                    name: "Dependency ID (Current Build)",
	                    displayName: "Dependency ID (Current Build)",
	                    field: "name",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "20%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.findWhere(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Id",
	                    field: "prevName",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Id (Build #{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}})"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    allowGrouping: true,
	                    sort: { direction: this.uiGridConstants.DESC },
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Module",
	                    field: "moduleName",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }, {
	                    name: "Repo path",
	                    field: "downloadLink",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "30%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.findWhere(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }]);
	            }
	        },
	        _getEnvVarsColumns: {
	            value: function _getEnvVarsColumns() {
	                return this._addCellTemplates([{
	                    name: "Current Key",
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.key}}</div>",
	                    width: "20%"
	                }, {
	                    name: "Current Value",
	                    field: "value",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.value}}</div>",
	                    width: "20%"
	                }, {
	                    name: "Prev Key",
	                    field: "prevKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.prevKey}}</div>",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Build#{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}} Key"),
	                    width: "20%"
	                }, {
	                    name: "Prev Value",
	                    field: "prevValue",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.prevValue}}</div>",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Build#{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}} Value"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    sort: { direction: this.uiGridConstants.DESC },
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }]);
	            }
	        }
	    });

	    return jfDiffController;
	})();

	function jfDiff() {
	    return {
	        restrict: "EA",
	        controller: jfDiffController,
	        controllerAs: "jfDiff",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_diff.html"
	    };
	}

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfReleaseHistory = jfReleaseHistory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var DICTIONARY = _interopRequire(__webpack_require__(323));

	var jfReleaseHistoryController = (function () {
	    function jfReleaseHistoryController($stateParams, BuildsDao) {
	        _classCallCheck(this, jfReleaseHistoryController);

	        this.$stateParams = $stateParams;
	        this.buildsDao = BuildsDao;
	        this.historyData = null;
	        this.DICTIONARY = DICTIONARY.releaseHistory;

	        this._getData();
	    }

	    _createClass(jfReleaseHistoryController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;

	                return this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "releaseHistory"
	                }).$promise.then(function (data) {
	                    _this.historyData = data;
	                })["catch"](function () {
	                    _this.historyData = [];
	                });
	            }
	        }
	    });

	    return jfReleaseHistoryController;
	})();

	function jfReleaseHistory() {
	    return {
	        restrict: "EA",
	        controller: jfReleaseHistoryController,
	        controllerAs: "jfReleaseHistory",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_release_history.html"
	    };
	}

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.jfLicenses = jfLicenses;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var jfLicensesController = (function () {
	    function jfLicensesController($scope, $state, $window, $stateParams, BuildsDao, ArtifactPropertyDao, JFrogGridFactory, JFrogModal, ArtifactoryState, JFrogDownload, commonGridColumns, ArtifactActionsDao, ArtifactoryStorage) {
	        _classCallCheck(this, jfLicensesController);

	        this.TOOLTIP = TOOLTIP.builds;
	        this.$stateParams = $stateParams;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$window = $window;
	        this.buildsDao = BuildsDao;
	        this.propsDao = ArtifactPropertyDao.getInstance();
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.download = JFrogDownload;
	        this.artifactoryState = ArtifactoryState;
	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.extendedGridOptions = {};

	        this.modalInstance = null;

	        this.includePublished = false;

	        this.allData = {};

	        this.filteredData = {};

	        this.scopesOptions = {};
	        this.scopesOptionsCopy = {};

	        this.showExtendedGrid = false;

	        this.canOverride = true;

	        this._createGrids();

	        this._getLicensesData();

	        this.toOverride = [];
	    }

	    _createClass(jfLicensesController, {
	        getFilteredData: {
	            value: function getFilteredData() {
	                var data = _.map(angular.copy(this.filteredData), function (obj) {
	                    delete obj.$$hashKey;
	                    return obj;
	                });

	                return JSON.stringify({ licenses: data });
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                var _this = this;

	                var params = { action: "download" };
	                this.artifactActionsDao.perform(params, {
	                    path: row.path,
	                    repoKey: row.repoKey
	                }).$promise.then(function (response) {
	                    _this.download(response.data.path);
	                });
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = row.repoKey + "/" + row.path;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        editLicense: {
	            value: function editLicense(row) {
	                var prevState = { state: this.$state.current.name, params: angular.copy(this.$stateParams) };
	                this.artifactoryState.setState("prevState", prevState);
	                this.$state.go("admin.configuration.editLicense", { licenseName: row.license.name });
	            }
	        },
	        changeLicense: {
	            value: function changeLicense(row) {
	                var _this = this;

	                this._getLicensesPredefineValues(row).then(function (data) {
	                    var modalScope = _this.$scope.$new();
	                    modalScope.saveLicenses = function (licenses) {
	                        _this.propsDao.update({
	                            repoKey: row.repoKey,
	                            path: row.path
	                        }, {
	                            parent: { name: "artifactory" },
	                            property: { name: "licenses" },
	                            selectedValues: licenses
	                        }).$promise.then(function (res) {
	                            //console.log(res);
	                            _this.modalInstance.close();
	                            _this._getLicensesData();
	                        });
	                    };
	                    modalScope.closeModal = function () {
	                        return _this.modalInstance.close();
	                    };

	                    if (_this.showExtendedGrid && row.extractedLicense.name !== "Not Found") {
	                        modalScope.foundLicense = row.extractedLicense.name;

	                        if (row.extractedLicense.found && row.extractedLicense.name !== row.license.name) modalScope.foundLicenseClass = row.extractedLicense.approved ? "license-approved" : "license-unapproved";else if (!row.extractedLicense.found || row.extractedLicense.name === row.license.name) modalScope.foundLicenseClass = "license-found-same-or-notfound";

	                        if (row.overridable) {
	                            modalScope.overridable = true;
	                            modalScope.override = function () {
	                                modalScope.selectedLicenses = [row.extractedLicense.name];
	                            };
	                        }
	                    }
	                    modalScope.modalTitle = "Edit 'artifactory.licenses' Property";
	                    modalScope.licenses = data.predefinedValues;
	                    modalScope.selectedLicenses = data.selectedValues;
	                    _this.modalInstance = _this.modal.launchModal("add_license_modal", modalScope);
	                });
	            }
	        },
	        autoLink: {
	            value: function autoLink() {
	                this.showExtendedGrid = true;
	                this._getLicensesData();
	            }
	        },
	        overrideSelected: {
	            value: function overrideSelected() {
	                var _this = this;

	                if (this.toOverride.length) {
	                    var requestObject = {
	                        name: this.$stateParams.buildName,
	                        number: this.$stateParams.buildNumber,
	                        time: this.$stateParams.startTime,
	                        licenses: this.toOverride
	                    };

	                    this.buildsDao.overrideLicenses(requestObject).$promise.then(function (data) {
	                        _this.cancel();
	                    });
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.showExtendedGrid = false;
	                this._getLicensesData();
	            }
	        },
	        onIncludePublish: {
	            value: function onIncludePublish() {
	                this._filterData();
	            }
	        },
	        onIncludeByScopes: {
	            value: function onIncludeByScopes() {
	                if (this.includeByScopes) {
	                    angular.copy(this.scopesOptionsCopy, this.scopesOptions);
	                } else {
	                    angular.copy(this.scopesOptions, this.scopesOptionsCopy);
	                    for (var key in this.scopesOptions) {
	                        this.scopesOptions[key] = true;
	                    }
	                }
	                this._filterData();
	            }
	        },
	        onScopeOptionChange: {
	            value: function onScopeOptionChange() {
	                this._filterData();
	            }
	        },
	        _getLicensesPredefineValues: {
	            value: function _getLicensesPredefineValues(row) {
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    autoFind: this.showExtendedGrid,
	                    id: row.id,
	                    repoKey: row.repoKey,
	                    path: row.path,
	                    action: "changeLicenses"
	                }).$promise;
	            }
	        },
	        _getLicensesData: {
	            value: function _getLicensesData() {
	                var _this = this;

	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    autoFind: this.showExtendedGrid,
	                    action: "buildLicenses"
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _.map(data.scopes, function (scope) {
	                        _this.scopesOptions[scope] = true;
	                    });
	                    angular.copy(_this.scopesOptions, _this.scopesOptionsCopy);
	                    _this.allData = data;
	                    _this._filterData();
	                });
	            }
	        },
	        _filterData: {
	            value: function _filterData() {
	                var _this = this;

	                var relevantData = this.allData.licenses;

	                if (this.includePublished) {
	                    relevantData = relevantData.concat(this.allData.publishedModules);
	                }

	                this.filteredData = _.filter(relevantData, function (license) {
	                    if (!_this.includeByScopes) return true;else {
	                        var ret = false;
	                        for (var key in _this.scopesOptions) {
	                            if (_this.scopesOptions[key] && license.scopeNames.includes(key)) {
	                                ret = true;
	                                break;
	                            }
	                        }
	                        return ret;
	                    }
	                });
	                if (this.showExtendedGrid) {
	                    this.extendedGridOptions.setGridData(this.filteredData);
	                } else {
	                    this.gridOptions.setGridData(this.filteredData);
	                }

	                this._calculateSummary();
	            }
	        },
	        _calculateSummary: {
	            value: function _calculateSummary() {
	                this.summary = {
	                    notApproved: _.filter(this.filteredData, function (license) {
	                        return license.license.found && !license.license.approved;
	                    }).length,
	                    notFound: _.filter(this.filteredData, function (license) {
	                        return license.license.notFound;
	                    }).length,
	                    unknown: _.filter(this.filteredData, function (license) {
	                        return license.license.unknown;
	                    }).length,
	                    neutral: _.filter(this.filteredData, function (license) {
	                        return license.license.notSearched;
	                    }).length,
	                    approved: _.filter(this.filteredData, function (license) {
	                        return license.license.approved;
	                    }).length };

	                this.summary.ok = this.summary.notApproved === 0 && this.summary.notFound === 0 && this.summary.unknown === 0;
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default");
	                this.extendedGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getExtendedColumns()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var _this = this;

	                var nameCellTemplate = "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>";

	                var licenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-unapproved': row.entity.license.found && !row.entity.license.approved," + "'license-approved': row.entity.license.approved," + "'license-notfound': row.entity.license.notFound," + "'license-neutral': row.entity.license.notSearched}\"" + "><div ng-if=\"row.groupHeader\">{{row.entity['license.name']}}</div>" + "<div ng-if=\"!row.groupHeader\">" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') !== -1\"><a href=\"\" ng-click=\"grid.appScope.jfLicenses.changeLicense(row.entity)\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</a></span>" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') === -1\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</span>" + "</div></div>";
	                return [{
	                    name: "Artifact ID",
	                    displayName: "Artifact ID",
	                    field: "id",
	                    cellTemplate: nameCellTemplate,
	                    width: "25%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return row.actions.indexOf("Download") !== -1;
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scopes",
	                    displayName: "Scopes",
	                    field: "scopeNames",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "12%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    cellTemplate: this.commonGridColumns.repoPathColumn(),
	                    field: "path",
	                    width: "50%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return row.actions.indexOf("ShowInTree") !== -1;
	                        }
	                    }]
	                }, {
	                    name: "License",
	                    displayName: "License",
	                    field: "license.name",
	                    allowGrouping: true,
	                    cellTemplate: licenseCellTemplate,
	                    grouped: true,
	                    width: "13%"
	                }];
	            }
	        },
	        _getExtendedColumns: {
	            value: function _getExtendedColumns() {
	                var _this = this;

	                var nameCellTemplate = "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>";

	                var licenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-unapproved': row.entity.license.found && !row.entity.license.approved," + "'license-approved': row.entity.license.approved," + "'license-notfound': row.entity.license.notFound}\"" + "><div ng-if=\"row.groupHeader\">{{row.entity['license.name']}}</div>" + "<div ng-if=\"!row.groupHeader\">" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') !== -1\"><a href=\"\" ng-click=\"grid.appScope.jfLicenses.changeLicense(row.entity)\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</a></span>" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') === -1\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</span>" + "</div></div>";

	                var foundLicenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-approved': row.entity.extractedLicense.found && row.entity.extractedLicense.name !== row.entity.license.name && row.entity.extractedLicense.approved," + "'license-unapproved': row.entity.extractedLicense.found && row.entity.extractedLicense.name !== row.entity.license.name && !row.entity.extractedLicense.approved," + "'license-found-same-or-notfound': !row.entity.extractedLicense.found || row.entity.extractedLicense.name === row.entity.license.name}\"" + ">{{row.entity.extractedLicense.name === \"Unknown\" ? \"Unknown(\" + row.entity.extractedLicense.longName + \")\" : row.entity.extractedLicense.name}}</div>";

	                return [{
	                    name: "Artifact ID",
	                    displayName: "Artifact ID",
	                    field: "id",
	                    cellTemplate: nameCellTemplate,
	                    width: "25%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return row.actions.indexOf("Download") !== -1;
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scopes",
	                    field: "scopeNames",
	                    allowGrouping: true,
	                    grouped: true
	                }, {
	                    name: "Repo Path",
	                    cellTemplate: this.commonGridColumns.repoPathColumn(),
	                    field: "path",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return row.actions.indexOf("ShowInTree") !== -1;
	                        }
	                    }]
	                }, {
	                    name: "License",
	                    field: "license.name",
	                    allowGrouping: true,
	                    cellTemplate: licenseCellTemplate,
	                    grouped: true
	                }, {
	                    name: "Found Licenses",
	                    field: "extractedLicense.name",
	                    cellTemplate: foundLicenseCellTemplate
	                }, {
	                    name: "Override",
	                    field: "selected",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.selected", "grid.appScope.jfLicenses.setSelected(row.entity)", "!row.entity.overridable")
	                }];
	            }
	        },
	        setSelected: {
	            value: function setSelected(row) {
	                if (row.selected) {
	                    this.toOverride.push(row);
	                } else {
	                    var index = this.toOverride.indexOf(row);
	                    if (index != -1) {
	                        this.toOverride.splice(index, 1);
	                    }
	                }
	            }
	        },
	        hasScopesOptions: {
	            value: function hasScopesOptions() {
	                return Object.keys(this.scopesOptions).length > 0;
	            }
	        }
	    });

	    return jfLicensesController;
	})();

	function jfLicenses() {
	    return {
	        restrict: "EA",
	        controller: jfLicensesController,
	        controllerAs: "jfLicenses",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/builds_info/build_tabs/jf_licenses.html"
	    };
	}

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var HomeController = __webpack_require__(336).HomeController;

	function homeConfig($stateProvider) {

	    $stateProvider.state("home", {
	        url: "/home",
	        parent: "app-layout",
	        templateUrl: "states/home/home.html",
	        controller: "HomeController as Home",
	        onExit: function (TreeBrowserDao) {
	            TreeBrowserDao.invalidateRoots();
	        } });
	}

	module.exports = angular.module("home", []).config(homeConfig).controller("HomeController", HomeController);

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var ArtifactCountController = __webpack_require__(337).ArtifactCountController;

	var VersionController = __webpack_require__(338).VersionController;

	var UpdatesController = __webpack_require__(339).UpdatesController;

	var QuickSearchController = __webpack_require__(340).QuickSearchController;

	var AddonsController = __webpack_require__(341).AddonsController;

	var LinksController = __webpack_require__(342).LinksController;

	var MostDownloadedController = __webpack_require__(343).MostDownloadedController;

	var LastDeployedController = __webpack_require__(344).LastDeployedController;

	var SetMeUpWidgetController = __webpack_require__(345).SetMeUpWidgetController;

	var EVENTS = _interopRequire(__webpack_require__(48));

	var HomeController = exports.HomeController = (function () {
	    function HomeController($timeout, $scope, User, ArtifactoryState, ArtifactoryFeatures, HomePageDao, JFrogEventBus, GoogleAnalytics) {
	        var _this = this;

	        _classCallCheck(this, HomeController);

	        this.$timeout = $timeout;
	        this.$scope = $scope;
	        this.homePageDao = HomePageDao;
	        this.user = User.getCurrent();
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryState = ArtifactoryState;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.widgetsOptions = {
	            padding: 15,
	            minHeight: 490
	        };
	        this.footerText = "Other than JFrog's trademarks, marks and logos, all other trademarks displayed in this application are owned by their respective holders. JFrog is not sponsored by, endorsed by or affiliated with the holders of these trademarks. More info here - <a target=_blank\" href=\"http://www.jfrog.com/artifactory/artifactory-cloud\">Terms of Use</a>,<a target=_blank\" href=\"http://www.jfrog.com/artifactory/artifactory-pro/\">EULA</a>.";
	        this.defineWidgets();
	        this.createLayout();

	        JFrogEventBus.register(EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getData();
	        });

	        this.getData();
	        this.isAol = function () {
	            return _this.features.isAol();
	        };
	        this.jfNewsIsOn = true;
	    }

	    _createClass(HomeController, {
	        getData: {
	            value: function getData() {
	                var _this = this;

	                this.homepageData = {};
	                this.homePageDao.get({ widgetName: "artifactCount" }).$promise.then(function (data) {
	                    _.extend(_this.homepageData, data.widgetData);
	                    _this.homePageDao.get({ widgetName: "info" }).$promise.then(function (data) {
	                        _.extend(_this.homepageData, data.widgetData);
	                    });
	                });
	            }
	        },
	        defineWidgets: {
	            value: function defineWidgets() {
	                this.widgets = {
	                    artifactCount: {
	                        name: "Artifacts Count",
	                        id: "artifacts-count",
	                        templateUrl: "home_widgets/artifacts_count_widget/artifacts_count.html",
	                        controller: ArtifactCountController,
	                        scroll: false,
	                        showSpinner: true },
	                    version: {
	                        name: "Version",
	                        id: "version",
	                        templateUrl: "home_widgets/version_widget/version.html",
	                        controller: VersionController,
	                        scroll: false,
	                        showSpinner: true },
	                    updates: {
	                        name: "Updates",
	                        id: "updates",
	                        templateUrl: "home_widgets/updates_widget/updates.html",
	                        controller: UpdatesController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    quickSearch: {
	                        name: "Quick Search",
	                        id: "quick-search",
	                        templateUrl: "home_widgets/quick_search/quick_search.html",
	                        controller: QuickSearchController,
	                        scroll: false,
	                        showSpinner: false
	                    },
	                    addons: {
	                        name: "Addons",
	                        id: "addons",
	                        templateUrl: "home_widgets/addons_widget/addons.html",
	                        controller: AddonsController,
	                        scroll: false,
	                        showSpinner: true },
	                    usefulLinks: {
	                        name: "Useful Links",
	                        templateUrl: "home_widgets/links_widget/links.html",
	                        controller: LinksController,
	                        scroll: false,
	                        showSpinner: false
	                    },
	                    lastDeployed: {
	                        name: "Last Deployed",
	                        id: "last-deployed",
	                        templateUrl: "home_widgets/last_deployed_widget/last_deployed.html",
	                        controller: LastDeployedController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    mostDownloaded: {
	                        name: "Most Downloaded",
	                        id: "most-downloaded",
	                        templateUrl: "home_widgets/most_downloaded_widget/most_downloaded.html",
	                        controller: MostDownloadedController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    setMeUp: {
	                        name: "Set me up",
	                        id: "set-me-up",
	                        templateUrl: "home_widgets/set_me_up_widget/set-me-up.html",
	                        controller: SetMeUpWidgetController,
	                        scroll: true,
	                        showSpinner: true
	                    } };
	            }
	        },
	        createLayout: {
	            value: function createLayout() {
	                this.widgetsLayout = {
	                    main: {
	                        rows: [{
	                            size: "73%",
	                            cells: ["100% #top"]
	                        }, {
	                            size: "27%",
	                            cells: ["100% #bottom"]
	                        }]
	                    },
	                    top: {
	                        main: {
	                            rows: [{
	                                size: "100%",
	                                cells: ["33% #topLeft", "34% #topCenter", "33% #topRight"]
	                            }]
	                        },
	                        topLeft: {
	                            columns: [{
	                                size: "100%",
	                                cells: ["40% @quickSearch", "60% @usefulLinks"]
	                            }]
	                        },
	                        topCenter: {
	                            main: {
	                                columns: [{
	                                    size: "100%",
	                                    cells: ["100% @setMeUp"]
	                                }]
	                            }
	                        },
	                        topRight: {
	                            columns: [{
	                                size: "100%",
	                                cells: ["50% @lastDeployed", "50% @mostDownloaded"]
	                            }]
	                        }
	                    },
	                    bottom: {
	                        columns: [{
	                            size: "100%",
	                            cells: ["100% @addons"]
	                        }]
	                    }
	                };
	            }
	        }
	    });

	    return HomeController;
	})();

/***/ }),
/* 337 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var ArtifactCountController = exports.ArtifactCountController = (function () {
	    function ArtifactCountController(HomePageDao) {
	        _classCallCheck(this, ArtifactCountController);

	        this.homePageDao = HomePageDao;
	        this.initHomePage();
	        this.updateCount();
	    }

	    _createClass(ArtifactCountController, {
	        initHomePage: {
	            value: function initHomePage() {
	                var _this = this;

	                this.homePageDao.get({ widgetName: "artifactCount" }).$promise.then(function (data) {
	                    _this.homepageData = data.widgetData;
	                    _this.$widgetObject.showSpinner = false;
	                });
	            }
	        },
	        updateCount: {
	            value: function updateCount() {
	                this.$widgetObject.showSpinner = true;
	                this.initHomePage();
	            }
	        }
	    });

	    return ArtifactCountController;
	})();

/***/ }),
/* 338 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var VersionController = exports.VersionController = (function () {
	    function VersionController(HomePageDao) {
	        _classCallCheck(this, VersionController);

	        this.homePageDao = HomePageDao;
	        this.initHomePage();
	    }

	    _createClass(VersionController, {
	        initHomePage: {
	            value: function initHomePage() {
	                var _this = this;

	                this.homePageDao.get({ widgetName: "info" }).$promise.then(function (data) {
	                    _this.homepageData = data.widgetData;
	                    _this.$widgetObject.showSpinner = false;
	                });
	            }
	        }
	    });

	    return VersionController;
	})();

/***/ }),
/* 339 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var UpdatesController = exports.UpdatesController = (function () {
	    function UpdatesController(User, $timeout) {
	        _classCallCheck(this, UpdatesController);

	        this.$timeout = $timeout;
	        this.showNews = false;
	        var offlineMode = User.getCurrent().offlineMode;
	        if (!offlineMode) this.readUpdateHTML();
	    }

	    _createClass(UpdatesController, {
	        readUpdateHTML: {
	            value: function readUpdateHTML() {
	                var _this = this;

	                var xhr = new XMLHttpRequest();
	                xhr.open("GET", "https://service.jfrog.org/artifactory/updatesv4", true);
	                xhr.onreadystatechange = function () {
	                    _this.updateHTML = xhr.response;
	                    _this.$scope.$apply();

	                    //twitter button javascript !
	                    !(function (d, s, id) {
	                        var js,
	                            fjs = d.getElementsByTagName(s)[0],
	                            p = /^http:/.test(d.location) ? "http" : "https";
	                        if (!d.getElementById(id)) {
	                            js = d.createElement(s);
	                            js.id = id;js.src = p + "://platform.twitter.com/widgets.js";
	                            fjs.parentNode.insertBefore(js, fjs);
	                        }
	                    })(document, "script", "twitter-wjs");

	                    _this.$scope.$on("$destroy", function () {
	                        var twitter = document.getElementById("twitter-wjs");
	                        if (twitter) twitter.remove();
	                    });

	                    if (xhr.response) {
	                        _this.$timeout(function () {
	                            _this.showNews = true;
	                            _this.$widgetObject.showSpinner = false;
	                        }, 200);
	                    }
	                };
	                xhr.send();
	            }
	        }
	    });

	    return UpdatesController;
	})();

/***/ }),
/* 340 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var QuickSearchController = exports.QuickSearchController = (function () {
	    function QuickSearchController($state, ArtifactoryFeatures, GoogleAnalytics) {
	        _classCallCheck(this, QuickSearchController);

	        this.GoogleAnalytics = GoogleAnalytics;
	        this.$state = $state;
	        this.features = ArtifactoryFeatures;

	        this.links = [{
	            title: "Package\nSearch",
	            search: "package"
	        }, {
	            title: "Archive\nSearch",
	            search: "archive"
	        }, {
	            title: "Property\nSearch",
	            search: "property"
	        }, {
	            title: "Checksum\nSearch",
	            search: "checksum"
	        }, {
	            title: "JCenter\nSearch",
	            search: "remote"
	        }];
	    }

	    _createClass(QuickSearchController, {
	        search: {
	            value: function search() {
	                if (!this.query) {
	                    return;
	                }var query = {
	                    search: "quick",
	                    query: this.query
	                };
	                this.$state.go("search", { searchType: "quick", query: btoa(JSON.stringify(query)), fromHome: true });
	            }
	        },
	        gotoSearch: {
	            value: function gotoSearch(searchType) {
	                this.GoogleAnalytics.trackEvent("Homepage", "Quick Search link", searchType);
	                this.$state.go("search", { searchType: searchType });
	            }
	        }
	    });

	    return QuickSearchController;
	})();

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var AddonsController = exports.AddonsController = (function () {
	    function AddonsController(HomePageDao, $timeout, $interval, JFrogEventBus) {
	        var _this = this;

	        _classCallCheck(this, AddonsController);

	        this.homePageDao = HomePageDao;

	        this.$timeout = $timeout;
	        this.$interval = $interval;

	        this.tabOptions = ["All", "Package Management", "Features", "Ecosystem", "Available"];
	        this.currentType = this.tabOptions[0];

	        this.getData();

	        $(window).resize(function () {
	            _this.$timeout(function () {
	                return _this.calculateAddonSize();
	            }, 100);
	        });
	        JFrogEventBus.register(EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.$widgetObject.showSpinner = true;
	            _this.getData();
	        });

	        this.addonsAnimation = undefined;
	        this.logColor = "color: green;";

	        window.move1 = this._move1.bind(this);
	        window.move3 = this._move3.bind(this);
	        window.moveAll = this._moveAll.bind(this);

	        this.lastDeltaX = 1;
	    }

	    _createClass(AddonsController, {
	        getData: {
	            value: function getData() {
	                var _this = this;

	                this.homePageDao.get({ widgetName: "addon" }).$promise.then(function (data) {
	                    _this.addons = data.widgetData.addons;

	                    var remainInOneLine = ["git-lfs", "sumo-logic", "ivy", "xray", "jfrog-cli", "plugin"]; // This items should remain in one line
	                    var brake3WordsAfter2ndWord = ["s3fileStore", "gcs", "distribution"]; // This items has 3 words and needs to brake after the second word
	                    var brake3WordsAfter1stWord = ["smart-repo", "sso"]; // This items has 3 words and needs to brake after the first word

	                    _.forEach(_this.addons, function (addon) {
	                        if (!_.includes(remainInOneLine, addon.name) && !_.includes(brake3WordsAfter2ndWord, addon.name) && !_.includes(brake3WordsAfter1stWord, addon.name)) {
	                            addon.displayName = addon.displayName.split(" ").join("\n");
	                        }
	                        if (_.includes(brake3WordsAfter2ndWord, addon.name)) {
	                            var splitDisplayName = addon.displayName.split(" ");
	                            var newDisplayName = splitDisplayName[0] + " " + splitDisplayName[1] + "\n" + splitDisplayName[2];

	                            addon.displayName = newDisplayName;
	                        }
	                        if (_.includes(brake3WordsAfter1stWord, addon.name)) {
	                            var splitDisplayName = addon.displayName.split(" ");
	                            var newDisplayName = splitDisplayName[0] + "\n" + splitDisplayName[1] + " " + splitDisplayName[2];

	                            addon.displayName = newDisplayName;
	                        }
	                    });

	                    _this.$timeout(function () {
	                        _this.calculateAddonSize();
	                        _this.$widgetObject.showSpinner = false;
	                    }, 100);
	                });
	            }
	        },
	        sortByCurrentType: {
	            value: function sortByCurrentType() {
	                var _this = this;

	                this.addons = _.filter(this.allAddons, function (addon) {
	                    return addon.categories.indexOf(_this._camelize(_this.currentType)) !== -1;
	                });
	                $(".addon-icon").removeClass("swelling");

	                // Commented out until we get a clearance from Yoav
	                // setTimeout(this.animateAddons.bind(this),100)

	                this.$timeout(function () {
	                    _this.freezeSwitchMenu();
	                });
	            }
	        },
	        _camelize: {
	            value: function _camelize(str) {
	                return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function (letter, index) {
	                    return index == 0 ? letter.toLowerCase() : letter.toUpperCase();
	                }).replace(/\s+/g, "");
	            }
	        },
	        freezeSwitchMenu: {
	            value: function freezeSwitchMenu() {
	                var swichMenu = $(".homepage-switch");
	                swichMenu.css({
	                    position: "fixed",
	                    width: $(".card.stretch").prop("clientWidth")
	                });
	                $(".addon-list").css("padding-top", 100);
	            }
	        },
	        calculateAddonSize: {
	            value: function calculateAddonSize() {
	                var addonWrapperWidth = $(".addons-wrapper").width();
	                this.numberOfItemsInLine = Math.round(addonWrapperWidth / 200);
	                this.tileWidth = addonWrapperWidth / this.numberOfItemsInLine;

	                $(".addon-tile").width(this.tileWidth);

	                this.ready = true;
	            }
	        },
	        addonPrevButton: {
	            value: function addonPrevButton() {

	                if ($(".addon-tile").is(":animated")) {
	                    return false;
	                }var addonItem = $(".addon-tile").last();
	                addonItem.insertBefore($(".addon-tile").first()).css("margin-left", -this.tileWidth);
	                addonItem.animate({ "margin-left": 0 }, 250);
	            }
	        },
	        addonNextButton: {
	            value: function addonNextButton() {

	                if ($(".addon-tile").is(":animated")) {
	                    return false;
	                }var addonItem = $(".addon-tile").first();

	                addonItem.animate({ "margin-left": -this.tileWidth }, 250);
	                this.$timeout(function () {
	                    addonItem.insertAfter($(".addon-tile").last());
	                    $(".addon-tile").css("margin-left", "");
	                }, 250);
	            }
	        },
	        _clearInterval: {
	            value: function _clearInterval() {
	                if (angular.isDefined(this.addonsAnimation)) {
	                    this.$interval.cancel(this.addonsAnimation);
	                    this.addonsAnimation = undefined;
	                }
	            }
	        },
	        _move1: {
	            value: function _move1() {
	                var _this = this;

	                var time = arguments[0] === undefined ? 5000 : arguments[0];

	                this._clearInterval();
	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile:hover").length > 0) return false;
	                    _this.addonNextButton();
	                }, time);
	                console.log("%cSwitched to move 1 at a time", this.logColor);
	            }
	        },
	        _move3: {
	            value: function _move3() {
	                var _this = this;

	                var time = arguments[0] === undefined ? 5000 : arguments[0];

	                this._clearInterval();
	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile").is(":animated") || $(".addon-tile:hover").length > 0) return false;
	                    var addonItems = $(".addon-tile:nth-child(-n+3)");
	                    addonItems.eq(0).animate({ "margin-left": -_this.tileWidth * 3 }, 250 * 3);
	                    _this.$timeout(function () {
	                        addonItems.insertAfter($(".addon-tile").last());
	                        $(".addon-tile").css("margin-left", "");
	                    }, 250 * 3);
	                }, time);
	                console.log("%cSwitched to move 3 at a time", this.logColor);
	            }
	        },
	        _moveAll: {
	            value: function _moveAll() {
	                var _this = this;

	                var time = arguments[0] === undefined ? 5000 : arguments[0];

	                this._clearInterval();

	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile").is(":animated") || $(".addon-tile:hover").length > 0) return false;
	                    var addonItems = $(".addon-tile:nth-child(-n+" + _this.numberOfItemsInLine + ")");
	                    addonItems.eq(0).animate({ "margin-left": -_this.tileWidth * _this.numberOfItemsInLine }, 250 * _this.numberOfItemsInLine);
	                    _this.$timeout(function () {
	                        addonItems.insertAfter($(".addon-tile").last());
	                        $(".addon-tile").css("margin-left", "");
	                    }, 250 * _this.numberOfItemsInLine);
	                }, time);

	                console.log("%cSwitched to move all the line at a time", this.logColor);
	            }
	        },
	        onMouseWheel: {
	            value: function onMouseWheel($event, $delta, $deltaX, $deltaY) {
	                $event.preventDefault();

	                if ($deltaX !== 0) {
	                    if (this.lastDeltaX !== undefined && Math.abs($deltaX) <= this.lastDeltaX) {
	                        this.lastDeltaX = Math.abs($deltaX);
	                        return;
	                    } else {
	                        this.lastDeltaX = Math.abs($deltaX);
	                    }
	                }

	                if ($deltaX < 0) {
	                    this.addonPrevButton();
	                } else if ($deltaX > 0) {
	                    this.addonNextButton();
	                } else if ($delta > 0) {
	                    this.addonPrevButton();
	                } else if ($delta < 0) {
	                    this.addonNextButton();
	                }
	            }
	        }
	    });

	    return AddonsController;
	})();

/***/ }),
/* 342 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var LinksController = exports.LinksController = (function () {
	    function LinksController(GoogleAnalytics) {
	        _classCallCheck(this, LinksController);

	        this.GoogleAnalytics = GoogleAnalytics;

	        this.links = [{
	            linkText: "User Guide",
	            "class": "user-guide",
	            url: "https://service.jfrog.org/artifactory/home/userguide",
	            svg: "images/userguide.216.svg"
	        }, {
	            linkText: "Webinar Signup",
	            "class": "webinar",
	            url: "https://service.jfrog.org/artifactory/home/webinars",
	            svg: "images/webinar.216.svg"
	        }, {
	            linkText: "Support Portal",
	            "class": "support",
	            url: "https://service.jfrog.org/artifactory/home/supportportal",
	            svg: "images/support.216.svg"
	        }, {
	            linkText: "Stackoverflow",
	            "class": "stackoverflow",
	            url: "https://service.jfrog.org/artifactory/home/stackoverflow",
	            svg: "images/stackoverflow.216.svg"
	        }, {
	            linkText: "Blog",
	            "class": "blogs",
	            url: "https://service.jfrog.org/artifactory/home/blog",
	            svg: "images/blogs.216.svg"
	        }, {
	            linkText: "Rest API",
	            "class": "rest-api",
	            url: "https://service.jfrog.org/artifactory/home/restapi",
	            svg: "images/rest_api.216.svg"
	        }];
	    }

	    _createClass(LinksController, {
	        linkClick: {
	            value: function linkClick(linkText) {
	                this.GoogleAnalytics.trackEvent("Homepage", "Knowledge Resources Link", linkText);
	            }
	        }
	    });

	    return LinksController;
	})();

/***/ }),
/* 343 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var MostDownloadedController = exports.MostDownloadedController = (function () {
	    function MostDownloadedController(HomePageDao, $timeout, ArtifactoryDeployModal, GoogleAnalytics) {
	        _classCallCheck(this, MostDownloadedController);

	        this.homePageDao = HomePageDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.deployModal = ArtifactoryDeployModal;
	        this.data = {};
	        this.getData(false);
	    }

	    _createClass(MostDownloadedController, {
	        getData: {
	            value: function getData(force) {
	                var _this = this;

	                this.mostDownloaded;
	                this.homePageDao.get({ widgetName: "mostDownloaded", force: force }).$promise.then(function (data) {
	                    data.widgetData.mostDownloaded.forEach(function (item) {
	                        item.name = item.path.substr(item.path.lastIndexOf("/") + 1);
	                    });
	                    _this.data = data.widgetData;
	                    _this.mostDownloaded = true;
	                    if (_this.mostDownloaded) {
	                        _this.$widgetObject.showSpinner = false;
	                    }
	                });

	                this.dateTime = new Date().getTime();
	            }
	        },
	        refresh: {
	            value: function refresh() {
	                this.$widgetObject.showSpinner = true;
	                this.getData(true);
	            }
	        },
	        itemClick: {
	            value: function itemClick() {
	                this.GoogleAnalytics.trackEvent("Homepage", "Most downloaded item click");
	            }
	        }
	    });

	    return MostDownloadedController;
	})();

/***/ }),
/* 344 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var LastDeployedController = exports.LastDeployedController = (function () {
	    function LastDeployedController(HomePageDao, $timeout, ArtifactoryDeployModal, GoogleAnalytics) {
	        _classCallCheck(this, LastDeployedController);

	        this.homePageDao = HomePageDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.deployModal = ArtifactoryDeployModal;
	        this.data = {};
	        this.getData();
	    }

	    _createClass(LastDeployedController, {
	        getData: {
	            value: function getData() {
	                var _this = this;

	                this.lastDeployed;

	                this.homePageDao.get({ widgetName: "latestBuilds" }).$promise.then(function (data) {
	                    _this.data = data.widgetData;
	                    _this.lastDeployed = true;
	                    if (_this.lastDeployed) {
	                        _this.$widgetObject.showSpinner = false;
	                    }
	                });
	                this.dateTime = new Date().getTime();
	            }
	        },
	        refresh: {
	            value: function refresh() {
	                this.$widgetObject.showSpinner = true;
	                this.getData();
	            }
	        },
	        itemClick: {
	            value: function itemClick() {
	                this.GoogleAnalytics.trackEvent("Homepage", "Last deployed item click");
	            }
	        }
	    });

	    return LastDeployedController;
	})();

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var fieldOptions = _interopRequire(__webpack_require__(163));

	var SetMeUpWidgetController = exports.SetMeUpWidgetController = (function () {
	    function SetMeUpWidgetController(TreeBrowserDao, SetMeUpModal, JFrogEventBus, ArtifactoryState, GoogleAnalytics) {
	        var _this = this;

	        _classCallCheck(this, SetMeUpWidgetController);

	        this.treeBrowserDao = TreeBrowserDao;
	        this.ArtifactoryState = ArtifactoryState;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.SetMeUpModal = SetMeUpModal;

	        var EVENTS = JFrogEventBus.getEventsDefinition();

	        JFrogEventBus.register(EVENTS.REFRESH_SETMEUP_WIZARD, function () {
	            _this.$widgetObject.showSpinner = true;
	            _this.getRepos();
	        });

	        this.packageTypes = _.cloneDeep(fieldOptions.repoPackageTypes);
	        this.getRepos();
	    }

	    _createClass(SetMeUpWidgetController, {
	        getRepos: {
	            value: function getRepos() {
	                var _this = this;

	                this.treeBrowserDao.getRoots(true).then(function (repos) {
	                    var repoOrder = _this.ArtifactoryState.getState("repoOrder");
	                    var repoScore = _this._getScoreObjectFromOrderArray(repoOrder || ["DISTRIBUTION", "LOCAL", "REMOTE", "VIRTUAL"]);

	                    _this.repos = _.map(_.filter(repos, function (repo) {
	                        return repo.repoType !== "trash" && repo.repoType !== "distribution";
	                    }), function (repo) {
	                        var packageType = _.find(_this.packageTypes, { serverEnumName: repo.repoPkgType });
	                        if (packageType) repo.icon = packageType.icon;
	                        return repo;
	                    });

	                    _this.repos = _this.filterCacheDoubles(_this.repos);

	                    _this.repos = _.sortBy(_this.repos, function (repo) {
	                        return -repoScore[repo.repoType];
	                    });

	                    _this.$widgetObject.showSpinner = false;
	                });
	            }
	        },
	        filterCacheDoubles: {
	            value: function filterCacheDoubles(repos) {
	                var DASH_CACHE = "-cache";
	                var cacheRepos = _.filter(repos, function (repo) {
	                    return _.contains(repo.repoKey, DASH_CACHE);
	                });

	                cacheRepos.forEach(function (repo) {
	                    var remoteRepoKey = repo.repoKey.substr(0, repo.repoKey.length - DASH_CACHE.length);
	                    var remote = _.find(repos, { repoKey: remoteRepoKey });
	                    if (remote) {
	                        //We have a double, just remove the cached one from array
	                        repos.splice(repos.indexOf(repo), 1);
	                    } else {
	                        //We have only cache repo, change it's name to not include '-cache'
	                        repo.repoKey = remoteRepoKey;
	                    }
	                });

	                return repos;
	            }
	        },
	        showSetMeUp: {
	            value: function showSetMeUp(repo) {
	                this.GoogleAnalytics.trackEvent("Homepage", "Quick set me up", repo.repoPkgType, null, repo.repoType);
	                this.SetMeUpModal.launch(repo, true);
	            }
	        },
	        _getScoreObjectFromOrderArray: {
	            value: function _getScoreObjectFromOrderArray(order) {
	                var repoScore = {};
	                var score = 100000;
	                order.forEach(function (repoType) {
	                    repoScore[repoType.toLowerCase()] = score;
	                    if (repoType === "REMOTE") {
	                        repoScore.cached = score;
	                        score = score / 10;
	                    }
	                    score = score / 10;
	                });
	                return repoScore;
	            }
	        },
	        filterHasNoMatches: {
	            value: function filterHasNoMatches() {
	                var _this = this;

	                if (!this.repoFilter) {
	                    return false;
	                }var count = _.filter(this.repos, function (repo) {
	                    return _.contains(repo.repoKey, _this.repoFilter);
	                }).length;
	                return count === 0;
	            }
	        }
	    });

	    return SetMeUpWidgetController;
	})();

/***/ }),
/* 346 */
/***/ (function(module, exports) {

	"use strict";

	function oauthErrorConfig($stateProvider) {

	    $stateProvider.state("oauth_error", {
	        url: "/oauth_error",
	        parent: "app-layout" });
	}

	module.exports = angular.module("oauth_error", []).config(oauthErrorConfig);

/***/ }),
/* 347 */
/***/ (function(module, exports) {

	"use strict";

	function notFound404($stateProvider) {

	    $stateProvider.state("not_found_404", {
	        url: "/404",
	        templateUrl: "states/not_found_404/not_found_404.html",
	        parent: "app-layout" });
	}

	module.exports = angular.module("not_found_404", []).config(notFound404);

/***/ }),
/* 348 */
/***/ (function(module, exports) {

	"use strict";

	function forbidden403($stateProvider) {

	    $stateProvider.state("forbidden_403", {
	        url: "/403",
	        templateUrl: "states/forbidden_403/forbidden_403.html",
	        parent: "app-layout" });
	}

	module.exports = angular.module("forbidden_403", []).config(forbidden403);

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var LoginController = __webpack_require__(350).LoginController;

	function loginCOnfig($stateProvider) {
	    $stateProvider.state("login", {
	        url: "/login",
	        templateUrl: "states/login/login.html",
	        controller: "LoginController as Login",
	        params: { oauthError: null },
	        parent: "login-layout"
	    });
	}

	module.exports = angular.module("changePassword", []).config(loginCOnfig).controller("LoginController", LoginController);

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var LoginController = exports.LoginController = (function () {
	    function LoginController($state, $timeout, FooterDao, $stateParams, User, $location, $window, ArtifactoryState, JFrogEventBus, JFrogNotifications, ArtifactoryFeatures, OnBoardingWizard) {
	        var _this = this;

	        _classCallCheck(this, LoginController);

	        this.user = {};
	        this.rememberMe = false;
	        this.UserService = User;
	        this.$state = $state;
	        this.$window = $window;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.$location = $location;
	        this.ArtifactoryState = ArtifactoryState;
	        this.ArtifactoryFeatures = ArtifactoryFeatures;
	        this.OnBoardingWizard = OnBoardingWizard;
	        this.FooterDao = FooterDao;
	        this.$timeout = $timeout;
	        this.canResetPassword = false;
	        this.canRememberMe = false;
	        this.loginForm = null;
	        this.pending = false;

	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.canExit = User.currentUser.name !== "anonymous" || User.currentUser.anonAccessEnabled;

	        this.oauth = {};
	        User.getOAuthLoginData().then(function (response) {
	            _this.oauth.providers = response;
	        });

	        if ($stateParams.oauthError) this.errorMessage = $stateParams.oauthError;

	        this.checkResetPassword();
	    }

	    _createClass(LoginController, {
	        login: {
	            value: function login() {

	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);

	                if (this.loginForm.$valid && !this.pending) {
	                    this.pending = true;
	                    this.UserService.login(this.user, this.rememberMe).then(success.bind(this), error.bind(this));
	                }

	                function success(result) {
	                    var _this = this;

	                    this.pending = false;
	                    var urlAfterLogin = this.ArtifactoryState.getState("urlAfterLogin");

	                    var aolOnboarding = this.ArtifactoryState.getState("aolOnboarding");

	                    this.ArtifactoryState.setState("clearErrorsOnStateChange", true);

	                    if (aolOnboarding) {
	                        this.ArtifactoryState.setState("onboarding", undefined);
	                        this.OnBoardingWizard.isSystemOnboarding().then(function (onBoarding) {
	                            if (onBoarding) {
	                                _this.$state.go("home").then(function () {
	                                    return _this.OnBoardingWizard.show();
	                                });
	                            } else {
	                                if (urlAfterLogin) {
	                                    _this.$location.path(urlAfterLogin);
	                                } else {
	                                    _this.$state.go("home");
	                                }
	                            }
	                        });
	                    } else {
	                        this.OnBoardingWizard.setInitStatus();
	                        if (urlAfterLogin) {
	                            this.$location.path(urlAfterLogin);
	                        } else {
	                            this.$state.go("home");
	                        }
	                    }
	                }

	                function error(response) {
	                    this.pending = false;
	                    if (response.data) {
	                        if (!this.catchExpired(response)) {
	                            this.errorMessage = response.data.error;
	                        }
	                    }
	                }
	            }
	        },
	        isLoggedIn: {
	            /**
	             * Check if already logged in
	             * */

	            value: function isLoggedIn() {
	                return this.UserService.getCurrent().isLoggedIn();
	            }
	        },
	        logOut: {

	            /**
	             * Logout is dispatching an event.
	             * The handler also checks if the current state is one of the admin states.
	             * This is done in order to make sure that logout happens only after all open admin states (windows) are closed.
	             * Otherwise the user could be stuck with an unresponsive screen.
	             * */

	            value: function logOut() {
	                this.JFrogEventBus.dispatch(EVENTS.USER_LOGOUT, "logoutAndLogin");
	            }
	        },
	        goHome: {

	            /**
	             * Go to home state
	             * */

	            value: function goHome() {
	                this.UserService.$state.go("home");
	            }
	        },
	        catchExpired: {
	            value: function catchExpired(response) {
	                var code = "CREDENTIALS_EXPIRED";
	                if (response.data && response.data.code && response.data.code === code) {
	                    var msg = response.data.feedbackMsg.error;
	                    if (response.data.profileUpdatable) {
	                        this.$state.go("change-password", { username: this.user.user });
	                    } else {
	                        msg += ".\nPlease contact your system administrator.";
	                        this.artifactoryNotifications.create({ error: msg });
	                    }
	                    return true;
	                }
	                return false;
	            }
	        },
	        userPasswordChanged: {
	            value: function userPasswordChanged() {
	                this.errorMessage = null;
	            }
	        },
	        checkResetPassword: {
	            value: function checkResetPassword() {
	                var _this = this;

	                this.UserService.getLoginData().then(function (response) {
	                    _this.canResetPassword = response.forgotPassword;
	                    _this.canRememberMe = response.canRememberMe;
	                    _this.ssoProviderLink = response.ssoProviderLink;
	                    _this.oauthProviderLink = response.oauthProviderLink;
	                });
	            }
	        },
	        gotoForgotPwd: {
	            value: function gotoForgotPwd() {
	                this.$state.go("forgot-password");
	            }
	        },
	        ssoLogin: {

	            /*
	                oauthLogin() {
	                    this.$window.open(this.oauthProviderLink,'_self');
	                }
	            */

	            value: function ssoLogin() {
	                this.$window.open(this.ssoProviderLink, "_self");
	            }
	        },
	        isOAuthEnabled: {
	            value: function isOAuthEnabled() {
	                return this.oauth.providers && this.oauth.providers.length > 0;
	            }
	        },
	        onGotoOAuth: {
	            value: function onGotoOAuth() {
	                localStorage.stateBeforeOAuth = this.$state.current.name;
	            }
	        }
	    });

	    return LoginController;
	})();

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var ChangePasswordController = __webpack_require__(352).ChangePasswordController;

	function changePasswordConfig($stateProvider) {
	    $stateProvider.state("change-password", {
	        url: "/change-password",
	        templateUrl: "states/change_password/change_password.html",
	        controller: "ChangePasswordController as ChangePassword",
	        parent: "login-layout",
	        params: { username: "" } });
	}

	module.exports = angular.module("login", []).config(changePasswordConfig).controller("ChangePasswordController", ChangePasswordController);

/***/ }),
/* 352 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var ChangePasswordController = exports.ChangePasswordController = (function () {
	    function ChangePasswordController(UserDao, $state, $stateParams) {
	        _classCallCheck(this, ChangePasswordController);

	        this.$state = $state;
	        this.userDao = UserDao.getInstance();
	        this.fields = {};
	        this.username = $stateParams.username;
	    }

	    _createClass(ChangePasswordController, {
	        passwordsMatch: {
	            value: function passwordsMatch() {
	                return this.fields.newPassword === this.fields.retypeNewPassword;
	            }
	        },
	        change: {
	            value: function change() {
	                var _this = this;

	                this.userDao.changePassword({}, {
	                    userName: this.username,
	                    oldPassword: this.fields.oldPassword,
	                    newPassword1: this.fields.newPassword,
	                    newPassword2: this.fields.retypeNewPassword
	                }).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this.$state.go("login");
	                    }
	                });
	            }
	        }
	    });

	    return ChangePasswordController;
	})();

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var ForgotPasswordController = __webpack_require__(354).ForgotPasswordController;

	var ResetPasswordController = __webpack_require__(355).ResetPasswordController;

	function forgotPasswordConfig($stateProvider) {
	    $stateProvider.state("forgot-password", {
	        url: "/forgot-password",
	        templateUrl: "states/forgot_password/forgot_password.html",
	        controller: "ForgotPasswordController as ForgotPassword",
	        parent: "login-layout"
	    }).state("reset-password", {
	        url: "/resetpassword?key",
	        templateUrl: "states/forgot_password/reset_password.html",
	        controller: "ResetPasswordController as ResetPassword",
	        parent: "login-layout"
	    });
	}

	module.exports = angular.module("forgotPassword", []).config(forgotPasswordConfig).controller("ForgotPasswordController", ForgotPasswordController).controller("ResetPasswordController", ResetPasswordController);

/***/ }),
/* 354 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var EMAIL_SENT_MESSAGE = "Reset password email was sent. \nDidn't received it? Contact your system administrator.";

	var ForgotPasswordController = exports.ForgotPasswordController = (function () {
	    function ForgotPasswordController($state, User, JFrogNotifications, JFrogEventBus) {
	        _classCallCheck(this, ForgotPasswordController);

	        this.user = {};
	        this.UserService = User;
	        this.$state = $state;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.forgotPasswordForm = null;
	        this.message = "";
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }

	    _createClass(ForgotPasswordController, {
	        forgot: {
	            value: function forgot() {
	                var self = this;

	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);
	                if (this.forgotPasswordForm.$valid) {
	                    this.pending = true;
	                    this.UserService.forgotPassword(this.user).then(success, error);
	                } else {
	                    form.user.$dirty = true;
	                }

	                function success(result) {
	                    self.pending = false;
	                    self.$state.go("login");
	                    self.artifactoryNotifications.create({ info: EMAIL_SENT_MESSAGE });
	                }

	                function error(errors) {
	                    self.pending = false;
	                    self.$state.go("login");
	                }
	            }
	        }
	    });

	    return ForgotPasswordController;
	})();

/***/ }),
/* 355 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var PASSWORD_CHANGED_MESSAGE = "Password changed successfully";

	var ResetPasswordController = exports.ResetPasswordController = (function () {
	    function ResetPasswordController($stateParams, User, $state, JFrogNotifications, JFrogEventBus, $timeout) {
	        _classCallCheck(this, ResetPasswordController);

	        this.$stateParams = $stateParams;
	        this.userService = User;
	        this.$state = $state;
	        this.key = $stateParams.key;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.ResetPasswordForm = null;
	        this.$timeout = $timeout;
	        this.user = {};
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }

	    _createClass(ResetPasswordController, {
	        resetPassword: {
	            value: function resetPassword() {
	                var self = this;

	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);

	                if (this.ResetPasswordForm.$valid) {
	                    this.userService.validateKey(this.key).then(success, error);
	                }

	                function success(response) {
	                    if (response.data.user) {
	                        self.user.user = response.data.user;
	                        self.userService.resetPassword(self.key, self.user).then(function (response) {
	                            self.artifactoryNotifications.create(response.data);
	                            self.$state.go("login");
	                        });
	                    }
	                }

	                function error(errors) {
	                    if (errors.data.error) {
	                        self.artifactoryNotifications.create({ error: errors.data.error });
	                    }
	                }
	            }
	        },
	        checkMatchingPasswords: {
	            value: function checkMatchingPasswords() {
	                var _this = this;

	                this.$timeout(function () {
	                    if (_this.ResetPasswordForm.password.$valid && _this.ResetPasswordForm.repeatPassword.$valid) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION);
	                    }
	                });
	            }
	        }
	    });

	    return ResetPasswordController;
	})();

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var UserProfileController = __webpack_require__(357).UserProfileController;

	function config($stateProvider) {

	    $stateProvider.state("user_profile", {
	        url: "/profile",
	        parent: "app-layout",
	        templateUrl: "states/user_profile/user_profile.html",
	        controller: "UserProfileController as UserProfile"
	    });
	}

	module.exports = angular.module("user_profile", []).config(config).controller("UserProfileController", UserProfileController);

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var TOOLTIPS = _interopRequire(__webpack_require__(96));

	var UserProfileController = exports.UserProfileController = (function () {
	    function UserProfileController($state, $scope, UserProfileDao, ArtifactoryFeatures, BintrayDao, SshClientDao, JFrogNotifications, User, JFrogEventBus, ArtifactoryModelSaver, OAuthDao, JFrogGridFactory, JFrogModal, ArtifactoryState) {
	        var _this = this;

	        _classCallCheck(this, UserProfileController);

	        this.$scope = $scope;
	        this.$state = $state;
	        this.passwordRank = 0;
	        this.userProfileDao = UserProfileDao;
	        this.bintrayDao = BintrayDao.getInstance();
	        this.sshClientDao = SshClientDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.User = User;
	        this.currentUser = User.getCurrent();
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.OAuthDao = OAuthDao;
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["userInfo"], ["apiKey"]);
	        this.modal = JFrogModal;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();

	        this.userInfo = {};
	        this.currentPassword = null;
	        this.showUserApiKey = false;
	        this.showBintrayApiKey = false;
	        this.profileLocked = true;

	        this.tooltips = TOOLTIPS.userProfile;
	        this.artifactoryState = ArtifactoryState;
	        this.emailChanged = false;

	        // Reloading is necessary since the User object is cached,
	        // and once the session is over the data becomes deprecated
	        this.User.loadUser(true).then(function () {
	            if (_this.currentUser.name == "anonymous") {
	                $state.go("login");
	            }
	            $("body").addClass("load-complete");
	        });

	        if (this.User.currentUser.requireProfileUnlock === false && this.User.currentUser.existsInDB) {
	            this.unlock();
	        }
	    }

	    _createClass(UserProfileController, {
	        unlock: {
	            value: function unlock() {
	                var _this = this;

	                this.userProfileDao.fetch({ password: this.User.currentUser.requireProfileUnlock === true ? this.currentPassword : "" }).$promise.then(function (response) {
	                    _this.userInfo = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    //console.log(this.userInfo);
	                    _this.profileLocked = false;

	                    if (!_this.features.isOss()) {
	                        _this._initOAuthData();
	                    }

	                    _this._getApiKey();
	                });
	            }
	        },
	        _getApiKey: {
	            value: function _getApiKey() {
	                var _this = this;

	                this.userProfileDao.getApiKey().$promise.then(function (res) {
	                    _this.userInfo.apiKey = res.apiKey;
	                });
	            }
	        },
	        revokeApiKey: {
	            value: function revokeApiKey() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to revoke your API key?").then(function () {
	                    _this.userProfileDao.revokeApiKey().$promise.then(function (res) {
	                        _this._getApiKey();
	                    });
	                });
	            }
	        },
	        regenerateApiKey: {
	            value: function regenerateApiKey() {
	                var _this = this;

	                this.userProfileDao.regenerateApiKey().$promise.then(function (res) {
	                    if (res.apiKey) {
	                        _this.artifactoryNotifications.create({ info: "Successfully regenerated API key" });
	                        _this.userInfo.apiKey = res.apiKey;
	                    } else {
	                        _this.artifactoryNotifications.create({ error: "Failed to regenerate API key" });
	                    }
	                });
	            }
	        },
	        generateApiKey: {
	            value: function generateApiKey() {
	                var _this = this;

	                this.userProfileDao.getAndCreateApiKey().$promise.then(function (res) {
	                    if (res.apiKey) {
	                        _this.artifactoryNotifications.create({ info: "Successfully generated API key" });
	                        _this.userInfo.apiKey = res.apiKey;
	                    } else {
	                        _this.artifactoryNotifications.create({ error: "Failed to generate API key" });
	                    }
	                });
	            }
	        },
	        _initOAuthData: {
	            value: function _initOAuthData() {
	                var _this = this;

	                this.oauth = {};

	                this.User.getOAuthLoginData().then(function (response) {
	                    _this.oauth.providers = response;

	                    _this.OAuthDao.getUserTokens().$promise.then(function (data) {
	                        data.forEach(function (providerName) {
	                            var provider = _.findWhere(_this.oauth.providers, { name: providerName });
	                            if (provider) {
	                                provider.binded = true;
	                            }
	                        });
	                    });
	                });
	            }
	        },
	        unbindOAuthProvider: {
	            value: function unbindOAuthProvider(providerName) {
	                var _this = this;

	                this.OAuthDao.deleteUserToken({}, { username: this.currentUser.name, provider: providerName }).$promise.then(function (res) {
	                    _this._initOAuthData();
	                });
	            }
	        },
	        onEmailChanged: {
	            value: function onEmailChanged() {
	                this.emailChanged = true;
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;

	                if (this.userInfo.user.newPassword && this.userInfo.user.newPassword !== this.userInfo.user.retypePassword) {
	                    this.artifactoryNotifications.create({ error: "Passwords do not match" });
	                    return;
	                }

	                var params = {
	                    user: {
	                        email: this.userInfo.user.email,
	                        password: this.userInfo.user.newPassword
	                    },
	                    bintray: this.userInfo.bintray,
	                    ssh: this.userInfo.ssh
	                };

	                if (this.emailChanged) {
	                    this.artifactoryState.removeState("setMeUpUserData");
	                }

	                this.userProfileDao.update(params).$promise.then(function () {
	                    _this.changePassword = false;
	                    _this.clearPasswordFields();
	                    _this.User.reload();
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        clearPasswordFields: {
	            value: function clearPasswordFields() {
	                delete this.userInfo.user.newPassword;
	                delete this.userInfo.user.retypePassword;
	            }
	        },
	        testBintray: {
	            value: function testBintray() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, this.bintrayForm.$name);
	                this.bintrayDao.fetch(this.userInfo.bintray);
	            }
	        },
	        isOAuthEnabled: {
	            value: function isOAuthEnabled() {
	                return this.oauth && this.oauth.providers && this.oauth.providers.length > 0 && this.userInfo.user.realm === "internal";
	            }
	        },
	        onGotoOAuth: {
	            value: function onGotoOAuth() {
	                localStorage.stateBeforeOAuth = this.$state.current.name;
	            }
	        }
	    });

	    return UserProfileController;
	})();

/***/ }),
/* 358 */
/***/ (function(module, exports) {

	/**
	 * Created by tomere on 16/03/2017.
	 */

	"use strict";

	function config($stateProvider) {

	    $stateProvider.state("server_error_5XX", {
	        templateUrl: "states/server_error_5XX/server_error_5XX.html",
	        parent: "app-layout" });
	}

	module.exports = angular.module("server_error_5XX", []).config(config);

/***/ }),
/* 359 */
/***/ (function(module, exports) {

	"use strict";

	function config($stateProvider) {

	    $stateProvider.state("server_down", {
	        templateUrl: "states/server_down/server_down.html"
	    });
	}

	module.exports = angular.module("server_down", []).config(config);

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var BaseController = __webpack_require__(361).BaseController;

	function baseConfig($stateProvider) {
	    $stateProvider
	    // Base state for all application states
	    .state("app-layout", {
	        url: "",
	        abstract: true,
	        templateUrl: "layouts/application.html",
	        controller: "BaseController as Base"
	    })
	    // Base state for all login related states (login, forgot password, etc.)
	    .state("login-layout", {
	        url: "",
	        abstract: true,
	        templateUrl: "layouts/login.html"
	    });
	}

	module.exports = angular.module("base.module", []).config(baseConfig).controller("BaseController", BaseController);

/***/ }),
/* 361 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var BaseController = exports.BaseController = (function () {
	    function BaseController(FooterDao, ArtifactorySidebarDriver, $timeout) {
	        _classCallCheck(this, BaseController);

	        this.FooterDao = FooterDao;
	        this.$timeout = $timeout;

	        this.getFooterData();

	        this.sidebarDriver = ArtifactorySidebarDriver;
	    }

	    _createClass(BaseController, {
	        getFooterData: {
	            value: function getFooterData() {
	                var _this = this;

	                var force = arguments[0] === undefined ? false : arguments[0];

	                // Ensure page is not displayed before we get the footer data
	                this.FooterDao.get(force).then(function (footerData) {
	                    return _this.footerData = footerData;
	                });

	                // Check that we have the footer data, solve RTFACT-13069 (Happens inconsistently when restarting server / starting vanilla)
	                this.$timeout(function () {
	                    if (!_this.footerData) {
	                        _this.getFooterData(true);
	                    }
	                }, 100);
	            }
	        }
	    });

	    return BaseController;
	})();

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var SearchStateController = __webpack_require__(363).SearchStateController;

	var searchQueryMaker = __webpack_require__(364).searchQueryMaker;

	var packageSearch = __webpack_require__(366).packageSearch;

	function searchConfig($stateProvider) {
	    $stateProvider.state("search", {
	        url: "/search/{searchType}/{query}",
	        parent: "app-layout",
	        templateUrl: "states/search/search.html",
	        controller: "SearchStateController as SearchController",
	        params: { oauthError: null, fromHome: false } });
	}

	module.exports = angular.module("search", []).config(searchConfig).directive("searchQueryMaker", searchQueryMaker).directive("packageSearch", packageSearch).controller("SearchStateController", SearchStateController);

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var EVENTS = _interopRequire(__webpack_require__(48));

	var TOOLTIP = _interopRequire(__webpack_require__(96));

	var SearchStateController = exports.SearchStateController = (function () {
	    function SearchStateController($q, $state, $scope, $window, $stateParams, $compile, $timeout, JFrogNotifications, uiGridConstants, commonGridColumns, ArtifactSearchDao, ArtifactPackageSearchDao, JFrogModal, JFrogGridFactory, FooterDao, RepositoriesDao, ArtifactActions, RepoDataDao, ArtifactActionsDao, SetMeUpDao, User, UserProfileDao, JFrogEventBus, $injector, StashResultsDao, GoogleAnalytics) {
	        var _this = this;

	        _classCallCheck(this, SearchStateController);

	        this.$q = $q;
	        this.inject = $injector.get;
	        this.modal = JFrogModal;
	        this.artifactSearchDao = ArtifactSearchDao;
	        this.stashResultsDao = StashResultsDao;
	        this.repositoriesDao = RepositoriesDao;
	        this.notifications = JFrogNotifications;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$window = $window;
	        this.$timeout = $timeout;
	        this.$compile = $compile;
	        this.$stateParams = $stateParams;
	        this.title = "Search Artifacts";
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.actions = ArtifactActions;
	        this.repoDataDao = RepoDataDao;
	        this.footerDao = FooterDao;
	        this.userProfileDao = UserProfileDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.artifactPackageSearchDao = ArtifactPackageSearchDao;
	        this.setMeUpDao = SetMeUpDao;
	        this.options = ["quick", "package", "archive", "property", "checksum", "remote", "trash"];
	        this.currentSearch = this.$stateParams.searchType || localStorage.lastSearchType || "quick";
	        this.resultsMsg = "Search Results";
	        this.TOOLTIP = TOOLTIP.artifacts.search;
	        this.gridOptions = {};
	        this.repoList = [];
	        this.query = this.$stateParams.query ? JSON.parse(atob(this.$stateParams.query)) : {};

	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.refreshRepoList();
	        });

	        this.packageTypesDefer = $q.defer();
	        this._initSearch();

	        if (localStorage.lastSearchType === "package") {
	            this.packageTypesDefer.promise.then(function () {
	                if (localStorage.lastPackageSearch) {
	                    var packageType = _.find(_this.availablePackageTypes, { id: localStorage.lastPackageSearch });
	                    _this.selectedPackageType = packageType;
	                }
	                _this.onPackageTypeChange();
	            });
	        }

	        //Check if Trash Can search should be available
	        this.currentUser = User.getCurrent();
	        var trashDisabled = this.footerDao.get().then(function (footerData) {
	            if (footerData.trashDisabled || !_this.currentUser.isAdmin()) {
	                _this.options.pop();
	                if (_this.currentSearch === "trash") _this.currentSearch = "quick";
	            }
	        });

	        //Check if jCenter is configured
	        this.repositoriesDao.isJcenterRepoConfigured().$promise.then(function () {
	            return _this.isJcenterExists = true;
	        }, function () {
	            return _this.isJcenterExists = false;
	        });

	        // init the query when the search type change
	        $scope.$watch(function () {
	            return _this.currentSearch;
	        }, function () {

	            _this.updateUrl();
	            localStorage.lastSearchType = _this.currentSearch;

	            if (_this.currentSearch === "package") {
	                _this._createPackageSearchColumnsObject();

	                //Focus on the package type dropdown
	                _this.$timeout(function () {
	                    var e = angular.element($(".package-type-selection").children(".ui-select-container")[0]);
	                    var c = e.controller("uiSelect");
	                    c.focusser[0].focus();

	                    _this.onPackageTypeChange();
	                });
	            } else {
	                if (_this.query.selectedPackageType) {
	                    delete _this.query.selectedPackageType;
	                    _this.updateUrl();
	                }
	                _this.refreshGrid();
	            }
	        });

	        this._updateStashStatus();
	    }

	    _createClass(SearchStateController, {
	        updateUrl: {
	            value: function updateUrl() {
	                var queryClone = _.cloneDeep(this.query);
	                delete queryClone.search;
	                this.$state.transitionTo(".", { searchType: this.currentSearch, query: !_.isEmpty(queryClone) ? btoa(JSON.stringify(this.query)) : "" }, { location: this.$stateParams.searchType ? true : "replace", inherit: true, relative: this.$state.$current, notify: false });
	            }
	        },
	        search: {
	            value: function search() {
	                var _this = this;

	                this.lastQuery = _.cloneDeep(this.query);
	                this.updateUrl();
	                this._trackGaEvent(this.currentSearch);
	                if (this.currentSearch === "package" && this.query.search !== "gavc") {
	                    var repos = _.find(this.query.packagePayload, { id: "repo" });
	                    if (repos && repos.values && repos.values.length === 0) {
	                        this.notifications.create({ warn: "Select at least one repository to search" });
	                    } else {
	                        this.artifactPackageSearchDao.runQuery({}, this._getQueryWithImplicitWildCard(this.query.packagePayload)).$promise.then(function (result) {
	                            result = result.data;

	                            _.map(result.results, function (result) {
	                                if (result.extraFields) {
	                                    for (var key in result.extraFields) {
	                                        result["extraField_" + key] = result.extraFields[key].join(", ");
	                                    }
	                                    delete result.extraFields;
	                                }
	                            });

	                            _this.resultsMsg = result.message;
	                            _this.gridOptions.setGridData(result.results);
	                            _this.results = result.results;
	                            _this.savedToStash = false;
	                            if (result.searchExpression) {
	                                _this.cleanAql = result.searchExpression;
	                                _this._updateAQL();
	                                _this.showAQL = false;
	                                _this.$timeout(function () {
	                                    var showAqlButtonElem = $("#show-aql-button-orig");
	                                    var aqlViewerElem = $("#aql-viewer-orig").clone();
	                                    var gridFilterElem = $("jf-grid-filter");
	                                    var gridActionElem = $(".wrapper-grid-actions");
	                                    var clone = showAqlButtonElem.clone();
	                                    clone.attr("id", "show-aql-button");
	                                    aqlViewerElem.attr("id", "aql-viewer");
	                                    gridFilterElem.append(clone);
	                                    clone.css("display", "block");
	                                    _this.$compile(clone)(_this.$scope);

	                                    gridActionElem.after(aqlViewerElem);
	                                    aqlViewerElem.css("display", "block");
	                                    var clipCopyElement = aqlViewerElem.find("jf-clip-copy");
	                                    clipCopyElement.addClass("code-mirror-copy");
	                                    _this.$compile(aqlViewerElem)(_this.$scope);
	                                });
	                            }
	                        });
	                    }
	                } else {
	                    (function () {
	                        var payloadQuery = _.cloneDeep(_this.query);
	                        if (_this.currentSearch === "property") {
	                            if (payloadQuery.propertySetKeyValues) {
	                                if (!payloadQuery.propertyKeyValues) payloadQuery.propertyKeyValues = [];
	                                payloadQuery.propertySetKeyValues.forEach(function (propSet) {
	                                    payloadQuery.propertyKeyValues.push(propSet);
	                                });
	                                delete payloadQuery.propertySetKeyValues;
	                            }
	                        } else if (_this.currentSearch === "trash") {
	                            payloadQuery.isChecksum = payloadQuery.isChecksum || false;
	                        }

	                        if (payloadQuery.selectedRepositories && payloadQuery.selectedRepositories.length == 0) {
	                            _this.notifications.create({ warn: "Select at least one repository to search" });
	                            _this.resultsMsg = "Search Results";
	                            _this.gridOptions.setGridData([]);
	                            _this.results = [];
	                        } else {
	                            _this.artifactSearchDao.fetch(_this._getQueryWithImplicitWildCard(payloadQuery)).$promise.then(function (result) {
	                                _this.resultsMsg = result.data.message;
	                                _this.gridOptions.setGridData(result.data.results);
	                                _this.results = result.data.results;
	                                _this.savedToStash = false;
	                            });
	                        }
	                    })();
	                }
	            }
	        },
	        reSearch: {
	            value: function reSearch() {
	                this.query = this.lastQuery;
	                this.search();
	            }
	        },
	        _getQueryWithImplicitWildCard: {
	            value: function _getQueryWithImplicitWildCard(query) {

	                var getNewVal = function (oldVal) {

	                    if (!oldVal) return oldVal;

	                    oldVal = oldVal.trim();
	                    var newVal = undefined;
	                    if (oldVal.startsWith("\"") && oldVal.endsWith("\"")) {
	                        newVal = oldVal.substr(1, oldVal.length - 2);
	                    } else if (!oldVal.endsWith("*")) {
	                        newVal = oldVal + "*";
	                    } else {
	                        newVal = oldVal;
	                    }

	                    return newVal;
	                };

	                var newQuery = _.cloneDeep(query);

	                if (this.currentSearch === "package") {
	                    if (newQuery.search === "gavc") {
	                        newQuery.artifactID = getNewVal(newQuery.artifactID);
	                        newQuery.classifier = getNewVal(newQuery.classifier);
	                        newQuery.groupID = getNewVal(newQuery.groupID);
	                        newQuery.version = getNewVal(newQuery.version);
	                    } else {
	                        //standard package search, not gavc
	                        newQuery.forEach(function (cond) {
	                            if (cond.id !== "repo") {
	                                (function () {
	                                    var newVals = [];
	                                    cond.values.forEach(function (val) {
	                                        newVals.push(getNewVal(val));
	                                    });
	                                    cond.values = newVals;
	                                })();
	                            }
	                        });
	                    }
	                } else {
	                    for (var key in newQuery) {
	                        var val = newQuery[key];
	                        if (_.isString(val) && key !== "search") {
	                            if (!(key === "checksum" || this.currentSearch === "trash" && key === "query" && newQuery.isChecksum)) {
	                                newQuery[key] = getNewVal(val);
	                            }
	                        } else if (key === "propertyKeyValues" || key === "propertySetKeyValues") {
	                            val.forEach(function (prop) {
	                                if (prop.key) prop.key = getNewVal(prop.key);
	                                if (prop.values) {
	                                    for (var i in prop.values) {
	                                        prop.values[i] = getNewVal(prop.values[i]);
	                                    }
	                                }
	                            });
	                        }
	                    }
	                }

	                return newQuery;
	            }
	        },
	        _updateAQL: {
	            value: function _updateAQL() {
	                if (this.cleanAql) {
	                    this.aql = "curl -H 'Content-Type:text/plain' -H 'X-JFrog-Art-Api: " + (this.apiKey || "<YOUR_API_KEY>") + "' -X POST " + this.baseUrl + "/api/search/aql -d '\n" + this.cleanAql + "'";
	                }
	            }
	        },
	        _initSearch: {
	            value: function _initSearch(params) {
	                var _this = this;

	                this.artifactPackageSearchDao.availablePackages().$promise.then(function (data) {
	                    data = _.filter(data, function (packageType) {
	                        return !packageType.id.startsWith("docker") && (!_this.isOss || packageType.id === "gavc");
	                    });
	                    var i = 0;
	                    _.forEach(data, function () {
	                        if (data[i].displayName === "GAVC") {
	                            data[i].displayName = "Maven GAVC";
	                        }
	                        i++;
	                    });
	                    if (!_this.isOss) {
	                        data.unshift({
	                            id: "dockerV2",
	                            icon: "docker",
	                            displayName: "Docker"
	                        });
	                    }

	                    _this.availablePackageTypes = _.sortBy(data, function (pack) {
	                        return pack.displayName;
	                    });
	                    _this.packageTypesDefer.resolve();
	                });

	                if (!this.repoList.length) {
	                    this.refreshRepoList();
	                }

	                if (!this.propertiesOptions) this.getProperties();

	                if (params && params.params) {
	                    this.query = JSON.parse(atob(params.params));

	                    if (this.currentSearch === "package") {
	                        this.packageSearchColumns = this.query.columns;
	                    }
	                    this._getGridData();
	                } else {
	                    if (this.currentSearch === "package") {
	                        this.packageSearchColumns = ["artifact", "path", "repo", "modified"];
	                    }
	                }

	                //get set me up data (for baseUrl)
	                this.setMeUpDao.get().$promise.then(function (result) {
	                    _this.baseUrl = result.baseUrl;
	                    _this._updateAQL();
	                });

	                this.userProfileDao.getApiKey().$promise.then(function (res) {
	                    _this.apiKey = res.apiKey;
	                    _this._updateAQL();
	                });
	            }
	        },
	        refreshRepoList: {
	            value: function refreshRepoList() {
	                var _this = this;

	                //            let getFuncName = this.currentSearch === 'package' ? 'getForPackageSearch' : 'getForSearch';
	                ["getForSearch", "getForPackageSearch"].forEach(function (getFuncName) {
	                    _this.repoDataDao[getFuncName]().$promise.then(function (result) {
	                        result.repoTypesList = _.map(result.repoTypesList, function (repo) {
	                            repo._iconClass = "icon " + (repo.type === "local" ? "icon-local-repo" : repo.type === "remote" ? "icon-remote-repo" : repo.type === "virtual" ? "icon-virtual-repo" : repo.type === "distribution" ? "icon-distribution-repo" : "icon-notif-error");
	                            return repo;
	                        });

	                        var dists = _.filter(result.repoTypesList, function (repo) {
	                            return repo.type === "distribution";
	                        });
	                        var locals = _.filter(result.repoTypesList, function (repo) {
	                            return repo.type === "local";
	                        });
	                        var caches = _.filter(result.repoTypesList, function (repo) {
	                            return repo.type === "remote";
	                        });

	                        if (getFuncName === "getForSearch") _this.allRepoList = _.cloneDeep(_.union(dists, locals, caches));else if (getFuncName === "getForPackageSearch") _this.allPackageRepoList = _.cloneDeep(_.union(dists, locals, caches));

	                        var lastIncluded = _this.query.selectedRepositories || [];

	                        if (getFuncName === "getForSearch") {
	                            _this.repoList = _.filter(_this.allRepoList, function (repo) {
	                                return !_.find(lastIncluded, { repoKey: repo.repoKey });
	                            });
	                        } else if (getFuncName === "getForPackageSearch") {
	                            _this.packageRepoList = _.filter(_this.allPackageRepoList, function (repo) {
	                                return !_.find(lastIncluded, { repoKey: repo.repoKey });
	                            });
	                        }
	                    });
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.currentSearch === "package" && !this.packageSearchColumns) {
	                    return;
	                }if (this.currentSearch == "remote" || this.currentSearch == "archive") {
	                    this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);
	                } else {
	                    this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(this._getBatchActions()).setGridData([]);
	                }

	                this.gridOptions.isRowSelectable = function (row) {
	                    var notRepository = row.entity.relativeDirPath !== "[repo]";
	                    return notRepository && _.contains(row.entity.actions, "Delete");
	                };
	            }
	        },
	        refreshGrid: {
	            value: function refreshGrid() {
	                var _this = this;

	                var defer = this.$q.defer();

	                this.showGrid = false;
	                this.$timeout(function () {
	                    _this._createGrid();

	                    //This is for recalculating grid columns width
	                    _this.$timeout(function () {
	                        try {
	                            window.dispatchEvent(new Event("resize"));
	                        } catch (e) {
	                            var resizeEvent = document.createEvent("Event");
	                            resizeEvent.initEvent("resize", false, true);
	                            window.dispatchEvent(resizeEvent);
	                        }
	                        _this.$timeout(function () {
	                            _this.showGrid = true;
	                            _this.resultsMsg = "Search Results";
	                            defer.resolve();
	                        });
	                    });
	                });

	                return defer.promise;
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;

	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete(_this.currentSearch === "trash");
	                    }
	                }];
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete(permanent) {
	                var _this = this;

	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                permanent = permanent || this.footerDao.getInfo().trashDisabled;
	                //console.log(selectedRows);
	                // Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to " + (permanent ? " <span class=\"highlight-alert\">permanently</span> " : " ") + " delete " + selectedRows.length + " items?").then(function () {
	                    _this._deleteSingleSelected(selectedRows);
	                });
	            }
	        },
	        _deleteSingleSelected: {
	            value: function _deleteSingleSelected(rows) {
	                var _this = this;

	                //console.log(rows);
	                if (rows.length === this.results.length) {
	                    //To prevent console error (RTFACT-13554)
	                    this.gridOptions.api.grouping.clearGrouping();
	                }
	                var elementsToDelete = _.map(rows, function (row) {
	                    return {
	                        name: row.name,
	                        path: _this.currentSearch === "trash" ? ((row.originRepository + "/" + row.relativeDirPath).split("[root]").join("") + "/" + row.name).split("//").join("/") : row.relativePath,
	                        repoKey: row.repoKey
	                    };
	                });
	                this.artifactSearchDao["delete"]({ artifacts: elementsToDelete }).$promise.then(function () {})["finally"](function () {
	                    _this.reSearch();
	                    _this.artifactoryState.setState("refreshTreeNextTime", true);
	                });
	            }
	        },
	        _deleteSelected: {
	            value: function _deleteSelected(rows, permanent) {
	                var _this = this;

	                permanent = permanent || this.footerDao.getInfo().trashDisabled;
	                this.modal.confirm("Are you sure you wish to " + (permanent ? " <span class=\"highlight-alert\">permanently</span> " : " ") + " delete " + rows[0].name + "?").then(function () {
	                    return _this._deleteSingleSelected(rows);
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var _this = this;

	                switch (this.currentSearch) {
	                    case "package":
	                        {
	                            return this._getColumnsForPackageSearch(this.packageSearchColumns);
	                        }
	                    case "quick":
	                        {
	                            return [{
	                                name: "Artifact",
	                                displayName: "Artifact",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                cellTemplate: this.commonGridColumns.downloadableColumn("autotest-quick-artifact"),
	                                width: "25%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Path",
	                                displayName: "Path",
	                                field: "relativeDirPath",
	                                allowGrouping: true,
	                                cellTemplate: "<div class=\"autotest-quick-path ui-grid-cell-contents\">{{ row.entity.relativeDirPath}}</div>",
	                                width: "40%",
	                                customActions: [{
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }]
	                            }, {
	                                name: "Repository",
	                                displayName: "Repository",
	                                field: "repoKey",
	                                allowGrouping: true,
	                                cellTemplate: "<div class=\"autotest-quick-repository ui-grid-cell-contents\">{{ row.entity.repoKey}}</div>",
	                                width: "15%"
	                            }, {
	                                name: "Modified",
	                                displayName: "Modified",
	                                cellTemplate: "<div class=\"autotest-quick-modified ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                                field: "modifiedDate",
	                                width: "20%",
	                                actions: {
	                                    "delete": {
	                                        callback: function (row) {
	                                            return _this._deleteSelected([row]);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Delete");
	                                        }
	                                    }
	                                }
	                            }];
	                        }
	                    case "archive":
	                        {
	                            return [{
	                                name: "Name",
	                                displayName: "Name",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                width: "30%"
	                            }, {
	                                name: "Artifact",
	                                displayName: "Artifact",
	                                field: "archiveName",
	                                allowGrouping: true,
	                                width: "20%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Artifact Path",
	                                displayName: "Artifact Path",
	                                field: "archivePath",
	                                allowGrouping: true,
	                                width: "25%",
	                                customActions: [{
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }]
	                            }, {
	                                name: "Repository",
	                                displayName: "Repository",
	                                field: "repoKey",
	                                allowGrouping: true,
	                                width: "10%"
	                            }, {
	                                name: "Modified",
	                                displayName: "Modified",
	                                cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                                field: "modifiedDate",
	                                width: "15%",
	                                actions: {
	                                    "delete": {
	                                        callback: function (row) {
	                                            return _this._deleteSelected([row]);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Delete");
	                                        }
	                                    }
	                                }
	                            }];
	                        }
	                    case "gavc":
	                        {
	                            return [{
	                                name: "Artifact",
	                                displayName: "Artifact",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                width: "20%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }, {
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Group ID",
	                                displayName: "Group ID",
	                                field: "groupID",
	                                allowGrouping: true,
	                                width: "15%"
	                            }, {
	                                name: "Artifact ID",
	                                displayName: "Artifact ID",
	                                field: "artifactID",
	                                allowGrouping: true,
	                                width: "17%"
	                            }, {
	                                name: "Version",
	                                displayName: "Version",
	                                field: "version",
	                                allowGrouping: true,
	                                width: "13%"
	                            }, {
	                                name: "Classifier",
	                                displayName: "Classifier",
	                                field: "classifier",
	                                allowGrouping: true,
	                                width: "10%"
	                            }, {
	                                name: "Repository",
	                                displayName: "Repository",
	                                field: "repoKey",
	                                allowGrouping: true,
	                                width: "10%"
	                            }, {
	                                name: "Modified",
	                                displayName: "Modified",
	                                cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                                field: "modifiedDate",
	                                width: "15%",
	                                actions: {
	                                    "delete": {
	                                        callback: function (row) {
	                                            return _this._deleteSelected([row]);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Delete");
	                                        }
	                                    }
	                                }
	                            }];
	                        }
	                    case "property":
	                        {
	                            return [{
	                                name: "Item",
	                                displayName: "Item",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                width: "25%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Type",
	                                displayName: "Type",
	                                field: "resultType",
	                                cellTemplate: "<div class=\"ui-grid-cell-contents\">" + "<span jf-tooltip=\"{{ row.entity.resultType }}\" class=\"icon\" ng-class=\"{ 'icon-local-repo': row.entity.resultType === 'Repository', 'icon-folder': row.entity.resultType === 'Directory', 'icon-general': row.entity.resultType === 'File'}\"></span></div>",
	                                allowGrouping: true,
	                                width: "8%"
	                            }, {
	                                name: "Path",
	                                displayName: "Path",
	                                field: "relativeDirPath",
	                                allowGrouping: true,
	                                width: "37%",
	                                customActions: [{
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }]
	                            }, {
	                                name: "Repository",
	                                displayName: "Repository",
	                                field: "repoKey",
	                                allowGrouping: true,
	                                width: "15%"
	                            }, {
	                                name: "Modified",
	                                displayName: "Modified",
	                                cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                                field: "modifiedDate",
	                                width: "15%",
	                                actions: {
	                                    "delete": {
	                                        callback: function (row) {
	                                            return _this._deleteSelected([row]);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Delete");
	                                        }
	                                    }
	                                }
	                            }];
	                        }
	                    case "checksum":
	                        {
	                            return [{
	                                name: "Artifact",
	                                displayName: "Artifact",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                width: "25%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Path",
	                                displayName: "Path",
	                                field: "relativeDirPath",
	                                allowGrouping: true,
	                                width: "45%",
	                                customActions: [{
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }]
	                            }, {
	                                name: "Repository",
	                                displayName: "Repository",
	                                field: "repoKey",
	                                allowGrouping: true,
	                                width: "15%"
	                            }, {
	                                name: "Modified",
	                                displayName: "Modified",
	                                cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                                field: "modifiedDate",
	                                width: "15%",
	                                actions: {
	                                    "delete": {
	                                        callback: function (row) {
	                                            return _this._deleteSelected([row]);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Delete");
	                                        }
	                                    }
	                                }
	                            }];
	                        }
	                    case "remote":
	                        {
	                            return [{
	                                name: "Name",
	                                displayName: "Name",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                width: "20%",
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Path",
	                                displayName: "Path",
	                                field: "path",
	                                customActions: [{
	                                    icon: "icon icon-bintray",
	                                    tooltip: "Show In Bintray",
	                                    callback: function (row) {
	                                        return _this.showInBintray(row);
	                                    }
	                                }],
	                                width: "30%"
	                            }, {
	                                name: "Package",
	                                displayName: "Package",
	                                field: "package",
	                                width: "25%"
	                            }, {
	                                name: "Released",
	                                displayName: "Released",
	                                field: "release",
	                                width: "15%"
	                            }, {
	                                name: "Cached",
	                                displayName: "Cached",
	                                field: "cached",
	                                cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                                width: "10%"
	                            }];
	                        }
	                    case "trash":
	                        {
	                            return [{
	                                name: "Artifact",
	                                displayName: "Artifact",
	                                field: "name",
	                                sort: {
	                                    direction: this.uiGridConstants.ASC
	                                },
	                                cellTemplate: this.commonGridColumns.downloadableColumn("autotest-trash-artifact"),
	                                width: "25%",
	                                customActions: [{
	                                    icon: "icon icon-view",
	                                    tooltip: "View",
	                                    callback: function (row) {
	                                        return _this.viewCodeArtifact(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "View");
	                                    }
	                                }, {
	                                    icon: "icon icon-trashcan-restore",
	                                    tooltip: "Restore To Original Path",
	                                    callback: function (row) {
	                                        return _this.restoreTrashItem(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "Restore");
	                                    }
	                                }],
	                                actions: {
	                                    download: {
	                                        callback: function (row) {
	                                            return _this.downloadSelectedItems(row);
	                                        },
	                                        visibleWhen: function (row) {
	                                            return _.contains(row.actions, "Download");
	                                        }
	                                    }
	                                }
	                            }, {
	                                name: "Original Path",
	                                displayName: "Original Path",
	                                field: "relativeDirPath",
	                                allowGrouping: true,
	                                cellTemplate: "<div class=\"autotest-trash-origin-path ui-grid-cell-contents\">{{ row.entity.relativeDirPath}}</div>",
	                                width: "40%",
	                                customActions: [{
	                                    icon: "icon icon-show-in-tree",
	                                    tooltip: "Show In Tree",
	                                    callback: function (row) {
	                                        return _this.showInTree(row);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "ShowInTree");
	                                    }
	                                }]
	                            }, {
	                                name: "Original Repository",
	                                displayName: "Original Repository",
	                                field: "originRepository",
	                                allowGrouping: true,
	                                cellTemplate: "<div class=\"autotest-trash-origin-repository ui-grid-cell-contents\">{{ row.entity.originRepository}}</div>",
	                                width: "15%"
	                            }, {
	                                name: "Deleted Time",
	                                displayName: "Deleted Time",
	                                cellTemplate: "<div class=\"autotest-trash-deleted ui-grid-cell-contents\">{{ row.entity.deletedTimeString }}</div>",
	                                field: "deletedTime",
	                                width: "20%",
	                                customActions: [{
	                                    icon: "icon icon-clear",
	                                    tooltip: " Delete Permanently ", //Spaces are there to prevent text from splitting to two lines (RTFACT-13526)
	                                    callback: function (row) {
	                                        return _this._deleteSelected([row], true);
	                                    },
	                                    visibleWhen: function (row) {
	                                        return _.contains(row.actions, "Delete");
	                                    } }]
	                            }];
	                        }

	                }
	            }
	        },
	        _createPackageSearchColumnsObject: {
	            value: function _createPackageSearchColumnsObject() {
	                var _this = this;

	                this.packageSearchColumnsObject = {
	                    artifact: {
	                        name: "Artifact",
	                        displayName: "Artifact",
	                        field: "name",
	                        sort: {
	                            direction: this.uiGridConstants.ASC
	                        },
	                        cellTemplate: this.commonGridColumns.downloadableColumn(),
	                        width: "25%",
	                        customActions: [{
	                            icon: "icon icon-view",
	                            tooltip: "View",
	                            callback: function (row) {
	                                return _this.viewCodeArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.contains(row.actions, "View");
	                            }
	                        }],
	                        actions: {
	                            download: {
	                                callback: function (row) {
	                                    return _this.downloadSelectedItems(row);
	                                },
	                                visibleWhen: function (row) {
	                                    return _.contains(row.actions, "Download");
	                                }
	                            }
	                        }
	                    },
	                    path: {
	                        name: "Path",
	                        displayName: "Path",
	                        field: "relativePath",
	                        allowGrouping: true,
	                        width: "40%",
	                        customActions: [{
	                            icon: "icon icon-show-in-tree",
	                            tooltip: "Show In Tree",
	                            callback: function (row) {
	                                return _this.showInTree(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.contains(row.actions, "ShowInTree");
	                            }
	                        }]
	                    },
	                    repo: {
	                        name: "Repository",
	                        displayName: "Repository",
	                        field: "repoKey",
	                        allowGrouping: true,
	                        width: "15%"
	                    },
	                    modified: {
	                        name: "Modified",
	                        displayName: "Modified",
	                        cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
	                        field: "modifiedDate",
	                        width: "20%",
	                        actions: {
	                            "delete": {
	                                callback: function (row) {
	                                    return _this._deleteSelected([row]);
	                                },
	                                visibleWhen: function (row) {
	                                    return _.contains(row.actions, "Delete");
	                                }
	                            }
	                        }
	                    },
	                    groupID: {
	                        name: "Group ID",
	                        displayName: "Group ID",
	                        field: "groupID",
	                        allowGrouping: true,
	                        width: "18%"
	                    },
	                    artifactID: {
	                        name: "Artifact ID",
	                        displayName: "Artifact ID",
	                        field: "artifactID",
	                        allowGrouping: true,
	                        width: "18%"
	                    },
	                    version: {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version",
	                        allowGrouping: true,
	                        width: "18%"
	                    },
	                    classifier: {
	                        name: "Classifier",
	                        displayName: "Classifier",
	                        field: "classifier",
	                        allowGrouping: true,
	                        width: "18%"
	                    }
	                };
	            }
	        },
	        _getColumnsForPackageSearch: {
	            value: function _getColumnsForPackageSearch(columns) {
	                var _this = this;

	                var columnsArray = [];
	                columns.forEach(function (column) {
	                    if (!_.contains(column, "*")) {
	                        columnsArray.push(_.cloneDeep(_this.packageSearchColumnsObject[column]));
	                    } else {
	                        var groupable = false;
	                        var width = undefined;
	                        if (_.contains(column, "@")) {
	                            column = column.split("@").join("");
	                            groupable = true;
	                        }
	                        if (_.contains(column, "!")) {
	                            var _splitted = column.split("!");
	                            column = _splitted[0];
	                            width = _splitted[1];
	                        }

	                        var splitted = column.split("*");
	                        var field = splitted[0];
	                        var _name = splitted[1];
	                        columnsArray.push({
	                            name: _name,
	                            displayName: _name,
	                            field: "extraField_" + field,
	                            width: width || "18%",
	                            allowGrouping: groupable
	                        });
	                    }
	                });

	                this._normalizeGridColumnWidths(columnsArray);

	                if (!columnsArray[0].actions) columnsArray[0].actions = {};
	                if (!columnsArray[0].actions.download) {
	                    columnsArray[0].actions.download = {
	                        callback: function (row) {
	                            return _this.downloadSelectedItems(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.contains(row.actions, "Download");
	                        }
	                    };
	                }

	                //If no path field add 'show in tree' action to first column
	                if (_.findIndex(columnsArray, "name", "Path") < 0) {
	                    if (!columnsArray[0].customActions) columnsArray[0].customActions = [];
	                    columnsArray[0].customActions = [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.contains(row.actions, "ShowInTree");
	                        }
	                    }];
	                }
	                return columnsArray;
	            }
	        },
	        _normalizeGridColumnWidths: {
	            value: function _normalizeGridColumnWidths(columnsArray) {
	                var totalWidth = 0;
	                for (var key in columnsArray) {
	                    var obj = columnsArray[key];
	                    totalWidth += parseInt(obj.width);
	                }
	                var scale = 100 / totalWidth;
	                for (var key in columnsArray) {
	                    var obj = columnsArray[key];
	                    var origWidth = parseInt(obj.width);
	                    obj.width = origWidth * scale + "%";
	                }
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var relativePath = undefined;
	                var artifactPath = undefined;
	                if (this.currentSearch === "trash") {
	                    relativePath = (row.originRepository + "/" + row.relativeDirPath).split("[root]").join("");
	                    artifactPath = (row.repoKey + "/" + relativePath + "/" + row.name).split("//").join("/");
	                } else {
	                    relativePath = row.relativePath ? row.relativePath.startsWith("./") ? row.relativePath.substr(2) : row.relativePath : "";
	                    artifactPath = row.repoKey + "/" + (relativePath || row.path);
	                }

	                var archivePath = "";
	                if (row.archiveName) {
	                    if (row.archivePath === "[root]") {
	                        row.archivePath = "";
	                    }
	                    archivePath = row.repoKey + "/" + row.archivePath + row.archiveName;
	                }
	                var path = archivePath || artifactPath;
	                this.$state.go("artifacts.browsers.path", {
	                    browser: "tree",
	                    tab: "General",
	                    artifact: path
	                });
	            }
	        },
	        _updateStashStatus: {
	            value: function _updateStashStatus() {
	                var _this = this;

	                this.stashResultsDao.get({ name: "stash" }).$promise.then(function (data) {
	                    _this.stashedItemsCount = data.length;
	                    _this.showStashBox = true;
	                    if (data.length === 0) {
	                        _this.showStashBox = false;
	                        _this.savedToStash = false;
	                    }
	                });
	            }
	        },
	        _doStashAction: {
	            value: function _doStashAction(action) {
	                var _this = this;

	                var payload = this._buildPayloadForStash();
	                this.stashResultsDao[action]({ name: "stash" }, payload).$promise.then(function (response) {
	                    if (action === "save" && response.status === 200) {
	                        _this.savedToStash = true;
	                        _this.duringStashAnimation = false;
	                    }
	                    _this._updateStashStatus();
	                });
	            }
	        },
	        saveToStash: {
	            value: function saveToStash() {
	                var _this = this;

	                this.showStashBox = true;

	                /*let distanceRight = $('.repo-list-dropdown').width() + $('.repo-list-dropdown').offset().left - $('.repo-dnd-title').width() - $('.repo-dnd-title').offset().left;
	                 $('#stash-animation').css('right', distanceRight);*/
	                var distanceRight = $(document).width() - $("#stash-results-button").offset().left - $("#stash-results-button").width();
	                $("#stash-animation").css({
	                    right: distanceRight,
	                    "animation-duration": $(document).width() / 960
	                });

	                this.$timeout(function () {
	                    _this.duringStashAnimation = true;
	                    $("#stash-container").addClass("animate");

	                    _this.duringStashAnimation = true;

	                    _this._doStashAction("save");
	                });
	            }
	        },
	        addToStash: {
	            value: function addToStash() {
	                this._doStashAction("add");
	            }
	        },
	        subtractFromStash: {
	            value: function subtractFromStash() {
	                this._doStashAction("subtract");
	            }
	        },
	        intersectWithStash: {
	            value: function intersectWithStash() {
	                this._doStashAction("intersect");
	            }
	        },
	        gotoStash: {
	            value: function gotoStash() {
	                this.JFrogEventBus.dispatch(EVENTS.ACTION_REFRESH_STASH);
	                this.$state.go("artifacts.browsers.path", { browser: "stash", artifact: "", tab: "StashInfo" });
	            }
	        },
	        clearStash: {
	            value: function clearStash() {
	                var _this = this;

	                this.modal.confirm("Are you sure you want to clear stashed results? All items will be removed from stash.", "Clear Stashed Results", { confirm: "Clear" }).then(function () {
	                    _this.stashResultsDao["delete"]({ name: "stash" }).$promise.then(function (response) {
	                        _this.JFrogEventBus.dispatch(EVENTS.ACTION_DISCARD_STASH);
	                        if (response.status === 200) {
	                            _this.savedToStash = false;
	                            _this._updateStashStatus();
	                            $("#stash-container").removeClass("animate");
	                        }
	                    });
	                });
	            }
	        },
	        _buildPayloadForStash: {
	            value: function _buildPayloadForStash() {
	                var searchType = this.currentSearch;
	                if (searchType === "checksum") searchType = "quick";
	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                var rawResults = selectedRows.length ? selectedRows : this.results;

	                rawResults = _.filter(rawResults, function (result) {
	                    return !result.resultType || result.resultType == "File";
	                });

	                var payload = _.map(rawResults, function (result) {
	                    var retObj = {};
	                    retObj.type = searchType === "archive" ? "class" : searchType;
	                    retObj.repoKey = result.repoKey;

	                    if (searchType === "archive") {
	                        if (result.archivePath === "[root]") result.archivePath = "";
	                        retObj.name = result.name;
	                        retObj.archivePath = result.archivePath + result.archiveName;
	                    } else {
	                        if (result.relativePath === "[root]") result.relativePath = "";
	                        retObj.relativePath = result.relativePath;
	                    }

	                    return retObj;
	                });

	                return payload;
	            }
	        },
	        setShowAQL: {
	            value: function setShowAQL(show) {
	                var _this = this;

	                this.showAQL = show;
	                if (show) {
	                    (function () {
	                        var temp = _this.aql;
	                        _this.aql = "";
	                        _this.$timeout(function () {
	                            _this.aql = temp;
	                        });
	                    })();
	                }
	            }
	        },
	        downloadSelectedItems: {
	            value: function downloadSelectedItems(row) {}
	        },
	        getProperties: {
	            value: function getProperties() {
	                var _this = this;

	                this.artifactSearchDao.get({ search: "property", action: "keyvalue" }).$promise.then(function (_propeties) {
	                    _this.propertiesOptions = _propeties.data;
	                });
	            }
	        },
	        showInBintray: {
	            value: function showInBintray(row) {
	                this.$window.open("https://bintray.com/bintray/jcenter/" + row["package"], "");
	            }
	        },
	        viewCodeArtifact: {
	            value: function viewCodeArtifact(row) {
	                var _this = this;

	                var name = row.name;
	                if (_.startsWith(name, "./")) {
	                    name = name.slice(2);
	                }
	                if (row.archiveName) {
	                    if (row.archivePath === "[root]") {
	                        row.archivePath = "";
	                    }
	                    this.artifactViewSourceDao.fetch({
	                        archivePath: row.archivePath + row.archiveName,
	                        repoKey: row.repoKey,
	                        sourcePath: name
	                    }).$promise.then(function (result) {
	                        _this.modal.launchCodeModal(row.name, result.source, { name: row.type, json: true });
	                    });
	                } else {
	                    var data = {
	                        repoKey: row.repoKey,
	                        path: row.relativePath || row.path
	                    };
	                    this.artifactActionsDao.perform({ action: "view" }, data).$promise.then(function (result) {
	                        _this.modal.launchCodeModal(row.name, result.data.fileContent, { name: row.type, json: true });
	                    });
	                }
	            }
	        },
	        restoreTrashItem: {
	            value: function restoreTrashItem(row) {
	                var _this = this;

	                this.actions.perform({ name: "RestoreToOriginalPath" }, {
	                    data: {
	                        path: (row.originRepository + "/" + row.relativeDirPath + "/" + row.name).split("[root]").join(""),
	                        repoKey: row.repoKey
	                    }
	                }).then(function () {
	                    _this.reSearch();
	                });
	            }
	        },
	        getPrettySearchType: {
	            value: function getPrettySearchType(type) {
	                if (type === "trash") {
	                    return "Trash Can";
	                }if (type === "remote") {
	                    return "JCenter";
	                }if (type === "archive") {
	                    return "Archive Entries";
	                } else {
	                    return _.capitalize(type);
	                }
	            }
	        },
	        createJcenter: {
	            value: function createJcenter() {
	                var _this = this;

	                if (!this.currentUser.isAdmin()) {
	                    this.notifications.create({ warn: "Only an admin user can create repositories." });
	                    return false;
	                }
	                this.modal.confirm("A remote repository pointing to JCenter with default configuration values is about to be created.<br/>" + "If you wish to change it's configuration you can do so from the Remote Repositories menu in the Admin section", "Creating JCenter remote repository").then(function () {
	                    _this.repositoriesDao.createDefaultJcenterRepo().$promise.then(function () {
	                        return _this.isJcenterExists = true;
	                    }, function () {
	                        return "";
	                    });
	                });
	            }
	        },
	        onPackageTypeChange: {
	            value: function onPackageTypeChange() {
	                var _this = this;

	                if (this.selectedPackageType) {
	                    this.$timeout(function () {
	                        if (_this.packageController) _this.packageController.onPackageTypeChange(_this.selectedPackageType);
	                    }, 100);
	                    localStorage.lastPackageSearch = this.selectedPackageType.id;
	                }
	            }
	        },
	        _trackGaEvent: {
	            value: function _trackGaEvent(searchType) {
	                switch (searchType) {
	                    case "quick":
	                        if (this.$stateParams.fromHome) {
	                            this.GoogleAnalytics.trackEvent("Homepage", "Quick search");
	                            this.$stateParams.fromHome = false;
	                        } else {
	                            this.GoogleAnalytics.trackEvent("Search", "Quick");
	                        }
	                        break;
	                    case "package":
	                        this.GoogleAnalytics.trackEvent("Search", "Package", this.query.selectedPackageType.displayName);
	                        break;
	                    case "archive":
	                        this.GoogleAnalytics.trackEvent("Search", "Archive");
	                        break;
	                    case "property":
	                        this.GoogleAnalytics.trackEvent("Search", "Property");
	                        break;
	                    case "checksum":
	                        this.GoogleAnalytics.trackEvent("Search", "Checksum");
	                        break;
	                    case "remote":
	                        this.GoogleAnalytics.trackEvent("Search", "Remote");
	                        break;
	                    case "trash":
	                        this.GoogleAnalytics.trackEvent("Search", "Trash");
	                        break;
	                    default:
	                        {
	                            this.GoogleAnalytics.trackEvent("Search", "Unknown");
	                            break;
	                        }
	                }
	            }
	        }
	    });

	    return SearchStateController;
	})();

	// refresh the gridData in any case

	//        this.download(row.downloadLink);

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.searchQueryMaker = searchQueryMaker;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var searchDescriptor = _interopRequire(__webpack_require__(365));

	var searchQueryMakerController = (function () {
	    function searchQueryMakerController($q, $scope, $stateParams, $timeout) {
	        _classCallCheck(this, searchQueryMakerController);

	        this.$q = $q;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$scope = $scope;

	        this.whenGotPropertiesData = $q.defer();
	        this.whenInitiated = $q.defer();

	        this.orderIndex = 0;
	        this.initWatchers();
	    }

	    _createClass(searchQueryMakerController, {
	        initWatchers: {
	            value: function initWatchers() {
	                var _this = this;

	                this.$scope.$watch("queryMaker.searchType", function (newVal, oldVal) {
	                    if (newVal === "package") return;
	                    _this.queryDescriptor = _this.compileQueryDescriptor(_.find(searchDescriptor.searchTypes, function (type) {
	                        return type.searchTypeName.toLowerCase() === newVal.toLowerCase();
	                    }));
	                    _this.refreshAvailableCriteria();
	                    if (!_.isEqual(_this.$stateParams.searchType, _this.searchType)) _this.initQuery();else if (!_.isEmpty(_this.query)) _this.initFromURLQuery();else {
	                        _.extend(_this.query, _this.queryDescriptor.staticPayload);
	                        if (_this.query.search === "property") {
	                            _this.initQuery();
	                        }
	                        _this.whenInitiated.resolve();
	                    }

	                    _this.focusField = false;
	                    _this.$timeout(function () {
	                        return _this.focusField = true;
	                    });
	                });
	                this.$scope.$watch("queryMaker.repoList", function (newVal, oldVal) {
	                    if (!newVal.length) return;
	                    _this.whenInitiated.promise.then(function () {
	                        _this.selectionRepoList = _.map(newVal, function (repo) {
	                            return {
	                                text: repo.repoKey,
	                                iconClass: repo._iconClass,
	                                isSelected: _this.inititiatedByURL && _this.query.selectedRepositories ? _this.query.selectedRepositories.indexOf(repo.repoKey) !== -1 : false
	                            };
	                        });
	                        if (_this.inititiatedByURL) delete _this.inititiatedByURL;
	                    });
	                });
	                this.$scope.$watch("queryMaker.propertiesData", function (newVal, oldVal) {
	                    if (newVal) {
	                        _this.transformedPropertiesData = _.cloneDeep(newVal);
	                        _this.transformedPropertiesData.forEach(function (prop) {
	                            if (prop.propertyType === "MULTI_SELECT") {
	                                prop.values = _.map(prop.values, function (val) {
	                                    return {
	                                        text: val,
	                                        isSelected: false
	                                    };
	                                });
	                            }
	                        });
	                        _this.propertySetKeys = _.sortBy(_.map(_this.transformedPropertiesData, "key"));
	                        _this.whenGotPropertiesData.resolve();
	                    }
	                });
	            }
	        },
	        initQuery: {
	            value: function initQuery() {
	                var _this = this;

	                for (var key in this.query) delete this.query[key];

	                this.queryDescriptor.searchCriteria.forEach(function (criterion) {
	                    if (criterion.multi && !criterion.copy) {
	                        _this.query[criterion.field] = [];
	                        if (criterion["default"] || criterion.visible) _this.query[criterion.field].push({ key: "", values: [] });
	                    }
	                });

	                _.extend(this.query, this.queryDescriptor.staticPayload);

	                this.whenInitiated.resolve();
	            }
	        },
	        initFromURLQuery: {
	            value: function initFromURLQuery() {
	                var _this = this;

	                //        console.log(this.query);
	                this.whenGotPropertiesData.promise.then(function () {
	                    for (var key in _this.query) {
	                        if (key === "search") continue;
	                        var criterion = _.find(_this.queryDescriptor.searchCriteria, { field: key });
	                        if (criterion && criterion.multi && _this.query.search === "property") {
	                            criterion.visible = false;
	                            if (_this.query[key]) {
	                                for (var i in _this.query[key]) {
	                                    if (i > 0) {
	                                        var newCriterion = _this._createMultiCriterionCopy(criterion);
	                                        _this.queryDescriptor.searchCriteria.push(newCriterion);
	                                    } else {
	                                        criterion.visible = true;
	                                    }

	                                    if (key === "propertySetKeyValues") {
	                                        (function () {
	                                            var keyVal = _this.query[key][i];
	                                            var propData = _.find(_this.transformedPropertiesData, { key: keyVal.key });
	                                            if (propData.propertyType === "MULTI_SELECT") {
	                                                keyVal.values.forEach(function (val) {
	                                                    var selectionObj = _.find(propData.values, { text: val });
	                                                    if (selectionObj) selectionObj.isSelected = true;
	                                                });
	                                            }
	                                        })();
	                                    }
	                                }
	                            }
	                        } else {
	                            if (criterion && !criterion["default"] && !criterion.multi) criterion.visible = true;
	                        }
	                    }

	                    _.extend(_this.query, _this.queryDescriptor.staticPayload);

	                    _this.inititiatedByURL = true;
	                    _this.refreshAvailableCriteria();
	                    _this.$timeout(function () {
	                        if (_this.canSearch()) _this.search();
	                    });

	                    _this.whenInitiated.resolve();
	                });
	            }
	        },
	        compileQueryDescriptor: {
	            value: function compileQueryDescriptor(descriptor) {
	                descriptor = _.cloneDeep(descriptor);
	                for (var i in descriptor.searchCriteria) {
	                    var criterion = descriptor.searchCriteria[i];

	                    if (_.isString(criterion)) {
	                        var _global = _.find(searchDescriptor.globalSearchCriteria, { id: criterion });
	                        descriptor.searchCriteria[i] = _.cloneDeep(_global);
	                    } else if (criterion.multi) {
	                        criterion.index = 0;
	                        criterion.nextIndex = criterion["default"] || criterion.visible ? 1 : 0;
	                        if (criterion["default"]) {
	                            criterion["default"] = false;
	                            criterion.visible = true;
	                        }
	                    }
	                    descriptor.searchCriteria[i].order = this.orderIndex;
	                    this.orderIndex++;
	                }
	                return descriptor;
	            }
	        },
	        refreshAvailableCriteria: {
	            value: function refreshAvailableCriteria() {
	                this.availableCriteria = this.queryDescriptor ? _.filter(this.queryDescriptor.searchCriteria, function (criterion) {
	                    return !criterion["default"] && !criterion.visible || criterion.multi && !criterion.copy;
	                }) : [];
	            }
	        },
	        onRepoSelectionChange: {
	            value: function onRepoSelectionChange(criterion) {
	                var selectedRepos = _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                });
	                this.query[criterion.field] = _.map(selectedRepos, "text");
	            }
	        },
	        onAddCriteria: {
	            value: function onAddCriteria() {
	                var _this = this;

	                if (this.criterionToAdd.id === "limitRepo") {
	                    this.openLimitDropDown = true;
	                } else {
	                    this.openLimitDropDown = false;
	                }

	                if (this.criterionToAdd.multi) {
	                    (function () {
	                        var newCriterion = _this._createMultiCriterionCopy(_this.criterionToAdd);
	                        _this.queryDescriptor.searchCriteria.push(newCriterion);
	                        if (!_this.query[newCriterion.field]) _this.query[newCriterion.field] = [];
	                        _this.query[newCriterion.field].push({ key: "", values: [] });

	                        newCriterion.order = _this.orderIndex;

	                        newCriterion.autofocus = true;
	                        _this.$timeout(function () {
	                            newCriterion.autofocus = false;
	                        }, 500);

	                        _this.orderIndex++;
	                    })();
	                } else {
	                    (function () {
	                        _this.criterionToAdd.order = _this.orderIndex;
	                        _this.orderIndex++;

	                        _this.criterionToAdd.visible = true;

	                        var tempCrit = _this.criterionToAdd;
	                        tempCrit.autofocus = true;
	                        _this.$timeout(function () {
	                            tempCrit.autofocus = false;
	                        }, 500);

	                        if (_this.criterionToAdd.type === "boolean") {
	                            _this.query[_this.criterionToAdd.field] = true;
	                        } else if (_this.criterionToAdd.id === "limitRepo") {
	                            _this.query.selectedRepositories = [];
	                        }
	                    })();
	                }
	                this.criterionToAdd = null;
	                this.refreshAvailableCriteria();
	            }
	        },
	        _createMultiCriterionCopy: {
	            value: function _createMultiCriterionCopy(orig) {
	                var newCriterion = _.cloneDeep(orig);
	                newCriterion["default"] = false;
	                newCriterion.visible = true;
	                newCriterion.copy = true;
	                newCriterion.index = orig.nextIndex;
	                orig.nextIndex++;
	                delete newCriterion.nextIndex;
	                return newCriterion;
	            }
	        },
	        clearMultiValPropSetSelectedValues: {
	            value: function clearMultiValPropSetSelectedValues(criterion) {
	                if (criterion.multi && criterion.type === "keyValSet" && this.query[criterion.field][criterion.index]) {
	                    var propSet = this.getPropertySetByKey(this.query[criterion.field][criterion.index].key);
	                    if (propSet && propSet.propertyType === "MULTI_SELECT") {
	                        propSet.values.forEach(function (val) {
	                            val.isSelected = false;
	                        });
	                    }
	                }
	            }
	        },
	        removeCriterion: {
	            value: function removeCriterion(criterion) {
	                this.clearMultiValPropSetSelectedValues(criterion);
	                if (criterion.multi) {

	                    if (criterion.copy) {
	                        var criterionIndex = _.indexOf(this.queryDescriptor.searchCriteria, criterion);
	                        this.queryDescriptor.searchCriteria.splice(criterionIndex, 1);
	                    } else criterion.visible = false;

	                    this.queryDescriptor.searchCriteria.forEach(function (crit) {
	                        if (crit.field === criterion.field && crit.multi && crit.copy && crit.index > criterion.index) {
	                            crit.index--;
	                        } else if (crit.field === criterion.field && crit.multi && !crit.copy) {
	                            crit.nextIndex--;
	                        }
	                    });
	                    if (this.query[criterion.field]) this.query[criterion.field].splice(criterion.index, 1);
	                } else {
	                    criterion.visible = false;
	                    delete this.query[criterion.field];
	                    if (criterion.id === "limitRepo") {
	                        _.filter(this.selectionRepoList, function (repo) {
	                            return repo.isSelected;
	                        }).forEach(function (selRepo) {
	                            selRepo.isSelected = false;
	                        });
	                        delete this.query.selectedRepositories;
	                    }
	                }
	                this.refreshAvailablePropertySetKeys();
	                this.refreshAvailableCriteria();
	            }
	        },
	        search: {
	            value: function search() {
	                var _this = this;

	                if (!this.canSearch()) {
	                    return;
	                }this.$timeout(function () {
	                    return _this.parentController.search();
	                }, 50);
	            }
	        },
	        getPropertySetByKey: {
	            value: function getPropertySetByKey(key) {
	                return _.find(this.transformedPropertiesData, { key: key });
	            }
	        },
	        onMultiSelectPropertyChange: {
	            value: function onMultiSelectPropertyChange(criterion) {
	                var keyVal = this.query[criterion.field][criterion.index];
	                var values = this.getPropertySetByKey(keyVal.key).values;

	                keyVal.values = _.map(_.filter(values, function (val) {
	                    return val.isSelected;
	                }), "text");
	            }
	        },
	        onChangePropertySetKey: {
	            value: function onChangePropertySetKey(criterion) {
	                var keyVal = this.query[criterion.field][criterion.index];
	                keyVal.values = [];

	                this.refreshAvailablePropertySetKeys();
	            }
	        },
	        refreshAvailablePropertySetKeys: {
	            value: function refreshAvailablePropertySetKeys() {
	                var _this = this;

	                this.propertySetKeys = _.sortBy(_.map(this.transformedPropertiesData, "key"));
	                if (!this.query.propertySetKeyValues || !this.query.propertySetKeyValues.length) {
	                    return;
	                } else {
	                    this.query.propertySetKeyValues.forEach(function (keyVal) {
	                        if (keyVal.key) {
	                            var propType = _this.getPropertySetByKey(keyVal.key).propertyType;
	                            if (propType === "MULTI_SELECT") {
	                                var i = _this.propertySetKeys.indexOf(keyVal.key);
	                                if (i !== -1) {
	                                    _this.propertySetKeys.splice(i, 1);
	                                }
	                            }
	                        }
	                    });
	                }
	            }
	        },
	        canSearch: {
	            value: function canSearch() {
	                return this.form && this.form.$valid && this.isQueryValid();
	            }
	        },
	        isQueryValid: {
	            value: function isQueryValid() {
	                if (this.searchType === "property") {
	                    if ((!this.query.propertyKeyValues || !this.query.propertyKeyValues.length) && (!this.query.propertySetKeyValues || !this.query.propertySetKeyValues.length)) {
	                        return false;
	                    } else if (this.query.propertySetKeyValues && this.query.propertySetKeyValues.length) {
	                        var nullValFound = false;
	                        for (var i in this.query.propertySetKeyValues) {
	                            if (!this.query.propertySetKeyValues[i].key) {
	                                nullValFound = true;
	                                break;
	                            }
	                        }
	                        if (nullValFound) {
	                            return false;
	                        }
	                    }
	                } else if (this.searchType === "archive") {
	                    if (!this.query.name && !this.query.path) {
	                        return false;
	                    }
	                }

	                return true;
	            }
	        },
	        clear: {
	            value: function clear() {
	                var _this = this;

	                var refreshProps = false;
	                this.queryDescriptor.searchCriteria.forEach(function (criterion) {
	                    _this.clearMultiValPropSetSelectedValues(criterion);

	                    if (criterion["default"] || criterion.visible) {
	                        if (criterion.type === "string") {
	                            _this.query[criterion.field] = "";
	                        } else if (criterion.type === "boolean") {
	                            _this.query[criterion.field] = false;
	                        } else if (criterion.type === "array") {
	                            _this.query[criterion.field] = [];
	                            _.filter(_this.selectionRepoList, function (repo) {
	                                return repo.isSelected;
	                            }).forEach(function (selRepo) {
	                                selRepo.isSelected = false;
	                            });
	                        } else if (criterion.type === "keyVal" || criterion.type === "keyValSet") {
	                            _this.query[criterion.field][criterion.index] = { key: "", values: [] };
	                            refreshProps = true;
	                        }
	                    }
	                });
	                if (refreshProps) this.refreshAvailablePropertySetKeys();
	            }
	        }
	    });

	    return searchQueryMakerController;
	})();

	function searchQueryMaker() {
	    return {
	        restrict: "E",
	        scope: {
	            searchType: "=",
	            query: "=",
	            repoList: "=",
	            propertiesData: "=",
	            parentController: "="
	        },
	        controller: searchQueryMakerController,
	        controllerAs: "queryMaker",
	        bindToController: true,
	        templateUrl: "states/search/search_query_maker.html"
	    };
	}

/***/ }),
/* 365 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = {
	    globalSearchCriteria: [{
	        id: "limitRepo",
	        label: "Limit to Specific Repositories",
	        field: "selectedRepositories",
	        type: "array",
	        mandatory: false,
	        "default": false
	    }],
	    searchTypes: [{
	        searchTypeName: "Quick",
	        endPoint: "quick",
	        staticPayload: {
	            search: "quick"
	        },
	        searchCriteria: [{
	            label: "Value",
	            field: "query",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Archive",
	        endPoint: "class",
	        staticPayload: {
	            search: "class"
	        },
	        searchCriteria: [{
	            label: "Name",
	            field: "name",
	            type: "string",
	            mandatory: false,
	            "default": true
	        }, {
	            label: "Path",
	            field: "path",
	            type: "string",
	            mandatory: false,
	            "default": false
	        }, {
	            label: "Search Class Resources Only",
	            field: "searchClassOnly",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }, {
	            label: "Exclude Inner Classes",
	            field: "excludeInnerClasses",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Property",
	        endPoint: "property",
	        staticPayload: {
	            search: "property"
	        },
	        searchCriteria: [{
	            label: "Property",
	            field: "propertyKeyValues",
	            type: "keyVal",
	            multi: true,
	            mandatory: true,
	            "default": true
	        }, {
	            label: "Property Set",
	            field: "propertySetKeyValues",
	            type: "keyValSet",
	            multi: true,
	            mandatory: true,
	            "default": false
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Checksum",
	        endPoint: "checksum",
	        staticPayload: {
	            search: "checksum"
	        },
	        searchCriteria: [{
	            label: "Checksum",
	            field: "checksum",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Remote",
	        endPoint: "remote",
	        staticPayload: {
	            search: "remote"
	        },
	        searchCriteria: [{
	            label: "Search for",
	            field: "searchKey",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }]
	    }, {
	        searchTypeName: "Trash",
	        endPoint: "trash",
	        staticPayload: {
	            search: "trash"
	        },
	        searchCriteria: [{
	            label: "Query",
	            field: "query",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, {
	            label: "Checksum Search",
	            field: "isChecksum",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }]
	    }]
	};

/***/ }),
/* 366 */
/***/ (function(module, exports) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.packageSearch = packageSearch;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var packageSearchController = (function () {
	    function packageSearchController($scope, $state, $stateParams, ArtifactPackageSearchDao, $timeout, $q, ArtifactoryFeatures) {
	        var _this = this;

	        _classCallCheck(this, packageSearchController);

	        this.queryFields = [];

	        this.$q = $q;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.artifactPackageSearchDao = ArtifactPackageSearchDao;

	        this.parentController.packageController = this;

	        this.isOss = ArtifactoryFeatures.isOss();

	        $scope.$watch("packageSearch.repoList", function (newVal, oldVal) {
	            if (!newVal || !newVal.length) return;
	            _this.rawRepos = newVal;
	            _this.refreshRepoList();
	        });

	        this.init();
	    }

	    _createClass(packageSearchController, {
	        refreshRepoList: {
	            value: function refreshRepoList() {
	                this.selectionRepoList = _.map(this.getFilteredRepoList(this.rawRepos, this.selectedPackageType ? this.selectedPackageType.id : undefined), function (repo) {
	                    return {
	                        text: repo.repoKey,
	                        iconClass: repo._iconClass,
	                        isSelected: false
	                    };
	                });
	            }
	        },
	        init: {
	            value: function init() {
	                var _this = this;

	                if (this.query.selectedPackageType) {
	                    this.selectedPackageType = this.query.selectedPackageType;

	                    this.onPackageTypeChange().then(function () {
	                        if (_this.query.packagePayload) {
	                            (function () {
	                                var runSearch = false;
	                                _this.query.packagePayload.forEach(function (queryItem) {
	                                    if (_this.rawQuery[queryItem.id]) {
	                                        _this.rawQuery[queryItem.id].values = queryItem.values.join(",");
	                                        var queryField = _.find(_this.queryFields, { id: queryItem.id });
	                                        if (queryField.id !== "repo") runSearch = true;
	                                        if (queryField && !queryField["default"]) {
	                                            if (queryField.id !== "repo") {
	                                                queryField.visible = true;
	                                            } else {
	                                                (function () {
	                                                    var queryRepos = _.find(_this.query.packagePayload, { id: "repo" }).values;
	                                                    if (queryRepos.length) queryField.visible = true;else {
	                                                        var i = _.findIndex(_this.query.packagePayload, { id: "repo" });
	                                                        _this.query.packagePayload.splice(i, 1);
	                                                    }

	                                                    _this.selectionRepoList.forEach(function (repo) {
	                                                        if (queryRepos.indexOf(repo.text) !== -1) {
	                                                            repo.isSelected = true;
	                                                        }
	                                                    });
	                                                })();
	                                            }
	                                        }
	                                    }
	                                });
	                                if (_this.query.selectedPackageType.id === "dockerV1") {
	                                    _this.queryFields.push({
	                                        id: "dockerV1",
	                                        displayName: "V1 Images",
	                                        visible: true
	                                    });
	                                }
	                                _this.refreshAvailableCriteria();
	                                _this.onRepoSelectionChange();
	                                if (runSearch) _this.$timeout(function () {
	                                    if (_this.canSearch()) _this.search();
	                                });
	                            })();
	                        } else if (_this.query.selectedPackageType.id === "gavc") {
	                            for (var key in _this.rawQuery) {
	                                _this.rawQuery[key].values = _this.query[key];
	                                var queryField = _.find(_this.queryFields, { id: key });
	                                if (queryField && _this.query[key] && !queryField["default"]) {
	                                    queryField.visible = true;
	                                }
	                            }
	                            _this.$timeout(function () {
	                                if (_this.canSearch()) _this.search();else _this.parentController.refreshGrid();
	                            });
	                        } else _this.parentController.refreshGrid();
	                    });
	                } else {
	                    this.parentController.refreshGrid();
	                }

	                this.artifactPackageSearchDao.availablePackages().$promise.then(function (data) {
	                    data = _.filter(data, function (packageType) {
	                        return !packageType.id.startsWith("docker") && (!_this.isOss || packageType.id === "gavc");
	                    });
	                    var i = 0;
	                    _.forEach(data, function () {
	                        if (data[i].displayName === "GAVC") {
	                            data[i].displayName = "Maven GAVC";
	                        }
	                        i++;
	                    });
	                    if (!_this.isOss) {
	                        data.unshift({
	                            id: "dockerV2",
	                            icon: "docker",
	                            displayName: "Docker"
	                        });
	                    }

	                    _this.availablePackageTypes = _.sortBy(data, function (pack) {
	                        return pack.displayName;
	                    });

	                    if (_this.isOss) {
	                        _this.parentController.availablePackageTypes = _this.availablePackageTypes;
	                    }
	                });
	            }
	        },
	        onPackageTypeChange: {
	            value: function onPackageTypeChange(selectedPackageType) {
	                var _this = this;

	                var defer = this.$q.defer();

	                if (selectedPackageType && selectedPackageType === this.selectedPackageType) {
	                    defer.resolve();
	                    return defer.promise;
	                }

	                this.rawQuery = {};
	                this.$timeout(function () {
	                    if (selectedPackageType) {
	                        _this.selectedPackageType = selectedPackageType;
	                    } else {
	                        _this.parentController.selectedPackageType = _this.selectedPackageType;
	                    }

	                    _this.refreshRepoList();

	                    _this.query.selectedPackageType = _this.selectedPackageType;
	                    _this.parentController.updateUrl();
	                    if (_this.selectedPackageType.id === "gavc") {
	                        var gavcFields = [{ id: "groupID", displayName: "Group ID", allowedComparators: "", "default": true }, { id: "artifactID", displayName: "Artifact ID", allowedComparators: "", "default": true }, { id: "version", displayName: "Version", allowedComparators: "", "default": true }, { id: "classifier", displayName: "Classifier", allowedComparators: "", "default": false }, { id: "repo", displayName: "", allowedComparators: "" }];
	                        _this.queryFields = gavcFields;

	                        _this.refreshAvailableCriteria();

	                        _this.queryFields.forEach(function (field) {
	                            _this.rawQuery[field.id] = { comparator: field.allowedComparators[0] };
	                        });
	                        defer.resolve();
	                    } else {
	                        _this.artifactPackageSearchDao.queryFields({}, { packageType: _this.selectedPackageType.id }).$promise.then(function (data) {
	                            if (_this.selectedPackageType.id === "nuget") {
	                                data = _.filter(data, function (field) {
	                                    return field.id !== "nugetTags" && field.id !== "nugetDigest";
	                                });
	                            }
	                            _this.queryFields = data;
	                            _this.queryFields.forEach(function (field) {
	                                field["default"] = field.visibleByDefault;
	                                _this.rawQuery[field.id] = { comparator: field.allowedComparators[0] };
	                            });

	                            _this.refreshAvailableCriteria();

	                            defer.resolve();
	                        });
	                    }
	                });

	                this.focusField = false;
	                this.$timeout(function () {
	                    return _this.focusField = true;
	                });

	                return defer.promise;
	            }
	        },
	        _transformQuery: {
	            value: function _transformQuery(rawQuery) {
	                var transformed = undefined;
	                if (this.selectedPackageType.id === "gavc") {
	                    transformed = {};
	                    transformed.search = "gavc";
	                    for (var key in rawQuery) {
	                        if (rawQuery[key].values) {
	                            transformed[key] = rawQuery[key].values || "";
	                        }
	                    }
	                    if (this.selectedRepos) transformed.selectedRepositories = this.selectedRepos;
	                } else {
	                    transformed = [];
	                    for (var key in rawQuery) {
	                        if (rawQuery[key].values) {
	                            if (key !== "repo") transformed.push({
	                                id: key,
	                                /*
	                                 comparator: rawQuery[key].comparator,
	                                 */
	                                values: rawQuery[key].values.split(",")
	                            });
	                        }
	                    }
	                    var repoField = _.find(this.queryFields, { id: "repo" });

	                    if (repoField && repoField.visible) transformed.push({
	                        id: "repo",
	                        values: this.selectedRepos || []
	                    });
	                }

	                return transformed;
	            }
	        },
	        canSearch: {
	            value: function canSearch() {
	                var ret = false;
	                if (this.rawQuery) {
	                    for (var key in this.rawQuery) {
	                        if (key !== "repo" && this.rawQuery[key].values) {
	                            ret = true;
	                            break;
	                        }
	                    }
	                }
	                return ret;
	            }
	        },
	        search: {
	            value: function search() {
	                var _this = this;

	                if (!this.canSearch()) {
	                    return;
	                }var transformedQuery = this._transformQuery(this.rawQuery);
	                for (var key in this.query) delete this.query[key];
	                if (_.isArray(transformedQuery)) {
	                    this.query.packagePayload = transformedQuery;
	                } else {
	                    //gavc
	                    _.extend(this.query, transformedQuery);
	                }
	                this.query.selectedPackageType = this.selectedPackageType;
	                this.parentController.packageSearchColumns = this.getColumnsByPackage();
	                this.parentController.refreshGrid().then(function () {
	                    _this.$timeout(function () {
	                        return _this.parentController.search();
	                    });
	                });
	            }
	        },
	        clear: {
	            value: function clear() {
	                for (var key in this.rawQuery) {
	                    var field = this.rawQuery[key];
	                    if (field.values) delete field.values;
	                }

	                _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                }).forEach(function (repoSel) {
	                    repoSel.isSelected = false;
	                });
	                delete this.selectedRepos;
	            }
	        },
	        getColumnsByPackage: {
	            value: function getColumnsByPackage() {

	                switch (this.selectedPackageType.id) {
	                    case "gavc":
	                        return ["artifact", "groupID", "artifactID", "version", "classifier", "repo", "path", "modified"];
	                        break;
	                    case "dockerV1":
	                        return ["dockerV1Image*Image@", "dockerV1Tag*Tag@", "repo", "modified"];
	                        break;
	                    case "dockerV2":
	                        return ["dockerV2Image*Image@", "dockerV2Tag*Tag@", "repo", "modified"];
	                        break;
	                    case "nuget":
	                        return ["nugetPackageId*Package ID", "nugetVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "npm":
	                        return ["npmName*Package Name", "npmVersion*Version@", "npmScope*Scope@", "repo", "path", "modified"];
	                        break;
	                    case "puppet":
	                        return ["puppetName*Name", "puppetVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "bower":
	                        return ["bowerName*Package Name", "bowerVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "debian":
	                        return ["artifact", "repo", "path", "debianDistribution*Distribution@", "debianComponent*Component@", "debianArchitecture*Architecture@", "modified"];
	                        break;
	                    case "pypi":
	                        return ["pypiName*Name", "pypiVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "gems":
	                        return ["gemName*Name", "gemVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "rpm":
	                        return ["rpmName*Name", "rpmVersion*Version@", "rpmArchitecture*Architecture@", "repo", "path", "modified"];
	                        break;
	                    case "vagrant":
	                        return ["vagrantName*Box Name", "vagrantVersion*Box Version@", "vagrantProvider*Box Provider@", "repo", "path", "modified"];
	                        break;
	                    case "conan":
	                        return ["conanName*Name@", "conanVersion*Version@", "conanUser*User@", "conanChannel*Channel@", "repo", "modified"];
	                        break;
	                    default:
	                        return ["artifact", "repo", "path", "modified"];
	                }
	            }
	        },
	        refreshAvailableCriteria: {
	            value: function refreshAvailableCriteria() {
	                if (this.queryFields) {
	                    var criteria = _.filter(this.queryFields, function (criterion) {
	                        return !criterion["default"] && !criterion.visible;
	                    });

	                    this.availableCriteria = _.map(criteria, function (criterion) {
	                        if (criterion.id === "repo") {
	                            criterion.displayName = "Limit to Specific Repositories";
	                        }
	                        return criterion;
	                    });

	                    if (this.selectedPackageType.id === "dockerV2") {
	                        this.availableCriteria.push({
	                            id: "dockerV1",
	                            displayName: "V1 Images"
	                        });
	                    }
	                } else {
	                    this.availableCriteria = [];
	                }
	            }
	        },
	        onAddCriteria: {
	            value: function onAddCriteria() {
	                var _this = this;

	                if (this.criterionToAdd.id === "dockerV1") {
	                    //            this.selectedPackageType = _.find(this.availablePackageTypes,{id: 'dockerV1'});
	                    this.selectedPackageType.id = this.criterionToAdd.id;
	                    this.onPackageTypeChange().then(function () {
	                        _this.queryFields.push({
	                            id: "dockerV1",
	                            displayName: "V1 Images",
	                            visible: true
	                        });
	                    });
	                } else if (this.criterionToAdd.id === "repo") {
	                    this.openLimitDropDown = true;
	                    this.selectedRepos = [];
	                } else {
	                    (function () {
	                        var tempCrit = _this.criterionToAdd;
	                        tempCrit.autofocus = true;
	                        _this.$timeout(function () {
	                            tempCrit.autofocus = false;
	                        }, 500);
	                    })();
	                }
	                this.criterionToAdd.visible = true;
	                this.criterionToAdd = null;
	                this.refreshAvailableCriteria();
	            }
	        },
	        removeCriterion: {
	            value: function removeCriterion(criterion) {
	                criterion.visible = false;
	                delete this.rawQuery[criterion.id];
	                if (criterion.id === "repo") {
	                    _.filter(this.selectionRepoList, function (repo) {
	                        return repo.isSelected;
	                    }).forEach(function (selRepo) {
	                        selRepo.isSelected = false;
	                    });
	                    delete this.selectedRepos;
	                } else if (criterion.id === "dockerV1") {
	                    this.selectedPackageType.id = "dockerV2";
	                    this.onPackageTypeChange();
	                }

	                this.refreshAvailableCriteria();
	            }
	        },
	        onRepoSelectionChange: {
	            value: function onRepoSelectionChange(criterion) {
	                var selectedRepos = _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                });
	                this.selectedRepos = _.map(selectedRepos, "text");
	            }
	        },
	        getFilteredRepoList: {
	            value: function getFilteredRepoList(unfiltered, packageType) {

	                //        let lastIncluded = this.query.selectedRepositories || [];// (this.$stateParams.searchParams && this.$stateParams.searchParams.selectedRepos) ? this.$stateParams.searchParams.selectedRepos : [];

	                if (!packageType) {
	                    return unfiltered;
	                }var filterFunc = function (repo) {
	                    var ret = undefined;
	                    if (packageType.startsWith("docker")) {
	                        if (packageType.endsWith("V1")) ret = repo.repoType.toLowerCase() === "docker" && repo.dockerApiVersion === "V1";else if (packageType.endsWith("V2")) ret = repo.repoType.toLowerCase() === "docker" && repo.dockerApiVersion === "V2";
	                    } else if (packageType === "rpm") {
	                        ret = repo.repoType.toLowerCase() === "yum";
	                    } else if (packageType === "gavc") {
	                        ret = repo.repoType.toLowerCase() === "maven" || repo.repoType.toLowerCase() === "ivy" || repo.repoType.toLowerCase() === "sbt" || repo.repoType.toLowerCase() === "gradle";
	                    } else ret = repo.repoType.toLowerCase() === packageType.toLowerCase();

	                    return ret;
	                };

	                return _.filter(unfiltered, filterFunc);
	                /*
	                        this.query.selectedRepositories = _.filter(lastIncluded, filterFunc);;
	                
	                        this.repoList = _.filter(this.allRepoList,(repo)=>{
	                            return filterFunc(repo) && !_.find(lastIncluded,{repoKey: repo.repoKey})
	                        });
	                */
	            }
	        }
	    });

	    return packageSearchController;
	})();

	function packageSearch() {
	    return {
	        restrict: "E",
	        scope: {
	            query: "=",
	            parentController: "=",
	            repoList: "="
	        },
	        controller: packageSearchController,
	        controllerAs: "packageSearch",
	        bindToController: true,
	        templateUrl: "states/search/package_search.html"
	    };
	}

/***/ })
]);